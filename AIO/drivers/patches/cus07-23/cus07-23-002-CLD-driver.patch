diff -urN qcacld-new.orig/CORE/BAP/src/btampHCI.c qcacld-new/CORE/BAP/src/btampHCI.c
--- qcacld-new.orig/CORE/BAP/src/btampHCI.c	2016-05-16 10:58:07.418298648 +0800
+++ qcacld-new/CORE/BAP/src/btampHCI.c	2016-05-16 10:58:08.842298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**
   * \file btampHCI.c
@@ -635,7 +636,7 @@
     else
     {
         /* Maximum of 5 triplets allowed, based on size of triplets definition */
-        if (tlvlen / 3 > 5)
+        if (tlvlen > 15)
         {
             tlvlen = 15;
         }
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt.h qcacld-new/CORE/CLD_TXRX/HTT/htt.h
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt.h	2016-05-16 10:58:07.442298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt.h	2016-05-16 10:58:08.858298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -597,7 +598,6 @@
     (((_var) & HTT_TX_DESC_NO_ENCRYPT_M) >> HTT_TX_DESC_NO_ENCRYPT_S)
 #define HTT_TX_DESC_NO_ENCRYPT_SET(_var, _val)            \
     do {                                                   \
-        HTT_CHECK_SET_VAL(HTT_TX_DESC_NO_ENCRYPT, _val);  \
         ((_var) |= ((_val) << HTT_TX_DESC_NO_ENCRYPT_S)); \
     } while (0)
 
@@ -637,7 +637,6 @@
     (((_var) & HTT_TX_DESC_FRM_LEN_M) >> HTT_TX_DESC_FRM_LEN_S)
 #define HTT_TX_DESC_FRM_LEN_SET(_var, _val)            \
     do {                                               \
-        HTT_CHECK_SET_VAL(HTT_TX_DESC_FRM_LEN, _val);  \
         ((_var) |= ((_val) << HTT_TX_DESC_FRM_LEN_S)); \
     } while (0)
 
@@ -645,7 +644,6 @@
     (((_var) & HTT_TX_DESC_FRM_ID_M) >> HTT_TX_DESC_FRM_ID_S)
 #define HTT_TX_DESC_FRM_ID_SET(_var, _val)            \
     do {                                              \
-        HTT_CHECK_SET_VAL(HTT_TX_DESC_FRM_ID, _val);  \
         ((_var) |= ((_val) << HTT_TX_DESC_FRM_ID_S)); \
     } while (0)
 
@@ -1233,7 +1231,6 @@
      HTT_H2T_STATS_REQ_CFG_STAT_TYPE_S)
 #define HTT_H2T_STATS_REQ_CFG_STAT_TYPE_SET(_var, _val)            \
     do {                                                         \
-        HTT_CHECK_SET_VAL(HTT_H2T_STATS_REQ_CFG_STAT_TYPE, _val);  \
         ((_var) |= ((_val) << HTT_H2T_STATS_REQ_CFG_STAT_TYPE_S)); \
     } while (0)
 
@@ -1283,7 +1280,6 @@
      HTT_H2T_SYNC_COUNT_S)
 #define HTT_H2T_SYNC_COUNT_SET(_var, _val)            \
     do {                                              \
-        HTT_CHECK_SET_VAL(HTT_H2T_SYNC_COUNT, _val);  \
         ((_var) |= ((_val) << HTT_H2T_SYNC_COUNT_S)); \
     } while (0)
 
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_h2t.c qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_h2t.c	2016-05-16 10:58:07.434298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_h2t.c	2016-05-16 10:58:08.850298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**
  * @file htt_h2t.c
@@ -512,6 +513,7 @@
         /* FIX THIS - add more details? */
         adf_os_print("%#x %#x stats not supported\n",
             stats_type_upload_mask, stats_type_reset_mask);
+        htt_htc_pkt_free(pdev, pkt);
         return -1; /* failure */
     }
 
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_rx.c qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_rx.c	2016-05-16 10:58:07.442298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_rx.c	2016-05-16 10:58:08.850298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**
  * @file htt_rx.c
@@ -468,11 +469,29 @@
                 *(word_ptr + 3) = rx_desc->pn_127_96;
                 /* bits 63:0 */
                 *(word_ptr + 2) = rx_desc->pn_95_64;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+				/* bits 48:0
+				 * copy 64 bits
+				 */
+				*(word_ptr + 1) = rx_desc->u0.pn_63_32;
+				/* bits 23:0
+				 * copy 32 bits
+				 */
+				*(word_ptr + 0) = rx_desc->pn_31_0;
+				break;
+#endif
             case 48:
                 /* bits 48:0
                  * copy 64 bits
                  */
                 *(word_ptr + 1) = rx_desc->u0.pn_63_32;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+				/* bits 23:0
+				 * copy 32 bits
+				 */
+				*(word_ptr + 0) = rx_desc->pn_31_0;
+				break;
+#endif
             case 24:
                 /* bits 23:0
                  * copy 32 bits
@@ -894,7 +913,7 @@
     }
     msdu = *head_msdu = htt_rx_netbuf_pop(pdev);
     while (1) {
-        int last_msdu, msdu_len_invalid, msdu_chained;
+        int last_msdu, msdu_len_invalid, msdu_chained = 0;
         int byte_offset;
 
         /*
@@ -2130,7 +2149,7 @@
         htt_list_remove(pdev->rx_ring.hash_table[i].freepool.next);
     }
     else {
-        hash_element = adf_os_mem_alloc(pdev->osdev, sizeof(hash_element));
+        hash_element = adf_os_mem_alloc(pdev->osdev, sizeof(struct htt_rx_hash_entry));
         if (adf_os_unlikely(NULL == hash_element)) {
             HTT_ASSERT_ALWAYS(0);
             return 1;
diff -urN qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_tx.c qcacld-new/CORE/CLD_TXRX/HTT/htt_tx.c
--- qcacld-new.orig/CORE/CLD_TXRX/HTT/htt_tx.c	2016-05-16 10:58:07.434298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/HTT/htt_tx.c	2016-05-16 10:58:08.850298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**
  * @file htt_tx.c
@@ -78,7 +79,7 @@
 {
     int i, pool_size;
     u_int32_t **p;
-    adf_os_dma_addr_t pool_paddr;
+    adf_os_dma_addr_t pool_paddr = 0;
 
     if (pdev->cfg.is_high_latency) {
         pdev->tx_descs.size = sizeof(struct htt_host_tx_desc_t);
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TLSHIM/tl_shim.c qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c
--- qcacld-new.orig/CORE/CLD_TXRX/TLSHIM/tl_shim.c	2016-05-16 10:58:07.434298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TLSHIM/tl_shim.c	2016-05-16 10:58:08.850298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include "vos_sched.h"
 #include "wlan_qct_tl.h"
@@ -1151,6 +1152,7 @@
 #endif /* QCA_LL_TX_FLOW_CT */
 }
 
+
 /*
  * TL API to transmit a frame given by HDD. Returns NULL
  * in case of success, skb pointer in case of failure.
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_rx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_rx.c	2016-05-16 10:58:07.458298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_rx.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <adf_nbuf.h>          /* adf_nbuf_t, etc. */
 #include <adf_os_io.h>         /* adf_os_cpu_to_le64 */
@@ -1039,7 +1040,9 @@
         TXRX_PRINT(TXRX_PRINT_LEVEL_ERR,
                    "%s: Invalid pdev passed!\n", __FUNCTION__);
         adf_os_assert_always(pdev);
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         return;
+#endif
     }
 
     /*
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx.c	2016-05-16 10:58:07.458298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /* OS abstraction libraries */
 #include <adf_nbuf.h>         /* adf_nbuf_t, etc. */
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_classify.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_classify.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_classify.c	2016-05-16 10:58:07.466298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_classify.c	2016-05-16 10:58:08.870298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <adf_nbuf.h>         /* adf_nbuf_t, etc. */
 #include <htt.h>              /* HTT_TX_EXT_TID_MGMT */
@@ -360,6 +361,9 @@
     dest_addr = ol_tx_dest_addr_find(pdev, tx_nbuf);
     if (IEEE80211_IS_MULTICAST(dest_addr)) {
         txq = &vdev->txqs[OL_TX_VDEV_MCAST_BCAST];
+        if (txq->flag == ol_tx_queue_paused) {
+            return NULL;
+        }
         tx_msdu_info->htt.info.ext_tid = HTT_TX_EXT_TID_NON_QOS_MCAST_BCAST;
         if (vdev->opmode == wlan_op_mode_sta) {
             /*
@@ -499,8 +503,15 @@
         if (ol_txrx_peer_state_auth != peer->state) {
             tx_msdu_info->htt.action.do_encrypt = 0;
         }
-        txq = &peer->txqs[tid];
-        tx_msdu_info->htt.info.ext_tid = tid;
+
+        //change EAPOL TID to mgmt tid
+        if (tid == TX_EAPOL_TID) {
+            txq = &vdev->txqs[OL_TX_VDEV_DEFAULT_MGMT];
+            tx_msdu_info->htt.info.ext_tid = OL_TX_VDEV_DEFAULT_MGMT;
+        } else {
+            txq = &peer->txqs[tid];
+            tx_msdu_info->htt.info.ext_tid = tid;
+        }
         /*
          * The following line assumes each peer object has a single ID.
          * This is currently true, and is expected to remain true.
@@ -538,7 +549,7 @@
     OL_TX_CLASSIFY_EXTENSION(vdev, tx_desc, tx_nbuf, tx_msdu_info, txq);
     if (IEEE80211_IS_MULTICAST(dest_addr) && vdev->opmode != wlan_op_mode_sta) {
 
-        TXRX_PRINT(TXRX_PRINT_LEVEL_ERR,
+        TXRX_PRINT(TXRX_PRINT_LEVEL_INFO2,
                       "%s: remove the peer reference %p\n", __func__, peer);
         /* remove the peer reference added above */
         ol_txrx_peer_unref_delete(tx_msdu_info->peer);
@@ -575,6 +586,9 @@
          * STA: probe requests can be either broadcast or unicast
          */
         txq = &vdev->txqs[OL_TX_VDEV_DEFAULT_MGMT];
+        if (txq->flag == ol_tx_queue_paused) {
+            return NULL;
+        }
         tx_msdu_info->htt.info.peer_id = HTT_INVALID_PEER_ID;
         tx_msdu_info->peer = NULL;
         tx_msdu_info->htt.info.is_unicast = 0;
@@ -604,6 +618,9 @@
         tx_msdu_info->peer = peer;
         if (!peer) {
             txq = &vdev->txqs[OL_TX_VDEV_DEFAULT_MGMT];
+            if (txq->flag == ol_tx_queue_paused) {
+                return NULL;
+            }
             tx_msdu_info->htt.info.peer_id = HTT_INVALID_PEER_ID;
         } else {
             txq = &peer->txqs[HTT_TX_EXT_TID_MGMT];
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_queue.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_queue.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_queue.c	2016-05-16 10:58:07.450298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_queue.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <adf_nbuf.h>         /* adf_nbuf_t, etc. */
 #include <adf_os_atomic.h>    /* adf_os_atomic_add, etc. */
@@ -212,6 +213,7 @@
     }
 }
 
+
 void
 ol_tx_enqueue(
     struct ol_txrx_pdev_t *pdev,
@@ -541,6 +543,60 @@
 
 #if defined(CONFIG_HL_SUPPORT) || defined(QCA_SUPPORT_TXRX_VDEV_PAUSE_LL)
 
+#if defined(CONFIG_HL_SUPPORT)
+void
+ol_txrx_vdev_pause_txq(ol_txrx_vdev_handle vdev)
+{
+    struct ol_tx_frms_queue_t *txq;
+    int i;
+
+    for (i = 0; i < OL_TX_VDEV_NUM_QUEUES; i++) {
+        txq = &vdev->txqs[i];
+        if (txq->paused_count.total++ == 0) {
+            txq->flag = ol_tx_queue_paused;
+        }
+    }
+}
+
+void
+ol_txrx_vdev_unpause_txq(ol_txrx_vdev_handle vdev)
+{
+    struct ol_tx_frms_queue_t *txq;
+    int i;
+
+    for (i = 0; i < OL_TX_VDEV_NUM_QUEUES; i++) {
+        txq = &vdev->txqs[i];
+        if (--txq->paused_count.total == 0) {
+            if (txq->frms == 0) {
+                txq->flag = ol_tx_queue_empty;
+            } else {
+                struct ol_tx_sched_notify_ctx_t notify_ctx;
+                struct ol_txrx_pdev_t *pdev = vdev->pdev;
+                struct ol_tx_desc_t *tx_desc = TAILQ_FIRST(&txq->head);
+                notify_ctx.event = OL_TX_UNPAUSE_QUEUE;
+                notify_ctx.txq = txq;
+                notify_ctx.info.ext_tid = adf_nbuf_get_tid(tx_desc->netbuf);;
+                ol_tx_sched_notify(pdev, &notify_ctx);
+
+                txq->flag = ol_tx_queue_active;
+                /*
+                 * Now that the are new tx frames available to download,
+                 * invoke the scheduling function, to see if it wants to
+                 * download the new frames.
+                 * Since the queue lock is currently held, and since
+                 * the scheduler function takes the lock, temporarily
+                 * release the lock.
+                 */
+                adf_os_spin_unlock_bh(&pdev->tx_queue_spinlock);
+                ol_tx_sched(pdev);
+                adf_os_spin_lock_bh(&pdev->tx_queue_spinlock);
+            }
+        }
+    }
+}
+#endif
+
+
 void
 ol_txrx_vdev_pause(ol_txrx_vdev_handle vdev, u_int32_t reason)
 {
@@ -556,6 +612,8 @@
         TAILQ_FOREACH(peer, &vdev->peer_list, peer_list_elem) {
             ol_txrx_peer_pause_base(pdev, peer);
         }
+        if (reason == 0)
+            ol_txrx_vdev_pause_txq(vdev);
         adf_os_spin_unlock_bh(&pdev->tx_queue_spinlock);
 #endif /* defined(CONFIG_HL_SUPPORT) */
     } else {
@@ -586,6 +644,8 @@
                 ol_txrx_peer_tid_unpause_base(pdev, peer, i);
             }
         }
+        if (reason == 0)
+            ol_txrx_vdev_unpause_txq(vdev);
         adf_os_spin_unlock_bh(&pdev->tx_queue_spinlock);
 #endif /* defined(CONFIG_HL_SUPPORT) */
     } else {
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx.c	2016-05-16 10:58:07.450298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*=== includes ===*/
 /* header files for OS primitives */
@@ -154,11 +155,14 @@
     struct ol_txrx_pdev_t *pdev,
     u_int8_t local_peer_id)
 {
-    if ((local_peer_id == OL_TXRX_INVALID_LOCAL_PEER_ID) ||
-        (local_peer_id >= OL_TXRX_NUM_LOCAL_PEER_IDS)) {
+    struct ol_txrx_peer_t *peer;
+    if (local_peer_id >= OL_TXRX_NUM_LOCAL_PEER_IDS) {
         return NULL;
     }
-    return pdev->local_peer_ids.map[local_peer_id];
+    adf_os_spin_lock_bh(&pdev->local_peer_ids.lock);
+    peer = pdev->local_peer_ids.map[local_peer_id];
+    adf_os_spin_unlock_bh(&pdev->local_peer_ids.lock);
+    return peer;
 }
 
 static void
@@ -1432,18 +1436,19 @@
         /* check whether the parent vdev has no peers left */
         if (TAILQ_EMPTY(&vdev->peer_list)) {
             /*
-             * Now that there are no references to the peer, we can
-             * release the peer reference lock.
-             */
-            adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
-            /*
              * Check if the parent vdev was waiting for its peers to be
              * deleted, in order for it to be deleted too.
              */
-            if (vdev->delete.pending) {
+            if (vdev->delete.pending == 1) {
                 ol_txrx_vdev_delete_cb vdev_delete_cb = vdev->delete.callback;
                 void *vdev_delete_context = vdev->delete.context;
 
+                /*
+                 * Now that there are no references to the peer, we can
+                 * release the peer reference lock.
+                 */
+                adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
+
                 TXRX_PRINT(TXRX_PRINT_LEVEL_INFO1,
                     "%s: deleting vdev object %p "
                     "(%02x:%02x:%02x:%02x:%02x:%02x)"
@@ -1452,11 +1457,46 @@
                     vdev->mac_addr.raw[0], vdev->mac_addr.raw[1],
                     vdev->mac_addr.raw[2], vdev->mac_addr.raw[3],
                     vdev->mac_addr.raw[4], vdev->mac_addr.raw[5]);
+#if defined(CONFIG_HL_SUPPORT)
+                if (ol_cfg_is_high_latency(pdev->ctrl_pdev)) {
+                    struct ol_tx_frms_queue_t *txq;
+
+                    for (i = 0; i < OL_TX_VDEV_NUM_QUEUES; i++) {
+                        txq = &vdev->txqs[i];
+                        ol_tx_queue_free(pdev, txq, (i + OL_TX_NUM_TIDS));
+                    }
+                }
+#endif /* defined(CONFIG_HL_SUPPORT) */
+
                 /* all peers are gone, go ahead and delete it */
+#if defined(CONFIG_PER_VDEV_TX_DESC_POOL)
+                if (adf_os_atomic_read(&vdev->tx_desc_count)) {
+                    for (i = 0; i < pdev->tx_desc.pool_size; i++) {
+                        if (pdev->tx_desc.array[i].tx_desc.vdev == vdev) {
+                            void *htt_tx_desc;
+                            if (adf_os_atomic_read(&pdev->tx_desc.array[i].tx_desc.ref_cnt)) {
+                                TXRX_PRINT(TXRX_PRINT_LEVEL_WARN,
+                                           "Warning: freeing tx frame "
+                                           "(no tx completion from the target)\n");
+                                ol_tx_desc_frame_free_nonstd(pdev, &pdev->tx_desc.array[i].tx_desc, 1);
+                            }
+                            htt_tx_desc = pdev->tx_desc.array[i].tx_desc.htt_tx_desc;
+                            htt_tx_desc_free(pdev->htt_pdev, htt_tx_desc);
+                        }
+                    }
+                    if (adf_os_atomic_read(&vdev->tx_desc_count)) {
+                        TXRX_PRINT(TXRX_PRINT_LEVEL_ERR,
+                                   "tx_desc_count is %d for vdev %p\n",
+                                   adf_os_atomic_read(&vdev->tx_desc_count), vdev);
+                    }
+                }
+#endif
                 adf_os_mem_free(vdev);
                 if (vdev_delete_cb) {
                     vdev_delete_cb(vdev_delete_context);
                 }
+            } else {
+                adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
             }
         } else {
             adf_os_spin_unlock_bh(&pdev->peer_ref_mutex);
@@ -1555,6 +1595,34 @@
     return peer;
 }
 
+/**
+ * ol_txrx_dump_tx_desc() - dump tx desc info
+ * @pdev_handle: Pointer to pdev handle
+ *
+ * Return: none
+ */
+void ol_txrx_dump_tx_desc(ol_txrx_pdev_handle pdev_handle)
+{
+        struct ol_txrx_pdev_t *pdev = pdev_handle;
+        int total;
+
+        if (ol_cfg_is_high_latency(pdev->ctrl_pdev)) {
+#ifdef HIF_USB
+                total = ol_tx_desc_pool_size_hl(pdev->ctrl_pdev);
+#else
+                total = adf_os_atomic_read(&pdev->orig_target_tx_credit);
+#endif
+        } else {
+                total = ol_cfg_target_tx_credit(pdev->ctrl_pdev);
+        }
+
+        TXRX_PRINT(TXRX_PRINT_LEVEL_ERR,
+                "Total tx credits %d free_credits %d",
+                total, pdev->tx_desc.num_free);
+
+        return;
+}
+
 int
 ol_txrx_get_tx_pending(ol_txrx_pdev_handle pdev_handle)
 {
@@ -1574,6 +1642,20 @@
 #endif
 }
 
+#if defined(CONFIG_HL_SUPPORT)
+int
+ol_txrx_get_tx_pending_hl(ol_txrx_pdev_handle pdev_handle)
+{
+    struct ol_txrx_pdev_t *pdev = (ol_txrx_pdev_handle)pdev_handle;
+    int total;
+
+    total = ol_tx_desc_pool_size_hl(pdev->ctrl_pdev);
+
+    return (total - pdev->tx_desc.num_free);
+}
+#endif
+
+
 void
 ol_txrx_discard_tx_pending(ol_txrx_pdev_handle pdev_handle)
 {
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_event.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_event.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_event.c	2016-05-16 10:58:07.450298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_event.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include "ol_txrx_types.h"
 
@@ -86,7 +87,7 @@
     /*
      * Input validation
      */
-    if (!event) {
+    if (event == 0) {
         adf_os_print("Invalid WDI event in %s\n", __FUNCTION__);
         return;
     }
@@ -123,7 +124,7 @@
         adf_os_print("Invalid callback in %s", __FUNCTION__);
         return A_ERROR;
     }
-    if ((!event) || (event >= WDI_EVENT_LAST) || (event < WDI_EVENT_BASE)) {
+    if ((event == 0) || (event >= WDI_EVENT_LAST) || (event < WDI_EVENT_BASE)) {
         adf_os_print("Invalid event in %s", __FUNCTION__);
         return A_ERROR;
     } /* Input validation */
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c	2016-05-16 10:58:07.458298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_peer_find.c	2016-05-16 10:58:08.858298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*=== includes ===*/
 /* header files for OS primitives */
@@ -417,6 +418,7 @@
     int tx_ready)
 {
     ol_txrx_peer_find_add_id(pdev, peer_mac_addr, peer_id);
+#if 0
     if (pdev->cfg.is_high_latency && !tx_ready) {
         struct ol_txrx_peer_t *peer;
         peer = ol_txrx_peer_find_by_id(pdev, peer_id);
@@ -443,6 +445,7 @@
             }
         }
     }
+#endif
 }
 
 void
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_types.h qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2016-05-16 10:58:07.458298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_txrx_types.h	2016-05-16 10:58:08.870298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -61,8 +62,9 @@
 
 /* OL_TXRX_NUM_EXT_TIDS -
  * 16 "real" TIDs + 3 pseudo-TIDs for mgmt, mcast/bcast & non-QoS data
+ * max tid could be 31, set to 31 to avoid memory corruption
  */
-#define OL_TXRX_NUM_EXT_TIDS 19
+#define OL_TXRX_NUM_EXT_TIDS 31
 
 #define OL_TX_NUM_QOS_TIDS 16 /* 16 regular TIDs */
 #define OL_TX_NON_QOS_TID 16
@@ -849,11 +851,11 @@
 	 * per TID info -
 	 * stored in separate arrays to avoid alignment padding mem overhead
 	 */
-	struct ol_rx_reorder_t tids_rx_reorder[OL_TXRX_NUM_EXT_TIDS];
-	union htt_rx_pn_t      tids_last_pn[OL_TXRX_NUM_EXT_TIDS];
-	u_int8_t               tids_last_pn_valid[OL_TXRX_NUM_EXT_TIDS];
-	u_int16_t              tids_next_rel_idx[OL_TXRX_NUM_EXT_TIDS];
-	u_int16_t              tids_last_seq[OL_TXRX_NUM_EXT_TIDS];
+	struct ol_rx_reorder_t tids_rx_reorder[OL_TXRX_NUM_EXT_TIDS+1];
+	union htt_rx_pn_t      tids_last_pn[OL_TXRX_NUM_EXT_TIDS+1];
+	u_int8_t               tids_last_pn_valid[OL_TXRX_NUM_EXT_TIDS+1];
+	u_int16_t              tids_next_rel_idx[OL_TXRX_NUM_EXT_TIDS+1];
+	u_int16_t              tids_last_seq[OL_TXRX_NUM_EXT_TIDS+1];
 
 	struct {
 		enum htt_sec_type sec_type;
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_sched.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_sched.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_sched.c	2016-05-16 10:58:07.458298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_sched.c	2016-05-16 10:58:08.870298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <adf_nbuf.h>         /* adf_nbuf_t, etc. */
 #include <htt.h>              /* HTT_TX_EXT_TID_MGMT */
@@ -39,6 +40,7 @@
 #include <ol_txrx.h>
 #include <adf_os_types.h>     /* a_bool_t */
 
+
 #ifndef DEBUG_SCHED_STAT
 #define DEBUG_SCHED_STAT 0
 #endif
@@ -746,6 +748,8 @@
  * The scheduler sync spinlock has been acquired outside this function,
  * so there is no need to worry about mutex within this function.
  */
+
+
 static int
 ol_tx_sched_select_batch_wrr_adv(
     struct ol_txrx_pdev_t *pdev,
@@ -829,7 +833,29 @@
      * Take the tx queue from the head of the category list.
      */
     txq = TAILQ_FIRST(&category->state.head);
+
+#if 1
+	/* this is for debug and prevention */
     if (txq){
+		if ((txq)->list_elem.tqe_prev == NULL)
+		{
+			printk(KERN_ERR " tqe_pre error index %d qnext %p\n", index, TAILQ_NEXT(txq, list_elem) );
+			printk(KERN_ERR "txq %p last %p flag 0x%x frm count %d\n", txq,(&category->state.head)->tqh_last,txq->flag, txq->frms);
+			printk(KERN_ERR " catalog state 0x%x frame 0x%x\n", category->state.active, category->state.frms);
+
+			//if((txq)->list_elem.tqe_prev !=NULL)
+			//	printk(KERN_ERR "tqe_pre is not null *tqe_pre is 0x%p\n", *(txq)->list_elem.tqe_prev);
+
+			//force clean, assume this packet is gone as debug log shows it has been removed.
+			TAILQ_INIT(&category->state.head);
+			txq->frms = 0;
+			txq = NULL;
+		}
+    }
+#endif
+
+    if (txq && txq->frms > 0){
+
         TAILQ_REMOVE(&category->state.head, txq, list_elem);
         credit -= category->specs.credit_reserve;
         frames = ol_tx_dequeue(
@@ -849,7 +875,7 @@
     } else {
         used_credits = 0;
 		/* TODO: find its reason */
-		adf_os_print("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
+        adf_os_print("ol_tx_sched_select_batch_wrr_adv: error, no TXQ can be popped.");
     }
     OL_TX_SCHED_WRR_ADV_CAT_STAT_DUMP(scheduler);
     return used_credits;
@@ -1201,7 +1227,7 @@
     switch (ctx->event) {
     case OL_TX_ENQUEUE_FRAME:
         tid = ctx->info.tx_msdu_info->htt.info.ext_tid;
-        ol_tx_sched_txq_enqueue(pdev, txq, tid, 1, ctx->bytes);
+        ol_tx_sched_txq_enqueue(pdev, txq, tid, ctx->frames, ctx->bytes);
         break;
     case OL_TX_DELETE_QUEUE:
         tid = ctx->info.ext_tid;
diff -urN qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_send.c qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_send.c
--- qcacld-new.orig/CORE/CLD_TXRX/TXRX/ol_tx_send.c	2016-05-16 10:58:07.466298648 +0800
+++ qcacld-new/CORE/CLD_TXRX/TXRX/ol_tx_send.c	2016-05-16 10:58:08.870298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <adf_os_atomic.h>    /* adf_os_atomic_inc, etc. */
 #include <adf_os_lock.h>      /* adf_os_spinlock */
@@ -540,7 +541,11 @@
     }
 
     /* One shot protected access to pdev freelist, when setup */
-    if (lcl_freelist) {
+#ifdef QCA_TX_SINGLE_COMPLETIONS
+    if (lcl_freelist && tx_desc_last) {
+#else
+    if (tx_desc_last) {
+#endif
         adf_os_spin_lock(&pdev->tx_mutex);
         tx_desc_last->next = pdev->tx_desc.freelist;
         pdev->tx_desc.freelist = lcl_freelist;
@@ -664,8 +669,11 @@
                                     tx_desc_last, htt_tx_status_ok);
         }
     }
-
-    if (lcl_freelist) {
+#ifdef QCA_TX_SINGLE_COMPLETIONS
+    if (lcl_freelist && tx_desc_last) {
+#else
+    if (tx_desc_last) {
+#endif
         adf_os_spin_lock(&pdev->tx_mutex);
         tx_desc_last->next = pdev->tx_desc.freelist;
         pdev->tx_desc.freelist = lcl_freelist;
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_helper.c qcacld-new/CORE/EPPING/src/epping_helper.c
--- qcacld-new.orig/CORE/EPPING/src/epping_helper.c	2016-05-16 10:58:06.582298648 +0800
+++ qcacld-new/CORE/EPPING/src/epping_helper.c	2016-05-16 10:58:08.746298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -75,7 +75,7 @@
    for (i = 0; i < MAX_COOKIE_SLOTS_NUM; i++) {
       pEpping_ctx->s_cookie_mem[i] =
          vos_mem_malloc(sizeof(struct epping_cookie)*MAX_COOKIE_SLOT_SIZE);
-      if (pEpping_ctx->s_cookie_mem == NULL) {
+      if (pEpping_ctx->s_cookie_mem[i] == NULL) {
          EPPING_LOG(VOS_TRACE_LEVEL_FATAL,
             "%s: no mem for cookie (idx = %d)", __func__, i);
          goto error;
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_main.c qcacld-new/CORE/EPPING/src/epping_main.c
--- qcacld-new.orig/CORE/EPPING/src/epping_main.c	2016-05-16 10:58:06.582298648 +0800
+++ qcacld-new/CORE/EPPING/src/epping_main.c	2016-05-16 10:58:08.746298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -107,6 +107,7 @@
                        char *pwlan_module_name)
 {
    int ret = 0;
+   unsigned long rc;
    epping_context_t *pEpping_ctx = NULL;
    VOS_STATUS status = VOS_STATUS_SUCCESS;
 
@@ -151,10 +152,10 @@
    init_completion(&pEpping_ctx->wlan_start_comp);
    ret = hif_register_driver();
    if (!ret) {
-      ret = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                &pEpping_ctx->wlan_start_comp,
                msecs_to_jiffies(WLAN_WAIT_TIME_WLANSTART));
-      if (!ret) {
+      if (!rc) {
          EPPING_LOG(VOS_TRACE_LEVEL_FATAL,
             "%s: timed-out waiting for hif_register_driver", __func__);
          ret = -1;
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_rx.c qcacld-new/CORE/EPPING/src/epping_rx.c
--- qcacld-new.orig/CORE/EPPING/src/epping_rx.c	2016-05-16 10:58:06.582298648 +0800
+++ qcacld-new/CORE/EPPING/src/epping_rx.c	2016-05-16 10:58:08.746298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -146,9 +146,11 @@
    if (pktSkb)
    {
       EPPING_HEADER *eppingHdr = (EPPING_HEADER *)adf_nbuf_data(pktSkb);
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
       if (EPPING_ALIGNMENT_PAD > 0) {
          A_NETBUF_PULL(pktSkb, EPPING_ALIGNMENT_PAD);
       }
+#endif
       if (enb_rx_dump)
          epping_hex_dump((void *)adf_nbuf_data(pktSkb),
                           pktSkb->len, __func__);
diff -urN qcacld-new.orig/CORE/EPPING/src/epping_tx.c qcacld-new/CORE/EPPING/src/epping_tx.c
--- qcacld-new.orig/CORE/EPPING/src/epping_tx.c	2016-05-16 10:58:06.582298648 +0800
+++ qcacld-new/CORE/EPPING/src/epping_tx.c	2016-05-16 10:58:08.746298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -137,9 +137,12 @@
     * the addition of the HTC header will mis-align the start of the HTC
     * frame, so we add some padding which will be stripped off in the target
     */
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
    if (EPPING_ALIGNMENT_PAD > 0) {
       A_NETBUF_PUSH(skb, EPPING_ALIGNMENT_PAD);
    }
+#endif
+
    /* prepare ep/HTC information */
    ac = eppingHdr->StreamNo_h;
    eid = pAdapter->pEpping_ctx->EppingEndpoint[ac];
@@ -340,6 +343,7 @@
 
    while (!HTC_QUEUE_EMPTY(pPacketQueue)) {
       htc_pkt = HTC_PACKET_DEQUEUE(pPacketQueue);
+      ASSERT(htc_pkt);
       status=htc_pkt->Status;
       eid=htc_pkt->Endpoint;
       pktSkb=GET_HTC_PACKET_NET_BUF_CONTEXT(htc_pkt);
diff -urN qcacld-new.orig/CORE/HDD/inc/bap_hdd_misc.h qcacld-new/CORE/HDD/inc/bap_hdd_misc.h
--- qcacld-new.orig/CORE/HDD/inc/bap_hdd_misc.h	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/HDD/inc/bap_hdd_misc.h	2016-05-16 10:58:08.694298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -26,6 +27,7 @@
  */
 
 #if !defined( BAP_HDD_MISC_H )
+#ifdef WLAN_BTAMP_FEATURE
 #define BAP_HDD_MISC_H
 
 /**===========================================================================
@@ -136,4 +138,5 @@
 
   --------------------------------------------------------------------------*/
 v_BOOL_t WLANBAP_AmpSessionOn(void);
+#endif //WLAN_BTAMP_FEATURE
 #endif    // end #if !defined( BAP_HDD_MISC_H )
diff -urN qcacld-new.orig/CORE/HDD/inc/qc_sap_ioctl.h qcacld-new/CORE/HDD/inc/qc_sap_ioctl.h
--- qcacld-new.orig/CORE/HDD/inc/qc_sap_ioctl.h	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/HDD/inc/qc_sap_ioctl.h	2016-05-16 10:58:08.694298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -239,7 +240,10 @@
     QCSAP_PARAM_SET_CHANNEL_CHANGE,
     QCASAP_SET_DFS_TARGET_CHNL,
     QCASAP_SET_RADAR_CMD,
-    QCSAP_GET_ACL
+    QCSAP_GET_ACL,
+    QCSAP_DIRECT_AUDIO_TEST,
+    QCSAP_DBGLOG_FWLOG_FILE_ENABLE,
+    QCSAP_DBGLOG_FWLOG_FILE_MAX_SIZE,
 };
 
 int iw_softap_get_channel_list(struct net_device *dev,
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg80211.h qcacld-new/CORE/HDD/inc/wlan_hdd_cfg80211.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg80211.h	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_cfg80211.h	2016-05-16 10:58:08.694298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg.h qcacld-new/CORE/HDD/inc/wlan_hdd_cfg.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_cfg.h	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_cfg.h	2016-05-16 10:58:08.694298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -2755,6 +2756,63 @@
 #define CFG_ENABLE_SAP_SUSPEND_MAX                 ( 1 )
 #define CFG_ENABLE_SAP_SUSPEND_DEFAULT             ( 1 )
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define CFG_EXTWOW_GO_TO_SUSPEND                   "gExtWoWgotoSuspend"
+#define CFG_EXTWOW_GO_TO_SUSPEND_MIN               ( 0 )
+#define CFG_EXTWOW_GO_TO_SUSPEND_MAX               ( 1 )
+#define CFG_EXTWOW_GO_TO_SUSPEND_DEFAULT           ( 1 )
+
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER            "gExtWowApp1WakeupPinNumber"
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MIN        ( 0 )
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MAX        ( 255 )
+#define CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_DEFAULT    ( 12 )
+
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER            "gExtWowApp2WakeupPinNumber"
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MIN        ( 0 )
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MAX        ( 255 )
+#define CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_DEFAULT    ( 16 )
+
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL           "gExtWoWApp2KAInitPingInterval"
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_MIN       ( 0 )
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_MAX       ( 0xffffffff )
+#define CFG_EXTWOW_KA_INIT_PING_INTERVAL_DEFAULT   ( 240 )
+
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL            "gExtWoWApp2KAMinPingInterval"
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_MIN_PING_INTERVAL_DEFAULT    ( 240 )
+
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL            "gExtWoWApp2KAMaxPingInterval"
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_MAX_PING_INTERVAL_DEFAULT    ( 1280 )
+
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL            "gExtWoWApp2KAIncPingInterval"
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_MIN        ( 0 )
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_MAX        ( 0xffffffff )
+#define CFG_EXTWOW_KA_INC_PING_INTERVAL_DEFAULT    ( 4 )
+
+#define CFG_EXTWOW_TCP_SRC_PORT                    "gExtWoWApp2TcpSrcPort"
+#define CFG_EXTWOW_TCP_SRC_PORT_MIN                ( 0 )
+#define CFG_EXTWOW_TCP_SRC_PORT_MAX                ( 65535 )
+#define CFG_EXTWOW_TCP_SRC_PORT_DEFAULT            ( 5000 )
+
+#define CFG_EXTWOW_TCP_DST_PORT                    "gExtWoWApp2TcpDstPort"
+#define CFG_EXTWOW_TCP_DST_PORT_MIN                ( 0 )
+#define CFG_EXTWOW_TCP_DST_PORT_MAX                ( 65535 )
+#define CFG_EXTWOW_TCP_DST_PORT_DEFAULT            ( 5001 )
+
+#define CFG_EXTWOW_TCP_TX_TIMEOUT                  "gExtWoWApp2TcpTxTimeout"
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_MIN              ( 0 )
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_MAX              ( 0xffffffff )
+#define CFG_EXTWOW_TCP_TX_TIMEOUT_DEFAULT          ( 200 )
+
+#define CFG_EXTWOW_TCP_RX_TIMEOUT                  "gExtWoWApp2TcpRxTimeout"
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_MIN              ( 0 )
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_MAX              ( 0xffffffff )
+#define CFG_EXTWOW_TCP_RX_TIMEOUT_DEFAULT          ( 200 )
+#endif
+
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_NAME    "gEnableDeauthToDisassocMap"
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_MIN     ( 0 )
 #define CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_MAX     ( 1 )
@@ -2877,6 +2935,11 @@
 #define CFG_SAP_AUTH_OFL_KEY_DEFAULT  ""
 #endif /* SAP_AUTH_OFFLOAD */
 
+#define CFG_P2P_LISTEN_DEFER_INTERVAL_NAME        "gP2PListenDeferInterval"
+#define CFG_P2P_LISTEN_DEFER_INTERVAL_MIN         (100)
+#define CFG_P2P_LISTEN_DEFER_INTERVAL_MAX         (200)
+#define CFG_P2P_LISTEN_DEFER_INTERVAL_DEFAULT     (100)
+
 /*---------------------------------------------------------------------------
   Type declarations
   -------------------------------------------------------------------------*/
@@ -3472,6 +3535,19 @@
 
    v_BOOL_t                    enableSapSuspend;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+   v_U8_t                      extWowGotoSuspend;
+   v_U8_t                      extWowApp1WakeupPinNumber;
+   v_U8_t                      extWowApp2WakeupPinNumber;
+   v_U32_t                     extWowApp2KAInitPingInterval;
+   v_U32_t                     extWowApp2KAMinPingInterval;
+   v_U32_t                     extWowApp2KAMaxPingInterval;
+   v_U32_t                     extWowApp2KAIncPingInterval;
+   v_U16_t                     extWowApp2TcpSrcPort;
+   v_U16_t                     extWowApp2TcpDstPort;
+   v_U32_t                     extWowApp2TcpTxTimeout;
+   v_U32_t                     extWowApp2TcpRxTimeout;
+#endif
    v_BOOL_t                    gEnableDeauthToDisassocMap;
 
 #ifdef DHCP_SERVER_OFFLOAD
@@ -3503,6 +3579,7 @@
    uint32_t                    sap_auth_offload_sec_type;
    uint8_t                     sap_auth_offload_key[WLAN_PSK_STRING_LENGTH];
 #endif /* SAP_AUTH_OFFLOAD */
+   uint16_t                    p2p_listen_defer_interval;
 } hdd_config_t;
 
 #ifdef WLAN_FEATURE_MBSSID
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h qcacld-new/CORE/HDD/inc/wlan_hdd_main.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_main.h	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_main.h	2016-05-16 10:58:08.694298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
@@ -1131,6 +1132,15 @@
 #ifdef WLAN_FEATURE_LINK_LAYER_STATS
    v_BOOL_t isLinkLayerStatsSet;
 #endif
+
+    /* Time stamp for last completed RoC request */
+    v_TIME_t lastRocTs;
+
+    /* work queue to defer the back to back p2p_listen */
+    struct delayed_work roc_work;
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
 };
 
 #define WLAN_HDD_GET_STATION_CTX_PTR(pAdapter) (&(pAdapter)->sessionCtx.station)
@@ -1246,7 +1256,6 @@
     v_U8_t dl_loglevel;
     v_U8_t index;
     v_U32_t dl_mod_loglevel[MAX_MOD_LOGLEVEL];
-
 }fw_log_info;
 
 /** Adapter stucture definition */
@@ -1531,8 +1540,16 @@
 #endif
     fw_log_info fw_log_settings;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    v_BOOL_t is_extwow_app_type1_param_set;
+    v_BOOL_t ext_wow_should_suspend;
+    struct completion ready_to_extwow;
+    tSirAppType1Params app_type1_params;
+   struct mutex ext_wow_lock;
+#endif
+
     /* RoC request queue and work */
-    struct work_struct rocReqWork;
+    struct delayed_work rocReqWork;
     hdd_list_t hdd_roc_req_q;
 };
 
@@ -1746,4 +1763,10 @@
 #endif
 
 void hdd_update_macaddr(hdd_config_t *cfg_ini, v_MACADDR_t hw_macaddr);
+
+char *hdd_get_version_string( void );
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
+
 #endif    // end #if !defined( WLAN_HDD_MAIN_H )
diff -urN qcacld-new.orig/CORE/HDD/inc/wlan_hdd_p2p.h qcacld-new/CORE/HDD/inc/wlan_hdd_p2p.h
--- qcacld-new.orig/CORE/HDD/inc/wlan_hdd_p2p.h	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/HDD/inc/wlan_hdd_p2p.h	2016-05-16 10:58:08.694298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -57,6 +58,8 @@
 #define WLAN_HDD_SET_WEP_FRM_FC(__fc__)     ( (__fc__) = ((__fc__) | 0x40))
 #endif //WLAN_FEATURE_11W
 
+#define HDD_P2P_MAX_ROC_DURATION 1000
+
 enum hdd_rx_flags {
     HDD_RX_FLAG_DECRYPTED        = 1 << 0,
     HDD_RX_FLAG_MMIC_STRIPPED    = 1 << 1,
@@ -187,6 +190,5 @@
 /* Max entry for RoC request */
 #define MAX_ROC_REQ_QUEUE_ENTRY 10
 
-void hdd_roc_req_work(struct work_struct *work);
-
+void wlan_hdd_roc_request_dequeue(struct work_struct *work);
 #endif // __P2P_H
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_assoc.c	2016-05-16 10:58:06.442298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_assoc.c	2016-05-16 10:58:08.710298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -147,7 +148,7 @@
    pHddStaCtx->conn_info.uIsAuthenticated = authState;
 
    /* Check is pending ROC request or not when auth state changed */
-   schedule_work(&pHddCtx->rocReqWork);
+   schedule_delayed_work(&pHddCtx->rocReqWork, 0);
 }
 
 v_VOID_t hdd_connSetConnectionState( hdd_adapter_t *pAdapter,
@@ -162,7 +163,7 @@
    pHddStaCtx->conn_info.connState = connState;
 
    /* Check is pending ROC request or not when connection state changed */
-   schedule_work(&pHddCtx->rocReqWork);
+   schedule_delayed_work(&pHddCtx->rocReqWork, 0);
 }
 
 // returns FALSE if not connected.
@@ -904,6 +905,7 @@
         return eHAL_STATUS_FAILURE;
     }
 
+
     // notify apps that we can't pass traffic anymore
     netif_tx_disable(dev);
     netif_carrier_off(dev);
@@ -985,6 +987,8 @@
             {
                 cfg80211_disconnected(dev, WLAN_REASON_UNSPECIFIED, NULL, 0, GFP_KERNEL);
             }
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
 
             //If the Device Mode is Station
             // and the P2P Client is Connected
@@ -1314,10 +1318,11 @@
         goto done;
     }
 
+    if (pCsrRoamInfo->pbFrames == NULL)
+        goto done;
+
     pFTAssocRsp = (u8 *)(pCsrRoamInfo->pbFrames + pCsrRoamInfo->nBeaconLength +
                     pCsrRoamInfo->nAssocReqLength);
-    if (pFTAssocRsp == NULL)
-        goto done;
 
     //pFTAssocRsp needs to point to the IEs
     pFTAssocRsp += FT_ASSOC_RSP_IES_OFFSET;
@@ -1386,7 +1391,7 @@
 #if  defined (FEATURE_WLAN_ESE) || defined(FEATURE_WLAN_LFR) || defined (WLAN_FEATURE_VOWIFI_11R)
     int ft_carrier_on = FALSE;
 #endif
-    int status;
+    unsigned long rc;
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
     if (pRoamInfo && pRoamInfo->roamSynchInProgress) {
        /* change logging before release */
@@ -1441,10 +1446,9 @@
             netif_carrier_on(dev);
 
             // Wait for the Link to up to ensure all the queues are set properly by the kernel
-            status = wait_for_completion_interruptible_timeout(&pAdapter->linkup_event_var,
+            rc = wait_for_completion_timeout(&pAdapter->linkup_event_var,
                                                    msecs_to_jiffies(ASSOC_LINKUP_TIMEOUT));
-            if(!status)
-            {
+            if (!rc) {
                 hddLog(VOS_TRACE_LEVEL_WARN, "%s: Warning:ASSOC_LINKUP_TIMEOUT", __func__);
             }
 
@@ -1602,6 +1606,8 @@
                                             pFTAssocRsp, assocRsplen,
                                             WLAN_STATUS_SUCCESS,
                                             GFP_KERNEL);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
                 }
             }
             else
@@ -1635,6 +1641,8 @@
                             rspRsnIe, rspRsnLength,
                             WLAN_STATUS_SUCCESS,
                             GFP_KERNEL);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
                 }
             }
             cfg80211_put_bss(
@@ -3828,6 +3836,7 @@
                         struct iw_request_info *info,
                         union iwreq_data *wrqu, char *extra)
 {
+    unsigned long rc;
     v_U32_t status = 0;
     hdd_wext_state_t *pWextState;
     hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
@@ -3873,9 +3882,13 @@
             INIT_COMPLETION(pAdapter->disconnect_comp_var);
             vosStatus = sme_RoamDisconnect( hHal, pAdapter->sessionId, eCSR_DISCONNECT_REASON_UNSPECIFIED );
 
-            if(VOS_STATUS_SUCCESS == vosStatus)
-               wait_for_completion_interruptible_timeout(&pAdapter->disconnect_comp_var,
-                     msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
+            if (VOS_STATUS_SUCCESS == vosStatus) {
+                rc = wait_for_completion_timeout(&pAdapter->disconnect_comp_var,
+                          msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
+                if (!rc) {
+                    hddLog( LOGE, FL("Disconnect event timed out"));
+                }
+             }
         }
     }
     /** wpa_supplicant 0.8.x, wext driver uses */
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg80211.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg80211.c	2016-05-16 10:58:06.442298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg80211.c	2016-05-16 10:58:08.710298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -5459,6 +5459,13 @@
         return -EINVAL;
     }
 
+    if (pHostapdState->vosStatus) {
+        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                 ("%s: ERROR: HDD vosStatus is 0x%02x"),
+                 __func__, pHostapdState->vosStatus);
+        return -EINVAL;
+    }
+
     //Succesfully started Bss update the state bit.
     set_bit(SOFTAP_BSS_STARTED, &pHostapdAdapter->event_flags);
     wlan_hdd_incr_active_session(pHddCtx, pHostapdAdapter->device_mode);
@@ -5643,6 +5650,7 @@
     tSirUpdateIE    updateIE;
     beacon_data_t  *old;
     int             ret;
+    unsigned long   rc;
 
     ENTER();
 
@@ -5676,18 +5684,16 @@
     hddLog(VOS_TRACE_LEVEL_INFO, FL("device_mode = %d"), pAdapter->device_mode);
 
     if ((pScanInfo != NULL) && pScanInfo->mScanPending && staAdapter) {
-        long ret;
 
         INIT_COMPLETION(pScanInfo->abortscan_event_var);
         hdd_abort_mac_scan(staAdapter->pHddCtx, pAdapter->sessionId,
                            eCSR_SCAN_ABORT_DEFAULT);
-        ret = wait_for_completion_interruptible_timeout(
+        rc = wait_for_completion_timeout(
                            &pScanInfo->abortscan_event_var,
                            msecs_to_jiffies(WLAN_WAIT_TIME_ABORTSCAN));
-        if (ret <= 0) {
+        if (!rc) {
             hddLog(VOS_TRACE_LEVEL_ERROR,
-                   FL("Timeout occurred while waiting for abortscan %ld"),
-                   ret);
+                   FL("Timeout occurred while waiting for abortscan"));
             VOS_ASSERT(pScanInfo->mScanPending);
         }
     }
@@ -6059,7 +6065,7 @@
     hdd_adapter_t *pDataAdapter = NULL;
     hdd_adapter_list_node_t *pAdapterNode = NULL, *pNext = NULL;
 #endif
-    long ret;
+    unsigned long rc;
     VOS_STATUS vstatus;
     eHalStatus hstatus;
     int status;
@@ -6251,14 +6257,12 @@
                     if (eHAL_STATUS_SUCCESS == hstatus)
                     {
                         /* Wait for completion */
-                        ret = wait_for_completion_interruptible_timeout(
+                        rc = wait_for_completion_timeout(
                                        &pAdapter->change_country_code,
                                        msecs_to_jiffies(WLAN_WAIT_TIME_COUNTRY));
-                        if (ret <= 0)
-                        {
+                        if (!rc) {
                             VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                                      FL("SME Timed out while setting country code %ld"),
-                                         ret);
+                               FL("SME Timed out while setting country code"));
                         }
                     }
                     else
@@ -6389,8 +6393,9 @@
       return -EOPNOTSUPP;
     }
 
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     if(pRoamProfile)
+#endif
     {
         if ( LastBSSType != pRoamProfile->BSSType )
         {
@@ -6410,13 +6415,12 @@
                                 pAdapter->sessionId,
                                 eCSR_DISCONNECT_REASON_UNSPECIFIED ) )
                 {
-                    ret = wait_for_completion_interruptible_timeout(
+                    rc = wait_for_completion_timeout(
                                   &pAdapter->disconnect_comp_var,
                                   msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-                    if (ret <= 0)
-                    {
+                    if (!rc) {
                         hddLog(VOS_TRACE_LEVEL_ERROR,
-                               FL("wait on disconnect_comp_var failed %ld"), ret);
+                               FL("wait on disconnect_comp_var failed"));
                      }
 
                 }
@@ -6496,6 +6500,7 @@
     VOS_STATUS status;
     hddTdlsPeer_t *pTdlsPeer;
     tANI_U16 numCurrTdlsPeers;
+    unsigned long rc;
     long ret;
 
     ENTER();
@@ -6640,14 +6645,13 @@
                                        pAdapter->sessionId, mac, StaParams);
     }
 
-     ret = wait_for_completion_interruptible_timeout(&pAdapter->tdls_add_station_comp,
+     rc = wait_for_completion_timeout(&pAdapter->tdls_add_station_comp,
            msecs_to_jiffies(WAIT_TIME_TDLS_ADD_STA));
 
-    if (ret <= 0)
-    {
+    if (!rc) {
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: timeout waiting for tdls add station indication %ld",
-                  __func__, ret);
+                  "%s: timeout waiting for tdls add station indication",
+                  __func__);
         return -EPERM;
     }
 
@@ -7219,13 +7223,14 @@
 
     ENTER();
 
+    memset(&params, 0, sizeof(params));
+
     MTRACE(vos_trace(VOS_MODULE_ID_HDD,
                      TRACE_CODE_HDD_CFG80211_GET_KEY,
                      pAdapter->sessionId, params.cipher));
     hddLog(VOS_TRACE_LEVEL_INFO, "%s: device_mode = %d",
                                  __func__,pAdapter->device_mode);
 
-    memset(&params, 0, sizeof(params));
 
     if (CSR_MAX_NUM_KEY <= key_index)
     {
@@ -8184,8 +8189,8 @@
     hdd_scaninfo_t *pScanInfo = &pAdapter->scan_info;
     struct cfg80211_scan_request *req = NULL;
     bool aborted = false;
+    unsigned long rc;
     int ret = 0;
-    long waitRet = 0;
 
     ENTER();
 
@@ -8197,13 +8202,12 @@
     pScanInfo->mScanPendingCounter = 0;
 
     //Block on scan req completion variable. Can't wait forever though.
-    waitRet = wait_for_completion_interruptible_timeout(
+    rc = wait_for_completion_timeout(
                          &pScanInfo->scan_req_completion_event,
                          msecs_to_jiffies(WLAN_WAIT_TIME_SCAN_REQ));
-    if (waitRet <= 0)
-    {
+    if (!rc) {
         hddLog(VOS_TRACE_LEVEL_ERROR,
-               "%s wait on scan_req_completion_event failed %ld", __func__, waitRet);
+               "%s wait on scan_req_completion_event timed out", __func__);
        VOS_ASSERT(pScanInfo->mScanPending);
        goto allow_suspend;
     }
@@ -8456,6 +8460,12 @@
         return -EBUSY;
     }
 
+    if (TRUE == pHddCtx->hdd_wlan_suspended)
+    {
+        hddLog(VOS_TRACE_LEVEL_ERROR, "%s: wlan suspend is TRUE", __func__);
+        return -EBUSY;
+    }
+
 #ifdef FEATURE_WLAN_SCAN_PNO
     /* This check will not allow any normal scan when we already issued
      * an PNO scan.
@@ -9160,6 +9170,9 @@
             pWextState->authKeyMgmt |= IW_AUTH_KEY_MGMT_802_1X;
             break;
 
+        case WLAN_AKM_SUITE_8021X_SHA256:
+        case WLAN_AKM_SUITE_PSK_SHA256:
+            break;
         default:
             hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Unsupported key mgmt type %d",
                     __func__, key_mgmt);
@@ -9685,7 +9698,7 @@
  */
 static int wlan_hdd_try_disconnect( hdd_adapter_t *pAdapter )
 {
-    long ret = 0;
+    unsigned long rc;
     hdd_station_ctx_t *pHddStaCtx;
     eMib_dot11DesiredBssType connectedBssType;
 
@@ -9704,26 +9717,26 @@
                         pAdapter->sessionId,
                         eCSR_DISCONNECT_REASON_UNSPECIFIED ) )
         {
-            ret = wait_for_completion_interruptible_timeout(
+            rc = wait_for_completion_timeout(
                          &pAdapter->disconnect_comp_var,
                          msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-            if (0 >=  ret)
-            {
-                hddLog(LOGE, FL("Failed to receive sme disconnect event session Id %d staDebugState %d"),
-                   pAdapter->sessionId, pHddStaCtx->staDebugState);
+            if (!rc) {
+                hddLog(LOGE, FL("Sme disconnect event timed out session Id %d"
+                   " staDebugState %d"), pAdapter->sessionId,
+                   pHddStaCtx->staDebugState);
                 return -EALREADY;
             }
         }
     }
     else if(eConnectionState_Disconnecting == pHddStaCtx->conn_info.connState)
     {
-        ret = wait_for_completion_interruptible_timeout(
+        rc = wait_for_completion_timeout(
                      &pAdapter->disconnect_comp_var,
                      msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-        if (0 >= ret)
-        {
-            hddLog(LOGE, FL("Failed to receive wait for comp disconnect event session Id %d staDebugState %d"),
-               pAdapter->sessionId, pHddStaCtx->staDebugState);
+        if (!rc) {
+            hddLog(LOGE, FL("Disconnect event timed out session Id %d"
+               " staDebugState %d"), pAdapter->sessionId,
+               pHddStaCtx->staDebugState);
             return -EALREADY;
         }
     }
@@ -9917,6 +9930,7 @@
 int wlan_hdd_disconnect( hdd_adapter_t *pAdapter, u16 reason )
 {
     int status;
+    unsigned long rc;
     hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
 
@@ -9952,23 +9966,17 @@
         pHddStaCtx->staDebugState = status;
         return -EINVAL;
     }
-    status = wait_for_completion_interruptible_timeout(
+    rc = wait_for_completion_timeout(
                 &pAdapter->disconnect_comp_var,
                 msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
 
     hdd_connSetConnectionState(pAdapter,
                                 eConnectionState_NotConnected);
     
-    if (!status)
-    {
+    if (!rc) {
        hddLog(VOS_TRACE_LEVEL_ERROR,
               "%s: Failed to disconnect, timed out", __func__);
        return -ETIMEDOUT;
-    } else if (status == -ERESTARTSYS)
-    {
-        hddLog(VOS_TRACE_LEVEL_ERROR,
-               "%s: Failed to disconnect, wait interrupted", __func__);
-        return status;
     }
 
     return 0;
@@ -10495,9 +10503,12 @@
         u32 rts_threshold = (wiphy->rts_threshold == -1) ?
                                WNI_CFG_RTS_THRESHOLD_STAMAX :
                                wiphy->rts_threshold;
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         if ((WNI_CFG_RTS_THRESHOLD_STAMIN > rts_threshold) ||
                 (WNI_CFG_RTS_THRESHOLD_STAMAX < rts_threshold))
+#else
+		if (WNI_CFG_RTS_THRESHOLD_STAMAX < rts_threshold)
+#endif
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,
                     "%s: Invalid RTS Threshold value %u",
@@ -10555,8 +10566,7 @@
                          wiphy->retry_short :
                          wiphy->retry_long;
 
-        if ((WNI_CFG_LONG_RETRY_LIMIT_STAMIN > retry_value) ||
-                (WNI_CFG_LONG_RETRY_LIMIT_STAMAX < retry_value))
+        if (WNI_CFG_LONG_RETRY_LIMIT_STAMAX < retry_value)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR, "%s: Invalid Retry count %hu",
                     __func__, retry_value);
@@ -11924,7 +11934,7 @@
 {
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
     hdd_scaninfo_t *pScanInfo = NULL;
-    int status = 0;
+    unsigned long rc;
 
     pScanInfo = &pAdapter->scan_info;
 
@@ -11934,11 +11944,10 @@
         hdd_abort_mac_scan(pHddCtx, pAdapter->sessionId,
                            eCSR_SCAN_ABORT_DEFAULT);
 
-        status = wait_for_completion_interruptible_timeout(
+        rc = wait_for_completion_timeout(
                            &pScanInfo->abortscan_event_var,
                            msecs_to_jiffies(5000));
-        if ((!status) || (status == -ERESTARTSYS))
-        {
+        if (!rc) {
            VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                   "%s: Timeout occurred while waiting for abort scan" ,
                   __func__);
@@ -12413,7 +12422,7 @@
     VOS_STATUS status;
     int max_sta_failed = 0;
     int responder;
-    long rc;
+    unsigned long rc;
     tANI_U16 numCurrTdlsPeers;
 #if !(TDLS_MGMT_VERSION2)
     u32 peer_capability;
@@ -12465,7 +12474,9 @@
         }
     }
 
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     if (WLAN_IS_TDLS_SETUP_ACTION(action_code))
+#endif
     {
         if (NULL != wlan_hdd_tdls_is_progress(pHddCtx, peer, TRUE))
         {
@@ -12601,14 +12612,13 @@
         return -EINVAL;
     }
 
-    rc = wait_for_completion_interruptible_timeout(&pAdapter->tdls_mgmt_comp,
-                                                        msecs_to_jiffies(WAIT_TIME_TDLS_MGMT));
+    rc = wait_for_completion_timeout(&pAdapter->tdls_mgmt_comp,
+                                       msecs_to_jiffies(WAIT_TIME_TDLS_MGMT));
 
-    if ((rc <= 0) || (TRUE != pAdapter->mgmtTxCompletionStatus))
-    {
+    if ((0 == rc) || (TRUE != pAdapter->mgmtTxCompletionStatus)) {
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                  "%s: Mgmt Tx Completion failed status %ld TxCompletion %u",
-                  __func__, rc, pAdapter->mgmtTxCompletionStatus);
+                  "%s: Mgmt Tx Completion timed out TxCompletion %u",
+                  __func__, pAdapter->mgmtTxCompletionStatus);
 
         if (pHddCtx->isLogpInProgress)
         {
@@ -12700,7 +12710,7 @@
         case NL80211_TDLS_ENABLE_LINK:
             {
                 VOS_STATUS status;
-                long ret;
+                unsigned long rc;
                 tCsrTdlsLinkEstablishParams tdlsLinkEstablishParams;
 
                 pTdlsPeer = wlan_hdd_tdls_find_peer(pAdapter, peer, TRUE);
@@ -12744,14 +12754,12 @@
                          * register with the TL on after the response for this operation
                          * is received .
                          */
-                        ret = wait_for_completion_interruptible_timeout(
+                        rc = wait_for_completion_timeout(
                                 &pAdapter->tdls_link_establish_req_comp,
                                 msecs_to_jiffies(WAIT_TIME_TDLS_LINK_ESTABLISH_REQ));
-                        if (ret <= 0)
-                        {
+                        if (!rc) {
                             VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                                      "%s: Link Establish Request Faled Status %ld",
-                                      __func__, ret);
+                              "%s: Link Establish Request timed out", __func__);
                             return -EINVAL;
                         }
                     }
@@ -12902,21 +12910,19 @@
 
                 if(TDLS_STA_INDEX_VALID(pTdlsPeer->staId))
                 {
-                    long status;
+                    unsigned long rc;
 
                     INIT_COMPLETION(pAdapter->tdls_del_station_comp);
 
                     sme_DeleteTdlsPeerSta( WLAN_HDD_GET_HAL_CTX(pAdapter),
                             pAdapter->sessionId, peer );
 
-                    status = wait_for_completion_interruptible_timeout(&pAdapter->tdls_del_station_comp,
+                    rc = wait_for_completion_timeout(&pAdapter->tdls_del_station_comp,
                               msecs_to_jiffies(WAIT_TIME_TDLS_DEL_STA));
-                    if (status <= 0)
-                    {
+                    if (!rc) {
                         wlan_hdd_tdls_set_peer_link_status(pTdlsPeer, eTDLS_LINK_IDLE);
                         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                                  "%s: Del station failed status %ld",
-                                  __func__, status);
+                                  "%s: Del station timed out", __func__);
                         return -EPERM;
                     }
                     wlan_hdd_tdls_set_peer_link_status(pTdlsPeer, eTDLS_LINK_IDLE);
@@ -13866,6 +13872,7 @@
 
 #ifdef QCA_WIFI_2_0
     /* Stop ongoing scan on each interface */
+    printk(KERN_ERR "cfg80211 suspend wlan\n");
     status =  hdd_get_front_adapter ( pHddCtx, &pAdapterNode );
     while ( NULL != pAdapterNode && VOS_STATUS_SUCCESS == status )
     {
@@ -13875,6 +13882,7 @@
         if (pScanInfo->mScanPending && pAdapter->request)
         {
            INIT_COMPLETION(pScanInfo->abortscan_event_var);
+           printk(KERN_ERR "cfg80211 abort wlanscan\n");
            hdd_abort_mac_scan(pHddCtx, pAdapter->sessionId,
                               eCSR_SCAN_ABORT_DEFAULT);
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_cfg.c	2016-05-16 10:58:06.458298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_cfg.c	2016-05-16 10:58:08.726298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -3747,6 +3748,85 @@
                CFG_ENABLE_SAP_SUSPEND_MIN,
                CFG_ENABLE_SAP_SUSPEND_MAX ),
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+   REG_VARIABLE( CFG_EXTWOW_GO_TO_SUSPEND, WLAN_PARAM_Integer,
+              hdd_config_t, extWowGotoSuspend,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_GO_TO_SUSPEND_DEFAULT,
+              CFG_EXTWOW_GO_TO_SUSPEND_MIN,
+              CFG_EXTWOW_GO_TO_SUSPEND_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_APP1_WAKE_PIN_NUMBER, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp1WakeupPinNumber,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_DEFAULT,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MIN,
+              CFG_EXTWOW_APP1_WAKE_PIN_NUMBER_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_APP2_WAKE_PIN_NUMBER, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2WakeupPinNumber,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_DEFAULT,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MIN,
+              CFG_EXTWOW_APP2_WAKE_PIN_NUMBER_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_INIT_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAInitPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_INIT_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_MIN_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAMinPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_MIN_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_MAX_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAMaxPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_MAX_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_KA_INC_PING_INTERVAL, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2KAIncPingInterval,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_DEFAULT,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_MIN,
+              CFG_EXTWOW_KA_INC_PING_INTERVAL_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_SRC_PORT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpSrcPort,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_SRC_PORT_DEFAULT,
+              CFG_EXTWOW_TCP_SRC_PORT_MIN,
+              CFG_EXTWOW_TCP_SRC_PORT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_DST_PORT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpDstPort,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_DST_PORT_DEFAULT,
+              CFG_EXTWOW_TCP_DST_PORT_MIN,
+              CFG_EXTWOW_TCP_DST_PORT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_TX_TIMEOUT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpTxTimeout,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_DEFAULT,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_MIN,
+              CFG_EXTWOW_TCP_TX_TIMEOUT_MAX ),
+
+   REG_VARIABLE( CFG_EXTWOW_TCP_RX_TIMEOUT, WLAN_PARAM_Integer,
+              hdd_config_t, extWowApp2TcpRxTimeout,
+              VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_DEFAULT,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_MIN,
+              CFG_EXTWOW_TCP_RX_TIMEOUT_MAX ),
+#endif
+
    REG_VARIABLE( CFG_ENABLE_DEAUTH_TO_DISASSOC_MAP_NAME, WLAN_PARAM_Integer,
               hdd_config_t, gEnableDeauthToDisassocMap,
               VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
@@ -3951,6 +4031,12 @@
                  CFG_SAP_DOT11_MODE_MIN,
                  CFG_SAP_DOT11_MODE_MAX ),
 
+   REG_VARIABLE(CFG_P2P_LISTEN_DEFER_INTERVAL_NAME, WLAN_PARAM_Integer,
+                hdd_config_t, p2p_listen_defer_interval,
+                VAR_FLAGS_OPTIONAL | VAR_FLAGS_RANGE_CHECK_ASSUME_DEFAULT,
+                CFG_P2P_LISTEN_DEFER_INTERVAL_DEFAULT,
+                CFG_P2P_LISTEN_DEFER_INTERVAL_MIN,
+                CFG_P2P_LISTEN_DEFER_INTERVAL_MAX),
 };
 #endif
 
@@ -4417,6 +4503,52 @@
             "Name = [gEnableSapSuspend] Value = [%u]",
             pHddCtx->cfg_ini->enableSapSuspend);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWgotoSuspend] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowGotoSuspend);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWowApp1WakeupPinNumber] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp1WakeupPinNumber);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWowApp2WakeupPinNumber] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2WakeupPinNumber);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAInitPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAInitPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAMinPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAMinPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAMaxPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAMaxPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2KAIncPingInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2KAIncPingInterval);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpSrcPort] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpSrcPort);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpDstPort] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpDstPort);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpTxTimeout] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpTxTimeout);
+
+  VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
+           "Name = [gExtWoWApp2TcpRxTimeout] Value = [%u]",
+                   pHddCtx->cfg_ini->extWowApp2TcpRxTimeout);
+#endif
+
 #ifdef DHCP_SERVER_OFFLOAD
   VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO_HIGH,
            "Name = [gDHCPServerOffloadEnable] Value = [%u]",
@@ -4476,6 +4608,8 @@
            "Name = [gMDNSResponseTypeSRVTarget] Value = [%s]",
                    pHddCtx->cfg_ini->mdns_resp_type_srv_target);
 #endif
+  hddLog(LOG2, "Name = [gP2PListenDeferInterval] Value = [%u]",
+                   pHddCtx->cfg_ini->p2p_listen_defer_interval);
 }
 
 #define CFG_VALUE_MAX_LEN 256
@@ -4673,6 +4807,8 @@
    VOS_STATUS vos_status = VOS_STATUS_SUCCESS;
 
    memset(macTable, 0, sizeof(macTable));
+
+
    status = request_firmware(&fw, WLAN_MAC_FILE, pHddCtx->parent_dev);
 
    if (status)
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_dev_pwr.c qcacld-new/CORE/HDD/src/wlan_hdd_dev_pwr.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_dev_pwr.c	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_dev_pwr.c	2016-05-16 10:58:08.702298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -102,7 +103,7 @@
 ----------------------------------------------------------------------------*/
 static int wlan_suspend(hdd_context_t* pHddCtx)
 {
-   long rc = 0;
+   unsigned long rc;
 
    pVosSchedContext vosSchedContext = NULL;
 
@@ -133,13 +134,12 @@
    wake_up_interruptible(&vosSchedContext->txWaitQueue);
 
    /* Wait for Suspend Confirmation from Tx Thread */
-   rc = wait_for_completion_interruptible_timeout(&pHddCtx->tx_sus_event_var, msecs_to_jiffies(200));
+   rc = wait_for_completion_timeout(&pHddCtx->tx_sus_event_var,
+            msecs_to_jiffies(200));
 
-   if (rc <= 0)
-   {
+   if (!rc) {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-                 "%s: Not able to suspend TX thread timeout happened %ld",
-                 __func__, rc);
+           "%s: Not able to suspend TX thread timeout happened", __func__);
       clear_bit(TX_SUSPEND_EVENT_MASK, &vosSchedContext->txEventFlag);
 
       return -ETIME;
@@ -155,12 +155,12 @@
    wake_up_interruptible(&vosSchedContext->rxWaitQueue);
 
    /* Wait for Suspend Confirmation from Rx Thread */
-   rc = wait_for_completion_interruptible_timeout(&pHddCtx->rx_sus_event_var, msecs_to_jiffies(200));
+   rc = wait_for_completion_timeout(&pHddCtx->rx_sus_event_var,
+             msecs_to_jiffies(200));
 
-   if (rc <= 0)
-   {
+   if (!rc) {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-                 "%s: Not able to suspend Rx thread timeout happened %ld", __func__, rc);
+            "%s: Not able to suspend Rx thread timeout happened", __func__);
 
        clear_bit(RX_SUSPEND_EVENT_MASK, &vosSchedContext->rxEventFlag);
 
@@ -184,10 +184,10 @@
    wake_up_interruptible(&vosSchedContext->mcWaitQueue);
 
    /* Wait for Suspend Confirmation from MC Thread */
-   rc = wait_for_completion_interruptible_timeout(&pHddCtx->mc_sus_event_var, msecs_to_jiffies(200));
+   rc = wait_for_completion_timeout(&pHddCtx->mc_sus_event_var,
+            msecs_to_jiffies(200));
 
-   if(rc <= 0)
-   {
+   if (!rc) {
       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
                 "%s: Not able to suspend MC thread timeout happened %ld",
                 __func__, rc);
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_dp_utils.c qcacld-new/CORE/HDD/src/wlan_hdd_dp_utils.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_dp_utils.c	2016-05-16 10:58:06.458298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_dp_utils.c	2016-05-16 10:58:08.726298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=============================================================================
   wlan_hdd_dp_utils.c
@@ -203,7 +204,7 @@
    int rv;
 
    //18 is MAC Address length plus the colons
-   if ( !pSrcMac && (length > 18 || length < 18) )
+   if ( !pSrcMac || (length > 18 || length < 18) )
    {
       return VOS_STATUS_E_FAILURE;
    }
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_early_suspend.c qcacld-new/CORE/HDD/src/wlan_hdd_early_suspend.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_early_suspend.c	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_early_suspend.c	2016-05-16 10:58:08.702298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=============================================================================
 *     wlan_hdd_early_suspend.c
@@ -158,7 +159,7 @@
 eHalStatus hdd_exit_standby(hdd_context_t *pHddCtx)
 {
     eHalStatus status = VOS_STATUS_SUCCESS;
-    long ret;
+    unsigned long rc;
 
     hddLog(VOS_TRACE_LEVEL_INFO, "%s: WLAN being resumed from standby",__func__);
     INIT_COMPLETION(pHddCtx->full_pwr_comp_var);
@@ -170,13 +171,12 @@
    if(status == eHAL_STATUS_PMC_PENDING)
    {
       //Block on a completion variable. Can't wait forever though
-      ret = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                  &pHddCtx->full_pwr_comp_var,
                  msecs_to_jiffies(WLAN_WAIT_TIME_FULL_PWR));
-      if (0 >= ret)
-      {
+      if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 FL("wait on full_pwr_comp_var failed %ld"), ret);
+             FL("wait on full_pwr_comp_var failed"));
       }
       status = g_full_pwr_status;
       if(g_full_pwr_status != eHAL_STATUS_SUCCESS)
@@ -208,7 +208,7 @@
 {
    eHalStatus halStatus = eHAL_STATUS_SUCCESS;
    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
-   long ret;
+   unsigned long rc;
 
    //Disable IMPS/BMPS as we do not want the device to enter any power
    //save mode on its own during suspend sequence
@@ -231,13 +231,12 @@
    if(halStatus == eHAL_STATUS_PMC_PENDING)
    {
       //Block on a completion variable. Can't wait forever though
-      ret = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                  &pHddCtx->full_pwr_comp_var,
                  msecs_to_jiffies(WLAN_WAIT_TIME_FULL_PWR));
-      if (0 >= ret)
-      {
+      if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 FL( "wait on full_pwr_comp_var failed %ld"), ret);
+                 FL("wait on full_pwr_comp_var failed"));
       }
 
       if(g_full_pwr_status != eHAL_STATUS_SUCCESS)
@@ -274,12 +273,11 @@
    if (halStatus == eHAL_STATUS_PMC_PENDING)
    {
       //Wait till WLAN device enters standby mode
-      ret = wait_for_completion_timeout(&pHddCtx->standby_comp_var,
+      rc = wait_for_completion_timeout(&pHddCtx->standby_comp_var,
          msecs_to_jiffies(WLAN_WAIT_TIME_STANDBY));
-      if (0 >= ret)
-      {
+      if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 FL("wait on standby_comp_var failed %ld"), ret);
+                 FL("wait on standby_comp_var failed"));
       }
 
       if (g_standby_status != eHAL_STATUS_SUCCESS && g_standby_status != eHAL_STATUS_PMC_NOT_NOW)
@@ -318,7 +316,7 @@
 {
    eHalStatus halStatus;
    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
-   long ret;
+   unsigned long rc;
 
    //Stop the Interface TX queue.
    netif_tx_disable(pAdapter->dev);
@@ -338,13 +336,12 @@
    if(halStatus == eHAL_STATUS_PMC_PENDING)
    {
       //Block on a completion variable. Can't wait forever though
-      ret = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                  &pHddCtx->full_pwr_comp_var,
                  msecs_to_jiffies(WLAN_WAIT_TIME_FULL_PWR));
-      if (0 >= ret)
-      {
+      if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 FL("wait on full_pwr_comp_var failed %ld"), ret);
+              FL("wait on full_pwr_comp_var failed"));
       }
 
       if(g_full_pwr_status != eHAL_STATUS_SUCCESS){
@@ -367,13 +364,12 @@
    if(halStatus == eHAL_STATUS_SUCCESS)
    {
       //Block on a completion variable. Can't wait forever though.
-      ret = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                  &pAdapter->disconnect_comp_var,
                  msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-      if (0 >= ret)
-      {
+      if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 FL("wait on disconnect_comp_var failed %ld"), ret);
+             FL("wait on disconnect_comp_var failed"));
       }
    }
    //None of the steps should fail after this. Continue even in case of failure
@@ -407,7 +403,11 @@
    VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
       "%s: calling hdd_set_sme_config",__func__);
    vosStatus = hdd_set_sme_config( pHddCtx );
-   VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+	  VOS_ASSERT_VD( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#else
+	  VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#endif
    if (!VOS_IS_STATUS_SUCCESS(vosStatus))
    {
       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -418,7 +418,11 @@
    VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
       "%s: calling vos_start",__func__);
    vosStatus = vos_start( pHddCtx->pvosContext );
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+   VOS_ASSERT_VD( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#else
    VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#endif
    if (!VOS_IS_STATUS_SUCCESS(vosStatus))
    {
       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -429,7 +433,11 @@
    VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
       "%s: calling hdd_post_voss_start_config",__func__);
    vosStatus = hdd_post_voss_start_config( pHddCtx );
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+   VOS_ASSERT_VD( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#else
    VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#endif
    if (!VOS_IS_STATUS_SUCCESS(vosStatus))
    {
       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -1928,7 +1936,12 @@
    {
       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
                 "%s: Failed to stop WDA", __func__);
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+      VOS_ASSERT_VD(VOS_IS_STATUS_SUCCESS(vosStatus));
+#else
       VOS_ASSERT(VOS_IS_STATUS_SUCCESS(vosStatus));
+#endif
+
       WDA_setNeedShutdown(pVosContext);
    }
 #else
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_hostapd.c	2016-05-16 10:58:06.450298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_hostapd.c	2016-05-16 10:58:08.718298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -1389,6 +1390,8 @@
                 return VOS_STATUS_E_FAULT;
             }
 #endif
+		    break;
+
         case eSAP_DFS_NOL_SET:
             hddLog(VOS_TRACE_LEVEL_INFO, FL("Received eSAP_DFS_NOL_SET event"));
 #if defined CONFIG_CNSS
@@ -1506,12 +1509,14 @@
     // Type check
     if ( gen_ie[0] ==  DOT11F_EID_RSN)
     {
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         // Validity checks
         if ((gen_ie_len < DOT11F_IE_RSN_MIN_LEN ) ||
             (gen_ie_len > DOT11F_IE_RSN_MAX_LEN) )
         {
             return VOS_STATUS_E_FAILURE;
         }
+#endif
         // Skip past the EID byte and length byte
         pRsnIe = gen_ie + 2;
         RSNIeLen = gen_ie_len - 2;
@@ -1865,6 +1870,7 @@
     return VOS_STATUS_SUCCESS;
 }
 
+
 int
 static iw_softap_setparam(struct net_device *dev,
                           struct iw_request_info *info,
@@ -2249,6 +2255,7 @@
                      if (pHostapdAdapter->device_mode ==
                                                       WLAN_HDD_INFRA_STATION)
                      {
+#ifndef CONFIG_VD_PREVENT_DEADCODE
                          /* iwpriv cmd issued on wlan0; get p2p0 vdev chan. */
                          if ((concurrent_state & VOS_P2P_CLIENT) != 0)
                          {
@@ -2259,7 +2266,9 @@
                                                    WLAN_HDD_P2P_CLIENT
                                                    );
                          } else
+#endif
                          {
+
                              /* The 2nd MCC vdev is P2P GO */
                              staAdapter = hdd_get_adapter
                                                     (
@@ -3811,7 +3820,7 @@
       switch ( wps_genie[0] )
       {
          case DOT11F_EID_WPA:
-            if (wps_genie[1] < 2 + 4)
+            if (wps_genie[1] < 2 + 4 || wps_genie[1] > DOT11F_IE_WPA_MAX_LEN + 2 + 4)
             {
                vos_mem_free(pSap_WPSIe);
                kfree(fwps_genie);
@@ -3913,7 +3922,7 @@
       switch ( wps_genie[0] )
       {
          case DOT11F_EID_WPA:
-            if (wps_genie[1] < 2 + 4)
+            if (wps_genie[1] < 2 + 4 || wps_genie[1] > DOT11F_IE_WPA_MAX_LEN + 2 + 4)
             {
                vos_mem_free(pSap_WPSIe);
                kfree(fwps_genie);
@@ -4261,7 +4270,7 @@
 static VOS_STATUS  wlan_hdd_get_classAstats_for_station(hdd_adapter_t *pAdapter, u8 staid)
 {
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
    struct statsContext context;
 
    if (NULL == pAdapter)
@@ -4290,13 +4299,12 @@
    }
    else
    {
-      lrc = wait_for_completion_interruptible_timeout(&context.completion,
+      rc = wait_for_completion_timeout(&context.completion,
             msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-      if (lrc <= 0)
-      {
+      if (!rc) {
          hddLog(VOS_TRACE_LEVEL_ERROR,
-               "%s: SME %s while retrieving link speed",
-              __func__, (0 == lrc) ? "timeout" : "interrupt");
+               "%s: SME timed out while retrieving link speed",
+              __func__);
       }
    }
 
@@ -4323,7 +4331,7 @@
                                                tSirMacAddr macAddress)
 {
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
    struct linkspeedContext context;
    tSirLinkSpeedInfo *linkspeed_req;
 
@@ -4357,13 +4365,12 @@
    }
    else
    {
-      lrc = wait_for_completion_interruptible_timeout(&context.completion,
+      rc = wait_for_completion_timeout(&context.completion,
             msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-      if (lrc <= 0)
-      {
+      if (!rc) {
          hddLog(VOS_TRACE_LEVEL_ERROR,
-               "%s: SME %s while retrieving link speed",
-              __func__, (0 == lrc) ? "timeout" : "interrupt");
+               "%s: SME timed out while retrieving link speed",
+              __func__);
       }
    }
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_ipa.c qcacld-new/CORE/HDD/src/wlan_hdd_ipa.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_ipa.c	2016-05-16 10:58:06.450298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_ipa.c	2016-05-16 10:58:08.710298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 /*========================================================================
 
 \file  wlan_hdd_ipa.c
@@ -1582,6 +1583,7 @@
 	v_U8_t interface_id;
 	hdd_adapter_t  *adapter = NULL;
 
+	iface_context = (struct hdd_ipa_iface_context*) priv;
 	if (evt != IPA_RECEIVE) {
 		skb = (adf_nbuf_t) data;
 		dev_kfree_skb_any(skb);
@@ -1589,7 +1591,6 @@
 		return;
 	}
 
-	iface_context = (struct hdd_ipa_iface_context *) priv;
 	ipa_tx_desc = (struct ipa_rx_data *)data;
 	skb = ipa_tx_desc->skb;
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c qcacld-new/CORE/HDD/src/wlan_hdd_main.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_main.c	2016-05-16 10:58:06.466298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_main.c	2016-05-16 10:58:08.738298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -144,6 +144,8 @@
 #elif defined(HIF_SDIO)
 #include "if_ath_sdio.h"
 #endif
+#include "wmi.h"
+#include "wmi_unified_priv.h"
 #include "wma.h"
 #endif
 
@@ -180,6 +182,7 @@
 static char *country_code;
 static int   enable_11d = -1;
 static int   enable_dfs_chan_scan = -1;
+static char *version_string = QWLAN_VERSIONSTR;
 
 #ifndef MODULE
 static int wlan_hdd_inited;
@@ -249,6 +252,11 @@
    unsigned char data[ANDROID_WIFI_ACTION_FRAME_SIZE];
 } ;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define WLAN_HDD_MAX_TCP_PORT            65535
+#define WLAN_WAIT_TIME_READY_TO_EXTWOW   2000
+#endif
+
 static vos_wake_lock_t wlan_wake_lock;
 /* set when SSR is needed after unload */
 static e_hdd_ssr_required isSsrRequired = HDD_SSR_NOT_REQUIRED;
@@ -700,18 +708,17 @@
    case NETDEV_GOING_DOWN:
         if( pAdapter->scan_info.mScanPending != FALSE )
         {
-           long result;
+           unsigned long rc;
            INIT_COMPLETION(pAdapter->scan_info.abortscan_event_var);
            hdd_abort_mac_scan(pAdapter->pHddCtx, pAdapter->sessionId,
                               eCSR_SCAN_ABORT_DEFAULT);
-           result = wait_for_completion_interruptible_timeout(
+           rc = wait_for_completion_timeout(
                                &pAdapter->scan_info.abortscan_event_var,
                                msecs_to_jiffies(WLAN_WAIT_TIME_ABORTSCAN));
-           if (result <= 0)
-           {
+           if (!rc) {
               VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                        "%s: Timeout occurred while waiting for abortscan %ld",
-                        __func__, result);
+                        "%s: Timeout occurred while waiting for abortscan",
+                        __func__);
            }
         }
         else
@@ -958,13 +965,12 @@
 
        if (VOS_STATUS_SUCCESS == vosStatus)
        {
-           long ret;
+           unsigned long rc;
 
-           ret = wait_for_completion_interruptible_timeout(&pAdapter->disconnect_comp_var,
+           rc = wait_for_completion_timeout(&pAdapter->disconnect_comp_var,
                       msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-           if (ret <= 0)
-               hddLog(LOGE, FL("failure waiting for disconnect_comp_var %ld"),
-                               ret);
+           if (!rc)
+               hddLog(LOGE, FL("failure waiting for disconnect_comp_var"));
         }
    }
 }
@@ -975,7 +981,7 @@
     hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
     hdd_config_t *cfg_param;
     eCsrPhyMode phyMode;
-    long ret;
+    unsigned long rc;
 
     if (NULL == pHddCtx)
     {
@@ -1028,12 +1034,12 @@
 
         if (VOS_STATUS_SUCCESS == vosStatus)
         {
-           ret = wait_for_completion_interruptible_timeout(&pAdapter->disconnect_comp_var,
+           rc = wait_for_completion_timeout(&pAdapter->disconnect_comp_var,
                   msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-           if (ret <= 0)
+           if (!rc)
            {
                VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                        "wait on disconnect_comp_var is failed %ld", ret);
+                        "wait on disconnect_comp_var is failed");
            }
         }
     }
@@ -1711,6 +1717,7 @@
     {
         pScanList = (tpSirBatchScanList)((tANI_U8 *)pBatchScanRsp->scanResults +
                                           nextScanListOffset);
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if (NULL == pScanList)
         {
             VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -1718,6 +1725,7 @@
             isLastAp = TRUE;
            goto done;
         }
+#endif
         numNetworkInScanList = numApMetaInfo = pScanList->numNetworksInScanList;
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
             "Batch scan rsp: numApMetaInfo %d scanId %d",
@@ -2091,11 +2099,10 @@
                 rc = wait_for_completion_timeout(
                      &pAdapter->hdd_get_batch_scan_req_var,
                      msecs_to_jiffies(HDD_GET_BATCH_SCAN_RSP_TIME_OUT));
-                if (0 >= rc)
-                {
+                if (!rc) {
                     VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                           "%s: wait on hdd_get_batch_scan_req_var failed %ld",
-                             __func__, rc);
+                           "%s: wait on hdd_get_batch_scan_req_var failed",
+                             __func__);
                     return -EFAULT;
                 }
             }
@@ -3062,7 +3069,7 @@
     tANI_U8 *inPtr = pValue;
     int tempInt;
     int v = 0;
-    char buf[32];
+    char buf[33];
     *pRate = 0;
     *pTxFlags = 0;
 
@@ -3403,6 +3410,184 @@
      return eHAL_STATUS_SUCCESS;
 }
 #endif
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+static void wlan_hdd_ready_to_extwow(void *callbackContext,
+                                             boolean is_success)
+{
+    hdd_context_t *pHddCtx = (hdd_context_t *)callbackContext;
+    int rc;
+
+    rc = wlan_hdd_validate_context(pHddCtx);
+    if (0 != rc) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return;
+    }
+    pHddCtx->ext_wow_should_suspend = is_success;
+    complete(&pHddCtx->ready_to_extwow);
+}
+
+static int hdd_enable_ext_wow(hdd_adapter_t *pAdapter,
+                               tpSirExtWoWParams arg_params)
+{
+    tSirExtWoWParams params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+    hdd_context_t  *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    int rc;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    INIT_COMPLETION(pHddCtx->ready_to_extwow);
+
+    halStatus = sme_ConfigureExtWoW(hHal, &params,
+                &wlan_hdd_ready_to_extwow, pHddCtx);
+    if (eHAL_STATUS_SUCCESS != halStatus) {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+               FL("sme_ConfigureExtWoW returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    rc = wait_for_completion_timeout(&pHddCtx->ready_to_extwow,
+                             msecs_to_jiffies(WLAN_WAIT_TIME_READY_TO_EXTWOW));
+    if (!rc) {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                   "%s: Failed to get ready to extwow", __func__);
+        return -EPERM;
+    }
+
+    if (pHddCtx->ext_wow_should_suspend) {
+       if (pHddCtx->cfg_ini->extWowGotoSuspend) {
+          VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+              "%s: Received ready to ExtWoW. Going to suspend", __func__);
+
+#if defined(HIF_PCI)
+          wlan_hdd_cfg80211_suspend_wlan(pHddCtx->wiphy, NULL);
+          wlan_hif_pci_suspend();
+#endif
+       }
+    } else {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+              "%s: Received ready to ExtWoW failure", __func__);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_enable_ext_wow_parser(hdd_adapter_t *pAdapter, int vdev_id,
+                                                                  int value)
+{
+   tSirExtWoWParams params;
+   hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+   int rc;
+
+   rc = wlan_hdd_validate_context(pHddCtx);
+   if (0 != rc) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+   }
+   vos_mem_zero(&params, sizeof(params));
+
+   if (value == EXT_WOW_DISABLED) {
+        params.type = value;
+   } else if (value == EXT_WOW_TYPE_APP_TYPE1 &&
+        pHddCtx->is_extwow_app_type1_param_set)
+        params.type = value;
+   else {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+           FL("Set app params before enable it value %d"),value);
+        return -EINVAL;
+   }
+
+   params.vdev_id = vdev_id;
+   params.wakeup_pin_num = pHddCtx->cfg_ini->extWowApp1WakeupPinNumber |
+                      (pHddCtx->cfg_ini->extWowApp2WakeupPinNumber << 8);
+
+   return hdd_enable_ext_wow(pAdapter, &params);
+}
+
+static int hdd_set_app_type1_params(tHalHandle hHal,
+                         tpSirAppType1Params arg_params)
+{
+    tSirAppType1Params params;
+    eHalStatus halStatus = eHAL_STATUS_FAILURE;
+
+    vos_mem_copy(&params, arg_params, sizeof(params));
+
+    halStatus = sme_ConfigureAppType1Params(hHal, &params);
+    if (eHAL_STATUS_SUCCESS != halStatus) {
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+             FL("sme_ConfigureAppType1Params returned failure %d"), halStatus);
+        return -EPERM;
+    }
+
+    return 0;
+}
+
+static int hdd_set_app_type1_parser(hdd_adapter_t *pAdapter,
+                                             char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    tHalHandle hHal = WLAN_HDD_GET_HAL_CTX(pAdapter);
+    char id[20], password[20];
+    tSirAppType1Params params;
+    int ret;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+    }
+
+    if (2 != sscanf(arg, "%8s %16s", id, password)) {
+       VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                 FL("Invalid Number of arguments"));
+       return -EINVAL;
+    }
+
+    memset(&params, 0, sizeof(tSirAppType1Params));
+    params.vdev_id = pAdapter->sessionId;
+
+    params.id_length = strlen(id);
+    vos_mem_copy(params.identification_id, id, params.id_length);
+    params.pass_length = strlen(password);
+    vos_mem_copy(params.password, password, params.pass_length);
+
+    VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+        "%s: %d %.8s %u %.16s %u",
+        __func__, params.vdev_id, params.identification_id, params.id_length,
+        params.password, params.pass_length);
+
+    ret = hdd_set_app_type1_params(hHal, &params);
+    if (ret == 0) {
+        vos_mem_copy(&pHddCtx->app_type1_params, &params, sizeof(tSirAppType1Params));
+    }
+    return ret;
+}
+
+
+
+static int hdd_get_app_type1_params(hdd_adapter_t *pAdapter,
+                                             char *arg, int len)
+{
+    hdd_context_t *pHddCtx = WLAN_HDD_GET_CTX(pAdapter);
+    int ret = 0;
+
+    ret = wlan_hdd_validate_context(pHddCtx);
+    if (0 != ret) {
+       hddLog(VOS_TRACE_LEVEL_ERROR, FL("HDD context is not valid"));
+       return -EINVAL;
+    }
+
+    snprintf(arg, len, "%.8s %.16s",
+             pHddCtx->app_type1_params.identification_id,
+             pHddCtx->app_type1_params.password);
+
+
+    return ret;
+}
+
+#endif
 
 int wlan_hdd_set_mc_rate(hdd_adapter_t *pAdapter, int targetRate)
 {
@@ -3612,7 +3797,7 @@
        else if (strncasecmp(command, "COUNTRY", 7) == 0)
        {
            eHalStatus status;
-           long rc;
+           unsigned long rc;
            char *country_code;
 
            country_code = command + 8;
@@ -3631,11 +3816,10 @@
                                     eSIR_TRUE, eSIR_TRUE);
            if (status == eHAL_STATUS_SUCCESS)
            {
-               rc = wait_for_completion_interruptible_timeout(
+               rc = wait_for_completion_timeout(
                        &pAdapter->change_country_code,
                        msecs_to_jiffies(WLAN_WAIT_TIME_COUNTRY));
-               if (0 >= rc)
-               {
+               if (!rc) {
                    hddLog(VOS_TRACE_LEVEL_ERROR,
                           "%s: SME while setting country code timed out",
                           __func__);
@@ -3782,8 +3966,7 @@
                goto exit;
            }
 
-           if ((roamScanPeriod < (CFG_EMPTY_SCAN_REFRESH_PERIOD_MIN/1000)) ||
-               (roamScanPeriod > (CFG_EMPTY_SCAN_REFRESH_PERIOD_MAX/1000)))
+           if (roamScanPeriod > (CFG_EMPTY_SCAN_REFRESH_PERIOD_MAX/1000))
            {
                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                       "Roam scan period value %d is out of range"
@@ -4217,7 +4400,8 @@
            pHddCtx->cfg_ini->nNeighborScanMinChanTime = minTime;
            sme_setNeighborScanMinChanTime((tHalHandle)(pHddCtx->hHal), minTime);
        }
-       else if (strncmp(command, "SENDACTIONFRAME", 15) == 0)
+       else if ((strncmp(command, "SENDACTIONFRAME", 15) == 0) &&
+	   			priv_data.total_len > 33)
        {
            ret = hdd_parse_sendactionframe(pAdapter, command);
        }
@@ -5138,8 +5322,12 @@
               ret = -EINVAL;
               goto exit;
            }
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
            if ((filterType < WLAN_HDD_DRIVER_MIRACAST_CFG_MIN_VAL ) ||
                (filterType > WLAN_HDD_DRIVER_MIRACAST_CFG_MAX_VAL))
+#else
+           if (filterType > WLAN_HDD_DRIVER_MIRACAST_CFG_MAX_VAL)
+#endif
            {
                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                       "%s: Accepted Values are 0 to 2. 0-Disabled, 1-Source,"
@@ -5525,8 +5713,7 @@
                goto exit;
            }
 
-           if ((dfsScanMode < CFG_ROAMING_DFS_CHANNEL_MIN) ||
-               (dfsScanMode > CFG_ROAMING_DFS_CHANNEL_MAX))
+           if (dfsScanMode > CFG_ROAMING_DFS_CHANNEL_MAX)
            {
                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                       "dfsScanMode value %d is out of range"
@@ -5559,6 +5746,46 @@
                goto exit;
            }
        }
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+       else if (strncmp(command, "ENABLEEXTWOW", 12) == 0) {
+
+           tANI_U8 *value = command;
+           int set_value;
+
+           /* Move pointer to ahead of ENABLEEXTWOW*/
+           value += 12;
+           sscanf(value, "%d", &set_value);
+           ret = hdd_enable_ext_wow_parser(pAdapter,
+                               pAdapter->sessionId, set_value);
+
+       } else if (strncmp(command, "SETAPP1PARAMS", 13) == 0) {
+           tANI_U8 *value = command;
+
+           /* Move pointer to ahead of SETAPP1PARAMS*/
+           value += 13;
+           ret = hdd_set_app_type1_parser(pAdapter,
+                                         value, strlen(value));
+           if (ret >= 0)
+               pHddCtx->is_extwow_app_type1_param_set = TRUE;
+
+       } else if (strncmp(command, "GETAPP1PARAMS", 13) == 0) {
+           if (pHddCtx->is_extwow_app_type1_param_set == TRUE) {
+               ret = hdd_get_app_type1_params(pAdapter,
+                                              command + 13, priv_data.total_len - 13);
+               if (ret == 0) {
+                   if (copy_to_user(priv_data.buf, command, strlen(command))) {
+                       VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                       "%s: failed to copy data to user buffer", __func__);
+                       ret = -EFAULT;
+                       goto exit;
+                   }
+               }
+           } else {
+               ret = -EFAULT;
+           }
+       }
+
+#endif
        else {
            MTRACE(vos_trace(VOS_MODULE_ID_HDD,
                             TRACE_CODE_HDD_UNSUPPORTED_IOCTL,
@@ -5628,6 +5855,9 @@
    return ret;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
+
 int hdd_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
@@ -5674,6 +5904,8 @@
       else
          ret = hdd_driver_ioctl(pAdapter, ifr);
       break;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
    default:
       hddLog(VOS_TRACE_LEVEL_ERROR, "%s: unknown ioctl %d",
              __func__, cmd);
@@ -5889,7 +6121,7 @@
    hdd_station_ctx_t *pHddStaCtx = NULL;
    eHalStatus         hstatus;
    VOS_STATUS         vstatus = VOS_STATUS_SUCCESS;
-   long               lrc;
+   unsigned long      rc;
    struct statsContext context;
    hdd_context_t     *pHddCtx = NULL;
 
@@ -5922,13 +6154,12 @@
    else
    {
       /* request was sent -- wait for the response */
-      lrc = wait_for_completion_interruptible_timeout(&context.completion,
+      rc = wait_for_completion_timeout(&context.completion,
                                     msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-      if (lrc <= 0)
-      {
+      if (!rc) {
          hddLog(VOS_TRACE_LEVEL_ERROR,
-                "%s: SME %s while retrieving statistics",
-                __func__, (0 == lrc) ? "timeout" : "interrupt");
+                "%s: SME timed out while retrieving statistics",
+                __func__);
          vstatus = VOS_STATUS_E_TIMEOUT;
       }
    }
@@ -7336,6 +7567,7 @@
   \return - void
 
   --------------------------------------------------------------------------*/
+
 static void hdd_uninit (struct net_device *dev)
 {
    hdd_adapter_t *pAdapter = WLAN_HDD_GET_PRIV_PTR(dev);
@@ -7365,6 +7597,8 @@
          /* we haven't validated all cases so let this go for now */
       }
 
+
+
       hdd_deinit_adapter(pAdapter->pHddCtx, pAdapter);
 
       /* after uninit our adapter structure will no longer be valid */
@@ -7652,6 +7886,10 @@
       init_completion(&pAdapter->ula_complete);
       init_completion(&pAdapter->change_country_code);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+      init_completion(&pHddCtx->ready_to_extwow);
+#endif
+
 #ifdef FEATURE_WLAN_BATCH_SCAN
       init_completion(&pAdapter->hdd_set_batch_scan_req_var);
       init_completion(&pAdapter->hdd_get_batch_scan_req_var);
@@ -7791,7 +8029,7 @@
    eHalStatus halStatus = eHAL_STATUS_SUCCESS;
    VOS_STATUS status = VOS_STATUS_E_FAILURE;
    tANI_U32 type, subType;
-   long rc = 0;
+   unsigned long rc;
    int ret_val;
 
    INIT_COMPLETION(pAdapter->session_open_comp_var);
@@ -7935,16 +8173,16 @@
 
    if( NULL != cfgState->buf )
    {
-      long rc;
+      unsigned long rc;
       INIT_COMPLETION(pAdapter->tx_action_cnf_event);
-      rc = wait_for_completion_interruptible_timeout(
+      rc = wait_for_completion_timeout(
                      &pAdapter->tx_action_cnf_event,
                      msecs_to_jiffies(ACTION_FRAME_TX_TIMEOUT));
-      if (rc <= 0)
+      if (!rc)
       {
          VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                   "%s HDD Wait for Action Confirmation Failed!! %ld",
-                   __func__, rc);
+                   "%s HDD Wait for Action Confirmation Failed!!",
+                   __func__);
       }
    }
    return;
@@ -8277,16 +8515,15 @@
               {
                  if(halStatus == eHAL_STATUS_PMC_PENDING)
                  {
-                    long ret;
+                    unsigned long rc;
                     //Block on a completion variable. Can't wait forever though
-                    ret = wait_for_completion_interruptible_timeout(
+                    rc = wait_for_completion_timeout(
                                    &pHddCtx->full_pwr_comp_var,
                                    msecs_to_jiffies(1000));
-                    if (ret <= 0)
-                    {
+                    if (!rc) {
                        hddLog(VOS_TRACE_LEVEL_ERROR,
-                              "%s: wait on full_pwr_comp_var failed %ld",
-                              __func__, ret);
+                              "%s: wait on full_pwr_comp_var failed",
+                              __func__);
 }
                  }
                  else
@@ -8460,6 +8697,7 @@
          netif_carrier_off(pAdapter->dev);
 
          hdd_set_conparam( 1 );
+
          break;
       }
       case WLAN_HDD_MONITOR:
@@ -8725,6 +8963,8 @@
   }
 
 #endif
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
 
 
    return pAdapter;
@@ -8880,6 +9120,21 @@
     }
 }
 
+v_BOOL_t wlan_hdd_is_target_resumeok( hdd_context_t *pHddCtx)
+{
+	pVosContextType vos_context = pHddCtx->pvosContext;
+	tp_wma_handle wma_handle = NULL;
+	wmi_unified_t wmi_handle = NULL;
+	if (vos_context) {
+		wma_handle = vos_context->pWDAContext;
+		if(wma_handle) {
+			wmi_handle = wma_handle->wmi_handle;
+			return adf_os_atomic_read(&wmi_handle->is_target_resumeok);
+		}
+	}
+	return TRUE;
+}
+
 VOS_STATUS hdd_stop_adapter( hdd_context_t *pHddCtx, hdd_adapter_t *pAdapter,
                              const v_BOOL_t bCloseSession)
 {
@@ -8887,19 +9142,23 @@
    hdd_wext_state_t *pWextState = WLAN_HDD_GET_WEXT_STATE_PTR(pAdapter);
    union iwreq_data wrqu;
    tSirUpdateIE updateIE ;
-   long ret;
+   unsigned long rc;
 
    ENTER();
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
+
    netif_tx_disable(pAdapter->dev);
    netif_carrier_off(pAdapter->dev);
+
    switch(pAdapter->device_mode)
    {
       case WLAN_HDD_INFRA_STATION:
       case WLAN_HDD_P2P_CLIENT:
       case WLAN_HDD_P2P_DEVICE:
-         if( hdd_connIsConnected( WLAN_HDD_GET_STATION_CTX_PTR( pAdapter )) )
-         {
+         if( hdd_connIsConnected( WLAN_HDD_GET_STATION_CTX_PTR( pAdapter ))
+            && wlan_hdd_is_target_resumeok(pHddCtx)) {
             if (pWextState->roamProfile.BSSType == eCSR_BSS_TYPE_START_IBSS)
                 halStatus = sme_RoamDisconnect(pHddCtx->hHal,
                                              pAdapter->sessionId,
@@ -8911,14 +9170,13 @@
             //success implies disconnect command got queued up successfully
             if(halStatus == eHAL_STATUS_SUCCESS)
             {
-               ret = wait_for_completion_interruptible_timeout(
+               rc = wait_for_completion_timeout(
                           &pAdapter->disconnect_comp_var,
                           msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-               if (ret <= 0)
-               {
+               if (!rc) {
                   hddLog(VOS_TRACE_LEVEL_ERROR,
-                         "%s: wait on disconnect_comp_var failed %ld",
-                         __func__, ret);
+                         "%s: wait on disconnect_comp_var failed",
+                         __func__);
                }
            }
            else
@@ -8976,7 +9234,8 @@
          /* It is possible that the caller of this function does not
           * wish to close the session
           */
-         if (VOS_TRUE == bCloseSession &&
+         if ( (wlan_hdd_is_target_resumeok(pHddCtx)) &&
+             VOS_TRUE == bCloseSession &&
              test_bit(SME_SESSION_OPENED, &pAdapter->event_flags))
          {
             INIT_COMPLETION(pAdapter->session_close_comp_var);
@@ -8985,13 +9244,12 @@
                      hdd_smeCloseSessionCallback, pAdapter))
             {
                //Block on a completion variable. Can't wait forever though.
-               ret = wait_for_completion_timeout(
+               rc = wait_for_completion_timeout(
                      &pAdapter->session_close_comp_var,
                      msecs_to_jiffies(WLAN_WAIT_TIME_SESSIONOPENCLOSE));
-               if (0 >= ret)
-               {
-                  hddLog(LOGE, "%s: failure waiting for session_close_comp_var %ld",
-                        __func__, ret);
+               if (!rc) {
+                  hddLog(LOGE, "%s: failure waiting for session_close_comp_var",
+                        __func__);
                }
             }
          }
@@ -9220,6 +9478,9 @@
       switch(pAdapter->device_mode)
       {
          case WLAN_HDD_INFRA_STATION:
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
+
          case WLAN_HDD_P2P_CLIENT:
          case WLAN_HDD_P2P_DEVICE:
 
@@ -9305,7 +9566,7 @@
    hdd_adapter_t *pAdapter;
    VOS_STATUS status;
    v_U32_t roamId;
-   long ret;
+   unsigned long rc;
 
    ENTER();
 
@@ -9329,12 +9590,12 @@
          sme_RoamDisconnect(pHddCtx->hHal, pAdapter->sessionId,
                              eCSR_DISCONNECT_REASON_UNSPECIFIED);
 
-         ret = wait_for_completion_interruptible_timeout(
+         rc = wait_for_completion_timeout(
                         &pAdapter->disconnect_comp_var,
                         msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-         if (0 >= ret)
-            hddLog(LOGE, "%s: failure waiting for disconnect_comp_var %ld",
-                   __func__, ret);
+         if (!rc)
+            hddLog(LOGE, "%s: failure waiting for disconnect_comp_var",
+                   __func__);
          pWextState->roamProfile.csrPersona = pAdapter->device_mode;
          pHddCtx->isAmpAllowed = VOS_FALSE;
          sme_RoamConnect(pHddCtx->hHal,
@@ -9977,6 +10238,7 @@
    vos_mem_zero(&scanReq, sizeof(tCsrScanRequest));
    vos_mem_set(&scanReq.bssid, sizeof(tCsrBssid), 0xff);
    scanReq.BSSType = eCSR_BSS_TYPE_ANY;
+   scanReq.ChannelInfo.ChannelList = NULL;
 
    if(sme_Is11dSupported(pHddCtx->hHal))
    {
@@ -10018,7 +10280,7 @@
          __func__, halStatus );
    }
 
-   if(sme_Is11dSupported(pHddCtx->hHal))
+   if(sme_Is11dSupported(pHddCtx->hHal) && scanReq.ChannelInfo.ChannelList)
         vos_mem_free(scanReq.ChannelInfo.ChannelList);
 }
 
@@ -10157,7 +10419,7 @@
    VOS_STATUS vosStatus;
    struct wiphy *wiphy = pHddCtx->wiphy;
    struct statsContext powerContext;
-   long lrc;
+   unsigned long rc;
 #if defined (QCA_WIFI_2_0) && \
     defined (QCA_WIFI_ISOC)
    adf_os_device_t adf_ctx;
@@ -10248,66 +10510,67 @@
    }
 #endif
 
-   if(!pConfig->enablePowersaveOffload)
-   {
-      //Disable IMPS/BMPS as we do not want the device to enter any power
-      //save mode during shutdown
-      sme_DisablePowerSave(pHddCtx->hHal, ePMC_IDLE_MODE_POWER_SAVE);
-      sme_DisablePowerSave(pHddCtx->hHal, ePMC_BEACON_MODE_POWER_SAVE);
-      sme_DisablePowerSave(pHddCtx->hHal, ePMC_UAPSD_MODE_POWER_SAVE);
-
-      //Ensure that device is in full power as we will touch H/W during vos_Stop
-      init_completion(&powerContext.completion);
-      powerContext.magic = POWER_CONTEXT_MAGIC;
-
-      halStatus = sme_RequestFullPower(pHddCtx->hHal, hdd_full_power_callback,
-            &powerContext, eSME_FULL_PWR_NEEDED_BY_HDD);
-
-      if (eHAL_STATUS_SUCCESS != halStatus)
-      {
-         if (eHAL_STATUS_PMC_PENDING == halStatus)
-         {
-            /* request was sent -- wait for the response */
-            lrc = wait_for_completion_interruptible_timeout(
-                  &powerContext.completion,
-                  msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
-            if (lrc <= 0)
-            {
-               hddLog(VOS_TRACE_LEVEL_ERROR,
-                     "%s: %s while requesting full power",
-                     __func__, (0 == lrc) ? "timeout" : "interrupt");
-            }
-         }
-         else
-         {
-            hddLog(VOS_TRACE_LEVEL_ERROR,
-                  "%s: Request for Full Power failed, status %d",
-                  __func__, halStatus);
-            /* continue -- need to clean up as much as possible */
-         }
-      }
-      /* either we never sent a request, we sent a request and received a
-         response or we sent a request and timed out.  if we never sent a
-         request or if we sent a request and got a response, we want to
-         clear the magic out of paranoia.  if we timed out there is a
-         race condition such that the callback function could be
-         executing at the same time we are. of primary concern is if the
-         callback function had already verified the "magic" but had not
-         yet set the completion variable when a timeout occurred. we
-         serialize these activities by invalidating the magic while
-         holding a shared spinlock which will cause us to block if the
-         callback is currently executing */
-      spin_lock(&hdd_context_lock);
-      powerContext.magic = 0;
-      spin_unlock(&hdd_context_lock);
-   }
-   else
-   {
-      /*
-       * Powersave Offload Case
-       * Disable Idle Power Save Mode
-       */
-      hdd_set_idle_ps_config(pHddCtx, FALSE);
+   if ((wlan_hdd_is_target_resumeok(pHddCtx))) {
+     if(!pConfig->enablePowersaveOffload)
+     {
+        //Disable IMPS/BMPS as we do not want the device to enter any power
+        //save mode during shutdown
+        sme_DisablePowerSave(pHddCtx->hHal, ePMC_IDLE_MODE_POWER_SAVE);
+        sme_DisablePowerSave(pHddCtx->hHal, ePMC_BEACON_MODE_POWER_SAVE);
+        sme_DisablePowerSave(pHddCtx->hHal, ePMC_UAPSD_MODE_POWER_SAVE);
+
+        //Ensure that device is in full power as we will touch H/W during vos_Stop
+        init_completion(&powerContext.completion);
+        powerContext.magic = POWER_CONTEXT_MAGIC;
+
+        halStatus = sme_RequestFullPower(pHddCtx->hHal, hdd_full_power_callback,
+              &powerContext, eSME_FULL_PWR_NEEDED_BY_HDD);
+
+        if (eHAL_STATUS_SUCCESS != halStatus)
+        {
+           if (eHAL_STATUS_PMC_PENDING == halStatus)
+           {
+              /* request was sent -- wait for the response */
+              rc = wait_for_completion_timeout(
+                    &powerContext.completion,
+                    msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
+              if (!rc) {
+                 hddLog(VOS_TRACE_LEVEL_ERROR,
+                        "%s: timed out while requesting full power",
+                        __func__);           
+              }
+           }
+           else
+           {
+              hddLog(VOS_TRACE_LEVEL_ERROR,
+                    "%s: Request for Full Power failed, status %d",
+                    __func__, halStatus);
+              /* continue -- need to clean up as much as possible */
+           }
+        }
+        /* either we never sent a request, we sent a request and received a
+           response or we sent a request and timed out.  if we never sent a
+           request or if we sent a request and got a response, we want to
+           clear the magic out of paranoia.  if we timed out there is a
+           race condition such that the callback function could be
+           executing at the same time we are. of primary concern is if the
+           callback function had already verified the "magic" but had not
+           yet set the completion variable when a timeout occurred. we
+           serialize these activities by invalidating the magic while
+           holding a shared spinlock which will cause us to block if the
+           callback is currently executing */
+        spin_lock(&hdd_context_lock);
+        powerContext.magic = 0;
+        spin_unlock(&hdd_context_lock);
+     }
+     else
+     {
+        /*
+         * Powersave Offload Case
+         * Disable Idle Power Save Mode
+         */
+        hdd_set_idle_ps_config(pHddCtx, FALSE);
+     }
    }
 
    hdd_debugfs_exit(pHddCtx);
@@ -10476,13 +10739,6 @@
       return;
    }
 
-   if(NULL == pVosContext) {
-      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,
-            "%s:Invalid global VOSS context", __func__);
-      EXIT();
-      return;
-   }
-
    //Get the HDD context.
    pHddCtx = (hdd_context_t *)vos_get_context(VOS_MODULE_ID_HDD,
          pVosContext);
@@ -11088,6 +11344,7 @@
    int ret;
    int i;
    struct wiphy *wiphy;
+   unsigned long rc;
 #ifdef QCA_WIFI_2_0
    adf_os_device_t adf_ctx;
 #endif
@@ -11164,6 +11421,9 @@
 
    hdd_list_init( &pHddCtx->hddAdapters, MAX_NUMBER_OF_ADAPTERS );
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#endif
+
 #ifdef FEATURE_WLAN_TDLS
    /* tdls_lock is initialized before an hdd_open_adapter ( which is
     * invoked by other instances also) to protect the concurrent
@@ -11659,13 +11919,12 @@
             country_code, pAdapter, pHddCtx->pvosContext, eSIR_TRUE, eSIR_TRUE);
       if (eHAL_STATUS_SUCCESS == ret)
       {
-          ret = wait_for_completion_interruptible_timeout(
+          rc = wait_for_completion_timeout(
                 &pAdapter->change_country_code,
                 msecs_to_jiffies(WLAN_WAIT_TIME_COUNTRY));
-          if (0 >= ret)
-          {
+          if (!rc) {
               hddLog(VOS_TRACE_LEVEL_ERROR,
-                     "%s: SME while setting country code timed out", __func__);
+                   "%s: SME while setting country code timed out", __func__);
           }
       }
       else
@@ -11986,9 +12245,9 @@
    /* Initialize the RoC Request queue and work. */
    hdd_list_init((&pHddCtx->hdd_roc_req_q), MAX_ROC_REQ_QUEUE_ENTRY);
 #ifdef CONFIG_CNSS
-   cnss_init_work(&pHddCtx->rocReqWork, hdd_roc_req_work);
+   cnss_init_delayed_work(&pHddCtx->rocReqWork, wlan_hdd_roc_request_dequeue);
 #else
-   INIT_WORK(&pHddCtx->rocReqWork, hdd_roc_req_work);
+   INIT_DELAYED_WORK(&pHddCtx->rocReqWork, wlan_hdd_roc_request_dequeue);
 #endif
 
 #if defined(QCA_WIFI_2_0) && !defined(QCA_WIFI_ISOC)
@@ -12095,6 +12354,11 @@
 
 err_free_hdd_context:
    hdd_allow_suspend();
+
+   /* wiphy_free() will free the HDD context so remove global reference */
+   if (pVosContext)
+      ((VosContextType*)(pVosContext))->pHDDContext = NULL;
+
    wiphy_free(wiphy) ;
    //kfree(wdev) ;
    VOS_BUG(1);
@@ -12142,6 +12406,9 @@
 #ifdef HAVE_WCNSS_CAL_DOWNLOAD
    int max_retries = 0;
 #endif
+#if !defined(CONFIG_USB_PRELOAD)
+   unsigned long rc;
+#endif
 
 #ifdef WLAN_LOGGING_SOCK_SVC_ENABLE
    wlan_logging_sock_init_svc();
@@ -12153,8 +12420,17 @@
 #ifdef HDD_TRACE_RECORD
    MTRACE(hddTraceInit());
 #endif
-   pr_info("%s: loading driver v%s\n", WLAN_MODULE_NAME,
-           QWLAN_VERSIONSTR TIMER_MANAGER_STR MEMORY_DEBUG_STR);
+   pr_info("%s: loading driver %s v%s\n", WLAN_MODULE_NAME,
+           hdd_get_version_string(), TIMER_MANAGER_STR MEMORY_DEBUG_STR);
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	status = vos_prealloc_init();
+	if (!VOS_IS_STATUS_SUCCESS(status))
+	{
+		hddLog(VOS_TRACE_LEVEL_FATAL,"%s: Failed to prealloc memory", __func__);
+		ret_status = -1;
+	}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 #ifdef ANI_BUS_TYPE_PCI
 
@@ -12241,11 +12517,15 @@
 #endif
    init_completion(&wlan_start_comp);
    ret_status = hif_register_driver();
+#if defined(CONFIG_USB_PRELOAD)
+   if (ret_status == 0)
+		return 0;
+#else
    if (!ret_status) {
-       ret_status = wait_for_completion_interruptible_timeout(
+       rc = wait_for_completion_timeout(
                            &wlan_start_comp,
                            msecs_to_jiffies(WLAN_WAIT_TIME_WLANSTART));
-       if (!ret_status) {
+       if (!rc) {
           hddLog(VOS_TRACE_LEVEL_FATAL,
             "%s: timed-out waiting for hif_register_driver", __func__);
            ret_status = -1;
@@ -12267,6 +12547,7 @@
        pr_info("%s: driver loaded\n", WLAN_MODULE_NAME);
        return 0;
    }
+#endif /* CONFIG_USB_PRELOAD */
 #endif
 
 #ifdef QCA_WIFI_ISOC
@@ -12300,6 +12581,7 @@
 
       pr_err("%s: driver load failure\n", WLAN_MODULE_NAME);
    }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
    else
    {
       //Send WLAN UP indication to Nlink Service
@@ -12307,6 +12589,7 @@
 
       pr_info("%s: driver loaded\n", WLAN_MODULE_NAME);
    }
+#endif
 
    EXIT();
 
@@ -12358,7 +12641,7 @@
 #endif
    v_CONTEXT_t pVosContext = NULL;
 
-   pr_info("%s: unloading driver v%s\n", WLAN_MODULE_NAME, QWLAN_VERSIONSTR);
+   pr_info("%s: unloading driver v%s\n", WLAN_MODULE_NAME, hdd_get_version_string());
 
    //Get the global vos context
    pVosContext = vos_get_global_context(VOS_MODULE_ID_SYS, NULL);
@@ -12424,6 +12707,11 @@
 #ifdef TIMER_MANAGER
    vos_timer_exit();
 #endif
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+	vos_prealloc_deinit();
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
    vos_mem_exit();
 #endif
@@ -12643,6 +12931,7 @@
 #ifdef WLAN_FEATURE_MBSSID
     WLANSAP_DisassocSta(WLAN_HDD_GET_SAP_CTX_PTR(pAdapter), pDestMacAddress);
 #else
+    msleep(10);
     WLANSAP_DisassocSta(pVosContext,pDestMacAddress);
 #endif
 }
@@ -12695,6 +12984,28 @@
     return VOS_STA;
 }
 
+/**---------------------------------------------------------------------------
+
+  \brief hdd_get_version_string() -
+
+  \param  - None
+
+  \return - printer to ver_str
+
+  --------------------------------------------------------------------------*/
+char * hdd_get_version_string ( void )
+{
+	static char ver_str[32];
+
+	if (strnlen(version_string, 32) == 32) {
+		hddLog(VOS_TRACE_LEVEL_ERROR, "%s, string too long, use default\n",
+			__func__);
+		return QWLAN_VERSIONSTR;
+	}
+	vos_mem_copy(ver_str, version_string, strnlen(version_string, 32));
+	return ver_str;
+}
+
 /* Decide whether to allow/not the apps power collapse.
  * Allow apps power collapse if we are in connected state.
  * if not, allow only if we are in IMPS  */
@@ -13315,7 +13626,7 @@
         strlcpy(data->chip_from, "Qualcomm", WLAN_SVC_MAX_STR_LEN);
     else
         strlcpy(data->chip_from, "Unknown", WLAN_SVC_MAX_STR_LEN);
-    strlcpy(data->host_version, QWLAN_VERSIONSTR, WLAN_SVC_MAX_STR_LEN);
+    strlcpy(data->host_version, hdd_get_version_string(), WLAN_SVC_MAX_STR_LEN);
     scnprintf(data->fw_version, WLAN_SVC_MAX_STR_LEN, "%d.%d.%d.%d",
               (fw_version & 0xf0000000) >> 28,
               (fw_version & 0xf000000) >> 24,
@@ -13650,6 +13961,7 @@
 
 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Qualcomm Atheros, Inc.");
+MODULE_VERSION("3.0.7.158");
 MODULE_DESCRIPTION("WLAN HOST DEVICE DRIVER");
 
 #if defined(QCA_WIFI_2_0) && defined(QCA_WIFI_FTM) && !defined(QCA_WIFI_ISOC)
@@ -13670,3 +13982,7 @@
 
 module_param(country_code, charp,
              S_IRUSR | S_IRGRP | S_IROTH);
+
+module_param(version_string, charp,
+				S_IRUSR | S_IRGRP | S_IROTH);
+
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_oemdata.c qcacld-new/CORE/HDD/src/wlan_hdd_oemdata.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_oemdata.c	2016-05-16 10:58:06.458298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_oemdata.c	2016-05-16 10:58:08.726298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #ifdef FEATURE_OEM_DATA_SUPPORT
 
@@ -659,7 +660,7 @@
    tAniMsgHdr *aniHdr;
    tHddChannelInfo *pHddChanInfo;
    tHddChannelInfo hddChanInfo;
-   tSmeChannelInfo smeChanInfo;
+  tSmeChannelInfo smeChanInfo = {0};
    tANI_U8 chanId;
    eHalStatus status = eHAL_STATUS_FAILURE;
    int i;
@@ -796,6 +797,7 @@
       return;
    }
 
+   memset(&smeChanInfo, 0, sizeof(tSmeChannelInfo));
    status = sme_getChannelInfo(pHddCtx->hHal, chanId, &smeChanInfo);
    if (eHAL_STATUS_SUCCESS != status)
    {
@@ -926,7 +928,7 @@
    }
 
    msg_hdr = NLMSG_DATA(nlh);
-
+#ifndef CONFIG_VD_PREVENT_DEADCODE
    if (!msg_hdr)
    {
      VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -934,6 +936,7 @@
      send_oem_err_rsp_nlink_msg(nlh->nlmsg_pid, OEM_ERR_NULL_MESSAGE_HEADER);
      return -1;
    }
+#endif
 
    if (nlh->nlmsg_len < NLMSG_LENGTH(sizeof(tAniMsgHdr) + msg_hdr->length))
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_p2p.c	2016-05-16 10:58:06.466298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_p2p.c	2016-05-16 10:58:08.738298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -53,6 +54,7 @@
 #include "vos_types.h"
 #include "vos_trace.h"
 #include "vos_sched.h"
+#include <adf_os_time.h>
 
 //Ms to Micro Sec
 #define MS_TO_MUS(x)   ((x)*1000);
@@ -184,6 +186,12 @@
     hdd_adapter_t *pAdapter = (hdd_adapter_t*) pCtx;
     hdd_cfg80211_state_t *cfgState = WLAN_HDD_GET_CFG_STATE_PTR( pAdapter );
     hdd_remain_on_chan_ctx_t *pRemainChanCtx;
+    hdd_context_t *hdd_ctx = WLAN_HDD_GET_CTX(pAdapter);
+
+    if (0 != wlan_hdd_validate_context(hdd_ctx)) {
+        hddLog(LOGE, FL("Invalid HDD context"));
+        return eHAL_STATUS_FAILURE;
+    }
 
     mutex_lock(&cfgState->remain_on_chan_ctx_lock);
     pRemainChanCtx = cfgState->remain_on_chan_ctx;
@@ -201,7 +209,19 @@
     vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
 
     cfgState->remain_on_chan_ctx = NULL;
-    mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+
+    /*
+     * Resetting the roc in progress early ensures that the subsequent
+     * roc requests are immediately processed without being queued
+     */
+    pAdapter->is_roc_inprogress = false;
+    /*
+     * If the allow suspend is done later, the scheduled roc wil prevent
+     * the system from going into suspend and immediately this logic
+     * will allow the system to go to suspend breaking the exising logic.
+     * Basically, the system must not go into suspend while roc is in progress.
+     */
+    hdd_allow_suspend();
 
     if( REMAIN_ON_CHANNEL_REQUEST == pRemainChanCtx->rem_on_chan_request)
     {
@@ -223,7 +243,18 @@
                               pRemainChanCtx->chan_type,
 #endif
                               GFP_KERNEL);
+        pAdapter->lastRocTs = vos_timer_get_system_time();
     }
+    mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+
+    /* Schedule any pending RoC: Any new roc request during this time
+     * would have got queued in 'wlan_hdd_request_remain_on_channel'
+     * since the queue is not empty. So, the roc at the head of the
+     * queue will only get the priority. Scheduling the work queue
+     * after sending any cancel remain on channel event will also
+     * ensure that the cancel roc is sent without any delays.
+     */
+    schedule_delayed_work(&hdd_ctx->rocReqWork, 0);
 
     if ( ( WLAN_HDD_INFRA_STATION == pAdapter->device_mode ) ||
          ( WLAN_HDD_P2P_CLIENT == pAdapter->device_mode ) ||
@@ -231,13 +262,17 @@
        )
     {
         tANI_U8 sessionId = pAdapter->sessionId;
+        mutex_lock(&cfgState->remain_on_chan_ctx_lock);
         if( REMAIN_ON_CHANNEL_REQUEST == pRemainChanCtx->rem_on_chan_request)
         {
+            mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
             sme_DeregisterMgmtFrame(
                        hHal, sessionId,
                       (SIR_MAC_MGMT_FRAME << 2) | ( SIR_MAC_MGMT_PROBE_REQ << 4),
                        NULL, 0 );
         }
+        else
+           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
     }
     else if ( ( WLAN_HDD_SOFTAP== pAdapter->device_mode ) ||
               ( WLAN_HDD_P2P_GO == pAdapter->device_mode )
@@ -254,6 +289,7 @@
 
     }
 
+    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
     if(pRemainChanCtx->action_pkt_buff.frame_ptr != NULL
        && pRemainChanCtx->action_pkt_buff.frame_length != 0 )
     {
@@ -262,11 +298,10 @@
         pRemainChanCtx->action_pkt_buff.frame_length = 0;
     }
     vos_mem_free( pRemainChanCtx );
-    complete(&pAdapter->cancel_rem_on_chan_var);
-    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
-    pAdapter->is_roc_inprogress = FALSE;
     mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
-    hdd_allow_suspend();
+    if (eHAL_STATUS_SUCCESS != status)
+        complete(&pAdapter->rem_on_chan_ready_event);
+    complete(&pAdapter->cancel_rem_on_chan_var);
     return eHAL_STATUS_SUCCESS;
 }
 
@@ -274,28 +309,37 @@
 {
     hdd_cfg80211_state_t *cfgState = WLAN_HDD_GET_CFG_STATE_PTR( pAdapter );
     hdd_remain_on_chan_ctx_t *pRemainChanCtx;
-    int status = 0;
+    unsigned long rc;
 
     mutex_lock(&cfgState->remain_on_chan_ctx_lock);
     if(cfgState->remain_on_chan_ctx != NULL)
     {
         hddLog( LOG1, "Cancel Existing Remain on Channel");
 
-        vos_timer_stop(&cfgState->remain_on_chan_ctx->hdd_remain_on_chan_timer);
+        if (VOS_TIMER_STATE_RUNNING == vos_timer_getCurrentState(
+                    &cfgState->remain_on_chan_ctx->hdd_remain_on_chan_timer))
+            vos_timer_stop(&cfgState->remain_on_chan_ctx->
+                                              hdd_remain_on_chan_timer);
+
         pRemainChanCtx = cfgState->remain_on_chan_ctx;
+        if (NULL == pRemainChanCtx)
+        {
+            mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+            hddLog(LOGE, FL("pRemainChanCtx is NULL"));
+            return;
+        }
         if (pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress == TRUE)
         {
             mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
             hddLog( LOG1,
                     "ROC timer cancellation in progress,"
                     " wait for completion");
-            status = wait_for_completion_interruptible_timeout(&pAdapter->cancel_rem_on_chan_var,
+            rc = wait_for_completion_timeout(&pAdapter->cancel_rem_on_chan_var,
                                msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
-            if (0 >= status)
-            {
+            if (!rc) {
                 hddLog( LOGE,
-                        "%s:wait on cancel_rem_on_chan_var failed %d",
-                         __func__, status);
+                        "%s:wait on cancel_rem_on_chan_var timed out",
+                         __func__);
             }
             return;
         }
@@ -306,13 +350,12 @@
          * received and if the driver issues cancel remain on channel then lim
          * will be in unknown state.
          */
-        status = wait_for_completion_interruptible_timeout(&pAdapter->rem_on_chan_ready_event,
+        rc = wait_for_completion_timeout(&pAdapter->rem_on_chan_ready_event,
                msecs_to_jiffies(WAIT_REM_CHAN_READY));
-        if (0 >= status)
-        {
+        if (!rc) {
             hddLog( LOGE,
-                    "%s: timeout waiting for remain on channel ready indication %d",
-                    __func__, status);
+                    "%s: timeout waiting for remain on channel ready indication",
+                    __func__);
         }
 
         INIT_COMPLETION(pAdapter->cancel_rem_on_chan_var);
@@ -341,14 +384,14 @@
 #endif
         }
 
-        status = wait_for_completion_interruptible_timeout(&pAdapter->cancel_rem_on_chan_var,
+        rc = wait_for_completion_timeout(&pAdapter->cancel_rem_on_chan_var,
                msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
 
-        if (0 >= status)
-        {
+        if (!rc) {
             hddLog( LOGE,
-                    "%s: timeout waiting for cancel remain on channel ready indication %d",
-                    __func__, status);
+                    "%s: timeout waiting for cancel remain on channel ready"
+                    " indication",
+                    __func__);
         }
         hdd_allow_suspend();
     } else
@@ -383,8 +426,10 @@
 /* Clean up RoC context at hdd_stop_adapter*/
 void wlan_hdd_cleanup_remain_on_channel_ctx(hdd_adapter_t *pAdapter)
 {
-    v_U8_t status,retry = 0;
+    unsigned long rc;
+    v_U8_t retry = 0;
     hdd_cfg80211_state_t *cfgState = WLAN_HDD_GET_CFG_STATE_PTR(pAdapter);
+    hdd_remain_on_chan_ctx_t *roc_ctx;
 
     mutex_lock(&cfgState->remain_on_chan_ctx_lock);
     while (pAdapter->is_roc_inprogress)
@@ -397,6 +442,28 @@
         if (retry++ > 3) {
            VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                      "%s: ROC completion is not received.!!!", __func__);
+
+           mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+           roc_ctx = cfgState->remain_on_chan_ctx;
+           if (roc_ctx == NULL)
+           {
+               mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+               hddLog(LOG1, FL("roc_ctx is NULL!"));
+               return;
+           }
+           if (roc_ctx->hdd_remain_on_chan_cancel_in_progress == true) {
+                mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+                hddLog(LOG1, FL("roc cancel already in progress"));
+                /*
+                 * Since a cancel roc is already issued and is
+                 * in progress, we need not send another
+                 * cancel roc again. Instead we can just wait
+                 * for cancel roc completion
+                 */
+                goto wait;
+           }
+           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+
            if (pAdapter->device_mode == WLAN_HDD_P2P_GO)
            {
                WLANSAP_CancelRemainOnChannel(
@@ -407,39 +474,38 @@
                sme_CancelRemainOnChannel(WLAN_HDD_GET_HAL_CTX(pAdapter),
                                      pAdapter->sessionId);
            }
-
-           status = wait_for_completion_interruptible_timeout(&pAdapter->cancel_rem_on_chan_var,
+wait:
+           rc = wait_for_completion_timeout(&pAdapter->cancel_rem_on_chan_var,
                                              msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
-           if ((!status) || (status == -ERESTARTSYS))
-           {
-                hdd_remain_on_chan_ctx_t *pRemainChanCtx;
+           if (!rc) {
                 VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                             "%s: Timeout occurred while waiting for RoC Cancellation" ,
                               __func__);
                 mutex_lock(&cfgState->remain_on_chan_ctx_lock);
-                pRemainChanCtx = cfgState->remain_on_chan_ctx;
-                if (pRemainChanCtx != NULL)
+                roc_ctx = cfgState->remain_on_chan_ctx;
+                if (roc_ctx != NULL)
                 {
                      cfgState->remain_on_chan_ctx = NULL;
-                     vos_timer_stop(&pRemainChanCtx->hdd_remain_on_chan_timer);
-                     vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
-                     if (pRemainChanCtx->action_pkt_buff.frame_ptr != NULL
-                           && pRemainChanCtx->action_pkt_buff.frame_length != 0)
+                     vos_timer_stop(&roc_ctx->hdd_remain_on_chan_timer);
+                     vos_timer_destroy(&roc_ctx->hdd_remain_on_chan_timer);
+                     if (roc_ctx->action_pkt_buff.frame_ptr != NULL
+                           && roc_ctx->action_pkt_buff.frame_length != 0)
                      {
-                         vos_mem_free(pRemainChanCtx->action_pkt_buff.frame_ptr);
-                         pRemainChanCtx->action_pkt_buff.frame_ptr = NULL;
-                         pRemainChanCtx->action_pkt_buff.frame_length = 0;
+                         vos_mem_free(roc_ctx->action_pkt_buff.frame_ptr);
+                         roc_ctx->action_pkt_buff.frame_ptr = NULL;
+                         roc_ctx->action_pkt_buff.frame_length = 0;
                      }
-                     vos_mem_free( pRemainChanCtx );
+                     vos_mem_free(roc_ctx);
                      pAdapter->is_roc_inprogress = FALSE;
                 }
                 mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
-
             }
+            /* hold the lock before break from the loop */
+            mutex_lock(&cfgState->remain_on_chan_ctx_lock);
             break;
        }
        mutex_lock(&cfgState->remain_on_chan_ctx_lock);
-   }
+   } /* end of while */
    mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 
 }
@@ -510,6 +576,17 @@
     v_BOOL_t isGoPresent = VOS_FALSE;
     unsigned int duration;
 
+    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+    if (pAdapter->is_roc_inprogress == TRUE) {
+        mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+        hddLog(VOS_TRACE_LEVEL_ERROR,
+               FL("remain on channel request is in execution"));
+        return -EBUSY;
+    }
+    cfgState->remain_on_chan_ctx = pRemainChanCtx;
+    cfgState->current_freq = pRemainChanCtx->chan.center_freq;
+    pAdapter->is_roc_inprogress = TRUE;
+
     /* Initialize Remain on chan timer */
     vos_status = vos_timer_init(&pRemainChanCtx->hdd_remain_on_chan_timer,
                                 VOS_TIMER_TYPE_SW,
@@ -517,14 +594,14 @@
                                 pAdapter);
     if (vos_status != VOS_STATUS_SUCCESS)
     {
-         hddLog(VOS_TRACE_LEVEL_ERROR,
-             "%s: Not able to initalize remain_on_chan timer",__func__);
+          hddLog(VOS_TRACE_LEVEL_ERROR,
+              FL("Not able to initialize remain_on_chan timer"));
+         cfgState->remain_on_chan_ctx = NULL;
+         pAdapter->is_roc_inprogress = FALSE;
+         vos_mem_free(pRemainChanCtx);
+         mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+         return -EINVAL;
     }
-
-    mutex_lock(&cfgState->remain_on_chan_ctx_lock);
-    cfgState->remain_on_chan_ctx = pRemainChanCtx;
-    cfgState->current_freq = pRemainChanCtx->chan.center_freq;
-    pAdapter->is_roc_inprogress = TRUE;
     mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
 
     status =  hdd_get_front_adapter ( pHddCtx, &pAdapterNode );
@@ -559,19 +636,30 @@
         tANI_U8 sessionId = pAdapter->sessionId;
         //call sme API to start remain on channel.
 
-        sme_RemainOnChannel(
+        if (eHAL_STATUS_SUCCESS != sme_RemainOnChannel(
                        WLAN_HDD_GET_HAL_CTX(pAdapter), sessionId,
                        pRemainChanCtx->chan.hw_value, duration,
                        wlan_hdd_remain_on_channel_callback, pAdapter,
                        (tANI_U8)(pRemainChanCtx->rem_on_chan_request
-                                  == REMAIN_ON_CHANNEL_REQUEST)? TRUE:FALSE);
+                                  == REMAIN_ON_CHANNEL_REQUEST)? TRUE:FALSE)) {
+            hddLog(LOGE, FL("sme_RemainOnChannel returned failure"));
+            mutex_lock(&cfgState->remain_on_chan_ctx_lock);
+            cfgState->remain_on_chan_ctx = NULL;
+            pAdapter->is_roc_inprogress = FALSE;
+            vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
+            vos_mem_free(pRemainChanCtx);
+            mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+            hdd_allow_suspend();
+            return -EINVAL;
+        }
 
         if (REMAIN_ON_CHANNEL_REQUEST == pRemainChanCtx->rem_on_chan_request) {
-            sme_RegisterMgmtFrame(WLAN_HDD_GET_HAL_CTX(pAdapter),
-                                   sessionId, (SIR_MAC_MGMT_FRAME << 2) |
-                                  (SIR_MAC_MGMT_PROBE_REQ << 4), NULL, 0 );
+            if (eHAL_STATUS_SUCCESS != sme_RegisterMgmtFrame(
+                                         WLAN_HDD_GET_HAL_CTX(pAdapter),
+                                         sessionId, (SIR_MAC_MGMT_FRAME << 2) |
+                                        (SIR_MAC_MGMT_PROBE_REQ << 4), NULL, 0))
+                hddLog(LOGE, FL("sme_RegisterMgmtFrame returned failure"));
         }
-
     }
     else if ( ( WLAN_HDD_SOFTAP== pAdapter->device_mode ) ||
               ( WLAN_HDD_P2P_GO == pAdapter->device_mode )
@@ -593,8 +681,9 @@
            mutex_lock(&cfgState->remain_on_chan_ctx_lock);
            cfgState->remain_on_chan_ctx = NULL;
            pAdapter->is_roc_inprogress = FALSE;
-           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+           vos_timer_destroy(&pRemainChanCtx->hdd_remain_on_chan_timer);
            vos_mem_free (pRemainChanCtx);
+           mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
            hdd_allow_suspend();
            return -EINVAL;
         }
@@ -625,6 +714,168 @@
     return 0;
 }
 
+/**
+ * wlan_hdd_roc_request_enqueue() - enqueue remain on channel request
+ * @adapter: Pointer to the adapter
+ * @remain_chan_ctx: Pointer to the remain on channel context
+ *
+ * Return: 0 on success, error number otherwise
+ */
+static int wlan_hdd_roc_request_enqueue(hdd_adapter_t *adapter,
+			hdd_remain_on_chan_ctx_t *remain_chan_ctx)
+{
+	hdd_context_t *hdd_ctx = WLAN_HDD_GET_CTX(adapter);
+	hdd_roc_req_t *hdd_roc_req;
+	VOS_STATUS status;
+
+	/*
+	 * "Driver is busy" OR "there is already RoC request inside the queue"
+	 * so enqueue this RoC Request and execute sequentially later.
+	 */
+
+	hdd_roc_req = vos_mem_malloc(sizeof(*hdd_roc_req));
+
+	if (NULL == hdd_roc_req) {
+		hddLog(LOGP, FL("malloc failed for roc req context"));
+		return -ENOMEM;
+	}
+
+	hdd_roc_req->pAdapter = adapter;
+	hdd_roc_req->pRemainChanCtx = remain_chan_ctx;
+
+	/* Enqueue this RoC request */
+	spin_lock(&hdd_ctx->hdd_roc_req_q.lock);
+	status = hdd_list_insert_back(&hdd_ctx->hdd_roc_req_q,
+					&hdd_roc_req->node);
+	spin_unlock(&hdd_ctx->hdd_roc_req_q.lock);
+
+	if (VOS_STATUS_SUCCESS != status) {
+		hddLog(LOGP, FL("Not able to enqueue RoC Req context"));
+		vos_mem_free(hdd_roc_req);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * wlan_hdd_indicate_roc_drop() - Indicate roc drop to userspace
+ * @adapter: HDD adapter
+ * @ctx: Remain on channel context
+ *
+ * Send remain on channel ready and cancel event for the queued
+ * roc that is being dropped. This will ensure that the userspace
+ * will send more roc requests. If this drop is not indicated to
+ * userspace, subsequent roc will not be sent to the driver since
+ * the userspace times out waiting for the remain on channel ready
+ * event.
+ *
+ * Return: None
+ */
+void wlan_hdd_indicate_roc_drop(hdd_adapter_t *adapter,
+		hdd_remain_on_chan_ctx_t *ctx)
+{
+	hddLog(LOG1, FL("indicate roc drop to userspace"));
+	cfg80211_ready_on_channel(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+			adapter->dev->ieee80211_ptr,
+#else
+			adapter->dev,
+#endif
+			(uintptr_t)ctx,
+			&ctx->chan,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
+			ctx->chan_type,
+#endif
+			ctx->duration, GFP_KERNEL);
+
+	cfg80211_remain_on_channel_expired(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+			ctx->dev->ieee80211_ptr,
+#else
+			ctx->dev,
+#endif
+			ctx->cookie,
+			&ctx->chan,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0))
+			ctx->chan_type,
+#endif
+			GFP_KERNEL);
+}
+
+/**
+ * wlan_hdd_roc_request_dequeue() - dequeue remain on channel request
+ * @work: Pointer to work queue struct
+ *
+ * Return: none
+ */
+void wlan_hdd_roc_request_dequeue(struct work_struct *work)
+{
+	VOS_STATUS status;
+	int ret = 0;
+	hdd_roc_req_t *hdd_roc_req;
+	hdd_context_t *hdd_ctx =
+			container_of(work, hdd_context_t, rocReqWork.work);
+
+        if (0 != (wlan_hdd_validate_context(hdd_ctx))) {
+                VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
+                                FL("hdd_ctx is NULL"));
+                return;
+        }
+
+	spin_lock(&hdd_ctx->hdd_roc_req_q.lock);
+	if (list_empty(&hdd_ctx->hdd_roc_req_q.anchor)) {
+		spin_unlock(&hdd_ctx->hdd_roc_req_q.lock);
+		return;
+	}
+	spin_unlock(&hdd_ctx->hdd_roc_req_q.lock);
+
+	/* If driver is busy then we can't run RoC */
+	if (hdd_ctx->isLoadInProgress || hdd_ctx->isUnloadInProgress ||
+	    hdd_isConnectionInProgress(hdd_ctx)) {
+		hddLog(LOGE,
+			FL("Wlan Load/Unload or Connection is in progress"));
+		return;
+	}
+
+	if (hdd_ctx->isLogpInProgress) {
+		hddLog(LOGE, FL("LOGP in Progress. Ignore!!!"));
+		return;
+	}
+
+	/*
+	 * The queued roc requests is dequeued and processed one at a time.
+	 * Callback 'wlan_hdd_remain_on_channel_callback' ensures
+	 * that any pending roc in the queue will be scheduled
+	 * on the current roc completion by scheduling the work queue.
+	 */
+
+	spin_lock(&hdd_ctx->hdd_roc_req_q.lock);
+	if (list_empty(&hdd_ctx->hdd_roc_req_q.anchor)) {
+		spin_unlock(&hdd_ctx->hdd_roc_req_q.lock);
+		hddLog(LOG1, FL("list is empty"));
+		return;
+ 	}
+	status = hdd_list_remove_front(&hdd_ctx->hdd_roc_req_q,
+			(hdd_list_node_t **) &hdd_roc_req);
+	spin_unlock(&hdd_ctx->hdd_roc_req_q.lock);
+	if (VOS_STATUS_SUCCESS != status) {
+		hddLog(LOG1, FL("unable to remove roc element from list"));
+		return;
+	}
+	ret = wlan_hdd_execute_remain_on_channel(
+			hdd_roc_req->pAdapter,
+			hdd_roc_req->pRemainChanCtx);
+	if (ret == -EBUSY) {
+		hddLog(VOS_TRACE_LEVEL_ERROR,
+				FL("dropping RoC request"));
+		wlan_hdd_indicate_roc_drop(hdd_roc_req->pAdapter,
+					hdd_roc_req->pRemainChanCtx);
+		vos_mem_free(hdd_roc_req->pRemainChanCtx);
+	}
+	vos_mem_free(hdd_roc_req);
+}
+
 static int wlan_hdd_request_remain_on_channel( struct wiphy *wiphy,
                                    struct net_device *dev,
                                    struct ieee80211_channel *chan,
@@ -639,8 +890,8 @@
     hdd_remain_on_chan_ctx_t *pRemainChanCtx;
     v_BOOL_t isBusy = VOS_FALSE;
     v_SIZE_t size = 0;
-    hdd_roc_req_t* phdd_roc_req;
-    VOS_STATUS status;
+    hdd_adapter_t *sta_adapter;
+    int status = 0;
 
     hddLog(VOS_TRACE_LEVEL_INFO, "%s: device_mode = %d",
                                  __func__, pAdapter->device_mode);
@@ -688,6 +939,7 @@
         return -ENOMEM;
     }
 
+    vos_mem_zero(pRemainChanCtx, sizeof(*pRemainChanCtx));
     vos_mem_copy(&pRemainChanCtx->chan, chan,
                    sizeof(struct ieee80211_channel));
 
@@ -706,100 +958,67 @@
     pRemainChanCtx->action_pkt_buff.frame_length = 0;
     pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress = FALSE;
 
-    /* Check roc_req_Q has pendding RoC Request or not */
+    if (REMAIN_ON_CHANNEL_REQUEST == request_type) {
+        sta_adapter = hdd_get_adapter(pHddCtx, WLAN_HDD_INFRA_STATION);
+        if ((NULL != sta_adapter)&&
+               hdd_connIsConnected(WLAN_HDD_GET_STATION_CTX_PTR(sta_adapter))) {
+            if (pAdapter->lastRocTs !=0 &&
+                    ((vos_timer_get_system_time() - pAdapter->lastRocTs )
+                     < pHddCtx->cfg_ini->p2p_listen_defer_interval)) {
+                if (pRemainChanCtx->duration > HDD_P2P_MAX_ROC_DURATION)
+                    pRemainChanCtx->duration = HDD_P2P_MAX_ROC_DURATION;
+
+                wlan_hdd_roc_request_enqueue(pAdapter, pRemainChanCtx);
+                schedule_delayed_work(&pHddCtx->rocReqWork,
+                msecs_to_jiffies(pHddCtx->cfg_ini->p2p_listen_defer_interval));
+                hddLog(LOG1, "Defer interval is %hu, pAdapter %p",
+                       pHddCtx->cfg_ini->p2p_listen_defer_interval, pAdapter);
+                return 0;
+            }
+        }
+    }
+
+    /* Check roc_req_Q has pending RoC Request or not */
     hdd_list_size(&(pHddCtx->hdd_roc_req_q), &size);
 
     if ((isBusy == VOS_FALSE) && (!size)) {
-
         /* Media is free and no RoC request is in queue, execute directly */
-        wlan_hdd_execute_remain_on_channel(pAdapter, pRemainChanCtx);
-
-        return 0;
-    } else {
-
-        /*
-         * "Driver is busy" OR "there is already RoC request inside the queue"
-         * so enqueue this RoC Request for execute RoC sequently in the future.
-         */
-
-        phdd_roc_req = vos_mem_malloc(sizeof(hdd_roc_req_t));
-
-        if (NULL == phdd_roc_req) {
-            hddLog(VOS_TRACE_LEVEL_FATAL,
-                 "%s: Not able to allocate memory for roc req context",
-                                             __func__);
-            return -ENOMEM;
+        status = wlan_hdd_execute_remain_on_channel(pAdapter,
+                                                    pRemainChanCtx);
+        if (status == -EBUSY) {
+            if (wlan_hdd_roc_request_enqueue(pAdapter, pRemainChanCtx)) {
+                vos_mem_free(pRemainChanCtx);
+                return -EAGAIN;
+            }
         }
-
-        phdd_roc_req->pAdapter = pAdapter;
-        phdd_roc_req->pRemainChanCtx = pRemainChanCtx;
-
-        /* Enqueue this RoC request */
-        spin_lock(&pHddCtx->hdd_roc_req_q.lock);
-        status = hdd_list_insert_back(&pHddCtx->hdd_roc_req_q,
-                              &phdd_roc_req->node);
-        spin_unlock(&pHddCtx->hdd_roc_req_q.lock);
-
-        if (VOS_STATUS_SUCCESS != status) {
-            hddLog(VOS_TRACE_LEVEL_FATAL,
-                 "%s: Not able to enqueue RoC Req context",
-                                             __func__);
-            vos_mem_free(phdd_roc_req);
-            return -ENOMEM;
+    } else {
+        if (wlan_hdd_roc_request_enqueue(pAdapter, pRemainChanCtx)) {
+            vos_mem_free(pRemainChanCtx);
+            return -EAGAIN;
         }
     }
 
     /*
-     * if driver is free and there is RoC request in the queue then
-     * schedule the RoC work directly.
+     * If a connection is not in progress (isBusy), before scheduling
+     * the work queue it is necessary to check if a roc in in progress
+     * or not because: if an roc is in progress, the dequeued roc
+     * that will be processed will be dropped. To ensure that this new
+     * roc request is not dropped, it is suggested to check if an roc
+     * is in progress or not. The existing roc completion will provide
+     * the trigger to dequeue the next roc request.
      */
-    if (isBusy == VOS_FALSE) {
-        schedule_work(&pHddCtx->rocReqWork);
+    if (isBusy == VOS_FALSE && pAdapter->is_roc_inprogress == false) {
+        hddLog(LOG1, FL("scheduling delayed work: no connection/roc active"));
+        schedule_delayed_work(&pHddCtx->rocReqWork, 0);
+    } else {
+    	/* when there are reuqest, we schedule one no mater how.
+    	   we drop the work during the execution if this is not needed */
+    	schedule_delayed_work(&pHddCtx->rocReqWork, msecs_to_jiffies(2000));
     }
 
     return 0;
 }
 
-void hdd_roc_req_work(struct work_struct *work)
-{
-    VOS_STATUS status;
-    hdd_roc_req_t *hdd_roc_req;
-    hdd_context_t *pHddCtx =
-             container_of(work, hdd_context_t, rocReqWork);
-
-    hddLog(LOG1, FL("RoC request timeout"));
-
-    if (list_empty(&pHddCtx->hdd_roc_req_q.anchor)) {
-       return;
-    }
-
-    /* If driver is busy then we can't run RoC */
-    if (pHddCtx->isLoadInProgress || pHddCtx->isUnloadInProgress ||
-        hdd_isConnectionInProgress(pHddCtx)) {
-        hddLog( LOGE,
-            "%s: Wlan Load/Unload  or Connection is in progress", __func__);
-        return;
-    }
-
-    if (pHddCtx->isLogpInProgress) {
-        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
-                "%s:LOGP in Progress. Ignore!!!", __func__);
-        return;
-    }
-
-    while (!list_empty(&pHddCtx->hdd_roc_req_q.anchor)) {
-        /* go to process this RoC request */
-        spin_lock(&pHddCtx->hdd_roc_req_q.lock);
-        status = hdd_list_remove_front(&pHddCtx->hdd_roc_req_q,
-                                           (hdd_list_node_t**) &hdd_roc_req);
-        spin_unlock(&pHddCtx->hdd_roc_req_q.lock);
-        if (status == VOS_STATUS_SUCCESS) {
-            wlan_hdd_execute_remain_on_channel(hdd_roc_req->pAdapter,
-                                     hdd_roc_req->pRemainChanCtx);
-            vos_mem_free(hdd_roc_req);
-        }
-    }
-}
 
 int __wlan_hdd_cfg80211_remain_on_channel( struct wiphy *wiphy,
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0))
@@ -856,6 +1075,9 @@
                                                channel_type,
 #endif
                                                duration, cookie);
+#ifdef TIMER_MANAGER
+   vos_timer_check_list();
+#endif
    vos_ssr_unprotect(__func__);
 
    return ret;
@@ -958,6 +1180,9 @@
         hddLog( LOGW, "%s: No Pending Remain on channel Request", __func__);
     }
     mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
+#ifdef TIMER_MANAGER
+   vos_timer_check_list();
+#endif
     return;
 }
 
@@ -979,6 +1204,7 @@
     int status;
     hdd_list_node_t *tmp, *q;
     hdd_roc_req_t *curr_roc_req;
+    unsigned long rc;
 
     hddLog( LOG1, "Cancel remain on channel");
 
@@ -1032,14 +1258,13 @@
             hddLog( LOG1,
                     FL("ROC timer cancellation in progress,"
                        " wait for completion"));
-            status = wait_for_completion_interruptible_timeout(
+            rc = wait_for_completion_timeout(
                                              &pAdapter->cancel_rem_on_chan_var,
                                              msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
-            if (0 >= status)
-            {
+            if (!rc) {
                 hddLog( LOGE,
-                        "%s:wait on cancel_rem_on_chan_var failed %d",
-                        __func__, status);
+                        "%s:wait on cancel_rem_on_chan_var timed out",
+                        __func__);
             }
             return 0;
         }
@@ -1050,10 +1275,9 @@
 
     /* wait until remain on channel ready event received
      * for already issued remain on channel request */
-    status = wait_for_completion_interruptible_timeout(&pAdapter->rem_on_chan_ready_event,
+    rc = wait_for_completion_timeout(&pAdapter->rem_on_chan_ready_event,
             msecs_to_jiffies(WAIT_REM_CHAN_READY));
-    if (0 >= status)
-    {
+    if (!rc) {
         hddLog( LOGE,
                 "%s: timeout waiting for remain on channel ready indication",
                 __func__);
@@ -1098,12 +1322,11 @@
                             __func__, pAdapter->device_mode);
        return -EIO;
     }
-    status = wait_for_completion_interruptible_timeout(&pAdapter->cancel_rem_on_chan_var,
+    rc = wait_for_completion_timeout(&pAdapter->cancel_rem_on_chan_var,
             msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
-    if (0 >= status)
-    {
+    if (!rc) {
         hddLog( LOGE,
-                "%s:wait on cancel_rem_on_chan_var failed %d", __func__, status);
+                "%s:wait on cancel_rem_on_chan_var timed out ", __func__);
     }
     hdd_allow_suspend();
     return 0;
@@ -1127,6 +1350,9 @@
                                                     dev,
 #endif
                                                     cookie);
+#ifdef TIMER_MANAGER
+   vos_timer_check_list();
+#endif
     vos_ssr_unprotect(__func__);
 
     return ret;
@@ -1171,6 +1397,7 @@
     tActionFrmType actionFrmType;
     bool noack = 0;
     int status;
+    unsigned long rc;
     hdd_adapter_t *goAdapter;
 
      MTRACE(vos_trace(VOS_MODULE_ID_HDD,
@@ -1197,14 +1424,17 @@
         if(actionFrmType >= MAX_P2P_ACTION_FRAME_TYPE)
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] unknown[%d] ---> OTA to "
-                   MAC_ADDRESS_STR, actionFrmType,
-                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]));
+                   MAC_ADDRESS_STR "at channel %d", actionFrmType,
+                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]),
+                   ieee80211_frequency_to_channel(chan->center_freq));
         }
         else
         {
             hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] %s ---> OTA to "
-                   MAC_ADDRESS_STR, p2p_action_frame_type[actionFrmType],
-                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]));
+                   MAC_ADDRESS_STR "at channel %d", p2p_action_frame_type[actionFrmType],
+                   MAC_ADDR_ARRAY(&buf[WLAN_HDD_80211_FRM_DA_OFFSET]),
+                   ieee80211_frequency_to_channel(chan->center_freq));
+
             if( (actionFrmType == WLAN_HDD_PROV_DIS_REQ) &&
                 (globalP2PConnectionStatus == P2P_NOT_ACTIVE) )
             {
@@ -1332,20 +1562,21 @@
                    goto send_frame;
                } else {
 
-                  if(pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress == TRUE)
+                  if( (pRemainChanCtx != NULL) &&
+                      (pRemainChanCtx->hdd_remain_on_chan_cancel_in_progress ==
+                           TRUE))
                   {
                       mutex_unlock(&cfgState->remain_on_chan_ctx_lock);
                       hddLog(VOS_TRACE_LEVEL_INFO,
                           "action frame tx: waiting for completion of ROC ");
 
-                      status = wait_for_completion_interruptible_timeout(
+                      rc = wait_for_completion_timeout(
                           &pAdapter->cancel_rem_on_chan_var,
                           msecs_to_jiffies(WAIT_CANCEL_REM_CHAN));
-                      if (0 >= status)
-                      {
+                      if (!rc) {
                           hddLog( LOGE,
-                              "%s:wait on cancel_rem_on_chan_var failed %d",
-                              __func__, status);
+                              "%s:wait on cancel_rem_on_chan_var timed out",
+                              __func__);
                       }
 
                   } else
@@ -1387,15 +1618,15 @@
          */
         extendedWait = (tANI_U16)wait;
         /* Wait for driver to be ready on the requested channel */
-        status = wait_for_completion_interruptible_timeout(
+        rc = wait_for_completion_timeout(
                      &pAdapter->offchannel_tx_event,
                      msecs_to_jiffies(WAIT_CHANGE_CHANNEL_FOR_OFFCHANNEL_TX));
-        if(0 >= status)
-        {
-           hddLog( LOGE, "wait on offchannel_tx_event failed %d", status);
+        if(!rc) {
+           hddLog( LOGE, "wait on offchannel_tx_event timed out");
            goto err_rem_channel;
         }
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     else if ( offchan )
     {
         /* Check before sending action frame
@@ -1405,6 +1636,7 @@
             goto err_rem_channel;
         }
     }
+#endif
     send_frame:
 
     if(!noack)
@@ -1598,6 +1830,17 @@
 }
 #endif
 
+/**
+ * hdd_p2p_roc_work_queue() - roc delayed work queue handler
+ * @work: Pointer to work queue struct
+ *
+ * Return: none
+ */
+void hdd_p2p_roc_work_queue(struct work_struct *work)
+{
+	wlan_hdd_roc_request_dequeue(work);
+}
+
 void hdd_sendActionCnf( hdd_adapter_t *pAdapter, tANI_BOOLEAN actionSendSuccess )
 {
     hdd_cfg80211_state_t *cfgState = WLAN_HDD_GET_CFG_STATE_PTR( pAdapter );
@@ -2169,6 +2412,7 @@
      return ;
 }
 
+
 void hdd_indicateMgmtFrame( hdd_adapter_t *pAdapter,
                             tANI_U32 nFrameLength,
                             tANI_U8* pbFrames,
@@ -2292,15 +2536,15 @@
                 if(actionFrmType >= MAX_P2P_ACTION_FRAME_TYPE)
                 {
                     hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] unknown[%d] <--- OTA"
-                           " from " MAC_ADDRESS_STR, actionFrmType,
-                           MAC_ADDR_ARRAY(macFrom));
+                           " from " MAC_ADDRESS_STR " at channel %d", actionFrmType,
+                           MAC_ADDR_ARRAY(macFrom), rxChan);
                 }
                 else
                 {
                     hddLog(VOS_TRACE_LEVEL_ERROR,"[P2P] %s <--- OTA"
-                           " from " MAC_ADDRESS_STR,
+                           " from " MAC_ADDRESS_STR "at channel %d",
                            p2p_action_frame_type[actionFrmType],
-                           MAC_ADDR_ARRAY(macFrom));
+                           MAC_ADDR_ARRAY(macFrom), rxChan);
                     if( (actionFrmType == WLAN_HDD_PROV_DIS_REQ) &&
                         (globalP2PConnectionStatus == P2P_NOT_ACTIVE) )
                     {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_scan.c qcacld-new/CORE/HDD/src/wlan_hdd_scan.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_scan.c	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_scan.c	2016-05-16 10:58:08.702298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -714,8 +715,7 @@
    }
 
    /* push addIEScan in scanRequset if exist */
-   if (pAdapter->scan_info.scanAddIE.addIEdata &&
-       pAdapter->scan_info.scanAddIE.length)
+   if (pAdapter->scan_info.scanAddIE.length)
    {
        scanRequest.uIEFieldLen = pAdapter->scan_info.scanAddIE.length;
        scanRequest.pIEField = pAdapter->scan_info.scanAddIE.addIEdata;
@@ -773,6 +773,11 @@
        __func__, (wrqu->data.length)?wrqu->data.length:IW_SCAN_MAX_DATA);
    ENTER();
 
+	if (NULL == extra) {
+		VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL,"%s: NULL extra", __func__);
+		return -EINVAL;
+	}
+
    if (TRUE == pAdapter->scan_info.mScanPending)
    {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_FATAL, "%s:mScanPending is TRUE !!!",__func__);
@@ -1092,8 +1097,7 @@
         }
 
         /* push addIEScan in scanRequset if exist */
-        if (pAdapter->scan_info.scanAddIE.addIEdata &&
-            pAdapter->scan_info.scanAddIE.length)
+        if (pAdapter->scan_info.scanAddIE.length)
         {
             scanRequest.uIEFieldLen = pAdapter->scan_info.scanAddIE.length;
             scanRequest.pIEField = pAdapter->scan_info.scanAddIE.addIEdata;
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2016-05-16 10:58:06.450298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_softap_tx_rx.c	2016-05-16 10:58:08.718298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**===========================================================================
 
@@ -546,6 +547,7 @@
 }
 #endif /* QCA_LL_TX_FLOW_CT */
 
+
 /**============================================================================
   @brief hdd_softap_hard_start_xmit() - Function registered with the Linux OS
                                         for transmitting packets.
@@ -605,7 +607,7 @@
    }
    else
    {
-      STAId = *(v_U8_t *)(((v_U8_t *)(skb->data)) - 1);
+  	  STAId = *(v_U8_t *)(((v_U8_t *)(skb->data)) - 1);
       if (STAId == HDD_WLAN_INVALID_STA_ID)
       {
          VOS_TRACE( VOS_MODULE_ID_HDD_SAP_DATA, VOS_TRACE_LEVEL_WARN,
@@ -1311,7 +1313,7 @@
    *ppVosPacket = NULL;
 
    //Make sure the AC being asked for is sane
-   if( ac > WLANTL_MAX_AC || ac < 0)
+   if( ac >= WLANTL_MAX_AC || ac < 0)
    {
       VOS_TRACE( VOS_MODULE_ID_HDD_SAP_DATA, VOS_TRACE_LEVEL_ERROR,
                  "%s: Invalid AC %d passed by TL", __func__, ac);
@@ -1824,6 +1826,8 @@
    vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
                                  HDD_WAKE_LOCK_DURATION);
 #endif
+
+
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_tdls.c qcacld-new/CORE/HDD/src/wlan_hdd_tdls.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_tdls.c	2016-05-16 10:58:06.434298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_tdls.c	2016-05-16 10:58:08.702298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -628,12 +629,14 @@
     tdls_scan_context_t *scan_ctx =
           container_of(work, tdls_scan_context_t, tdls_scan_work.work);
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (NULL == scan_ctx)
     {
         VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                   FL("scan_ctx is NULL"));
         return;
     }
+#endif
 
     if (unlikely(TDLS_CTX_MAGIC != scan_ctx->magic))
         return;
@@ -1531,8 +1534,12 @@
             CFG_TDLS_TX_STATS_PERIOD_MIN, CFG_TDLS_TX_STATS_PERIOD_MAX);
         return -1;
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (config->tx_packet_n < CFG_TDLS_TX_PACKET_THRESHOLD_MIN ||
         config->tx_packet_n > CFG_TDLS_TX_PACKET_THRESHOLD_MAX)
+#else
+    if (config->tx_packet_n > CFG_TDLS_TX_PACKET_THRESHOLD_MAX)
+#endif
     {
         hddLog(VOS_TRACE_LEVEL_ERROR, "%s invalid 3rd argument %d. <%d...%ld>",               __func__,
                config->tx_packet_n,
@@ -1559,8 +1566,12 @@
                CFG_TDLS_MAX_DISCOVERY_ATTEMPT_MAX);
         return -1;
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE        
     if (config->idle_timeout_t < CFG_TDLS_IDLE_TIMEOUT_MIN ||
         config->idle_timeout_t > CFG_TDLS_IDLE_TIMEOUT_MAX)
+#else
+    if (config->idle_timeout_t > CFG_TDLS_IDLE_TIMEOUT_MAX)
+#endif      
     {
         hddLog(VOS_TRACE_LEVEL_ERROR, "%s invalid 6th argument %d. <%d...%d>",                __func__,
                config->idle_timeout_t,
@@ -1568,15 +1579,23 @@
                CFG_TDLS_IDLE_TIMEOUT_MAX);
         return -1;
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (config->idle_packet_n < CFG_TDLS_IDLE_PACKET_THRESHOLD_MIN ||
         config->idle_packet_n > CFG_TDLS_IDLE_PACKET_THRESHOLD_MAX)
+#else
+if (config->idle_packet_n > CFG_TDLS_IDLE_PACKET_THRESHOLD_MAX)
+#endif
     {
         hddLog(VOS_TRACE_LEVEL_ERROR, "%s invalid 7th argument %d. <%d...%d>", __func__, config->idle_packet_n,
             CFG_TDLS_IDLE_PACKET_THRESHOLD_MIN, CFG_TDLS_IDLE_PACKET_THRESHOLD_MAX);
         return -1;
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (config->rssi_hysteresis < CFG_TDLS_RSSI_HYSTERESIS_MIN ||
         config->rssi_hysteresis > CFG_TDLS_RSSI_HYSTERESIS_MAX)
+#else
+if (config->rssi_hysteresis > CFG_TDLS_RSSI_HYSTERESIS_MAX)
+#endif
     {
         hddLog(VOS_TRACE_LEVEL_ERROR, "%s invalid 8th argument %d. <%d...%d>", __func__, config->rssi_hysteresis,
             CFG_TDLS_RSSI_HYSTERESIS_MIN, CFG_TDLS_RSSI_HYSTERESIS_MAX);
@@ -2072,6 +2091,7 @@
 
     mutex_lock(&pHddCtx->tdls_lock);
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (NULL == pHddTdlsCtx)
     {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
@@ -2079,6 +2099,7 @@
         mutex_unlock(&pHddCtx->tdls_lock);
         return;
     }
+#endif
     pHddTdlsCtx->discovery_sent_cnt = 0;
     wlan_hdd_tdls_check_power_save_prohibited(pHddTdlsCtx->pAdapter);
 
@@ -2401,12 +2422,14 @@
     hddTdlsPeer_t *temp_peer;
     int status;
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if (NULL == pHddTdlsCtx)
     {
        VOS_TRACE(VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_ERROR,
                  FL("pHddTdlsCtx is NULL"));
        return;
     }
+#endif
 
     if (unlikely(TDLS_CTX_MAGIC != pHddTdlsCtx->magic))
     {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_tx_rx.c	2016-05-16 10:58:06.450298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_tx_rx.c	2016-05-16 10:58:08.718298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**===========================================================================
 
@@ -1415,16 +1416,21 @@
 
    //Get the HDD context.
    pHddCtx = (hdd_context_t *)vos_get_context( VOS_MODULE_ID_HDD, vosContext );
-   //Get the Adapter context.
-   pAdapter = hdd_get_adapter(pHddCtx,WLAN_HDD_INFRA_STATION);
-   if(pAdapter == NULL)
-   {
-      VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
-                "%s: HDD adapter context is Null", __func__);
-   }
-   else
-   {
-      ++pAdapter->hdd_stats.hddTxRxStats.txCompleted;
+   if(pHddCtx) {
+     //Get the Adapter context.
+     pAdapter = hdd_get_adapter(pHddCtx,WLAN_HDD_INFRA_STATION);
+     if(pAdapter == NULL)
+     {
+        VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                  "%s: HDD adapter context is Null", __func__);
+     }
+     else
+     {
+        ++pAdapter->hdd_stats.hddTxRxStats.txCompleted;
+     }
+   } else {
+     VOS_TRACE( VOS_MODULE_ID_HDD, VOS_TRACE_LEVEL_INFO,
+                  "%s: HDD context is Null", __func__);
    }
 
    kfree_skb((struct sk_buff *)pOsPkt);
@@ -2200,6 +2206,14 @@
        return eHAL_STATUS_FAILURE;
    }
 
+   if (unlikely(skb->len < (sizeof(struct ethhdr) + skb->data_len))) {
+         ++pAdapter->hdd_stats.hddTxRxStats.rxDropped;
+         VOS_TRACE(VOS_MODULE_ID_HDD_DATA, VOS_TRACE_LEVEL_INFO,
+            "%s: Dropping invalid size packet", __func__);
+        kfree_skb(skb);
+        return VOS_STATUS_SUCCESS;
+   }
+
    pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
    if ((pHddStaCtx->conn_info.proxyARPService) &&
          cfg80211_is_gratuitous_arp_unsolicited_na(skb))
@@ -2269,6 +2283,8 @@
    vos_wake_lock_timeout_acquire(&pHddCtx->rx_wake_lock,
                                  HDD_WAKE_LOCK_DURATION);
 #endif
+
+
    rxstat = netif_rx_ni(skb);
    if (NET_RX_SUCCESS == rxstat)
    {
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c qcacld-new/CORE/HDD/src/wlan_hdd_wext.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_wext.c	2016-05-16 10:58:06.458298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_wext.c	2016-05-16 10:58:08.738298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2011-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -49,6 +49,7 @@
 #include <linux/wireless.h>
 #include <macTrace.h>
 #include <wlan_hdd_includes.h>
+#include "wlan_hdd_main.h"
 #include <wlan_btc_svc.h>
 #include <wlan_nlink_common.h>
 #ifdef WLAN_BTAMP_FEATURE
@@ -245,6 +246,9 @@
 /* Private ioctl for packet power save */
 #define WE_PPS_5G_EBT                         83
 #define WE_SET_FW_CRASH_INJECT                84
+#define WE_SET_DIRECT_AUDIO_TEST              85
+#define WE_USB_CONTX_DEBUG			87
+
 
 /* Private ioctls and their sub-ioctls */
 #define WLAN_PRIV_SET_NONE_GET_INT    (SIOCIWFIRSTPRIV + 1)
@@ -304,6 +308,8 @@
 #define WE_GET_GTX_MINTPC               53
 #define WE_GET_GTX_BWMASK               54
 #define WE_GET_SCAN_BAND_PREFERENCE     55
+/* continue usb */
+#define WE_GET_USB_CONTX_DEBUG			56
 #endif
 
 /* Private ioctls and their sub-ioctls */
@@ -743,7 +749,7 @@
     if (wrqu) {
         wrqu->data.length = scnprintf(extra, WE_MAX_STR_LEN,
                                      "Host SW:%s, FW:%d.%d.%d.%d, HW:%s",
-                                     QWLAN_VERSIONSTR,
+                                     hdd_get_version_string(),
                                      MSPId,
                                      mSPId,
                                      SIId,
@@ -751,7 +757,7 @@
                                      pHWversion);
     } else {
         pr_info("Host SW:%s, FW:%d.%d.%d.%d, HW:%s\n",
-                QWLAN_VERSIONSTR,
+                hdd_get_version_string(),
                 MSPId,
                 mSPId,
                 SIId,
@@ -1024,7 +1030,7 @@
    hdd_context_t *pHddCtx;
    hdd_station_ctx_t *pHddStaCtx;
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
 
    if (NULL == pAdapter)
    {
@@ -1060,12 +1066,11 @@
    else
    {
        /* request was sent -- wait for the response */
-       lrc = wait_for_completion_interruptible_timeout(&context.completion,
+       rc = wait_for_completion_timeout(&context.completion,
                                     msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-       if (lrc <= 0)
-       {
-          hddLog(VOS_TRACE_LEVEL_ERROR, "%s: SME %s while retrieving RSSI",
-                 __func__, (0 == lrc) ? "timeout" : "interrupt");
+       if (!rc) {
+          hddLog(VOS_TRACE_LEVEL_ERROR,
+              FL("SME timed out while retrieving RSSI"));
           /* we'll now returned a cached value below */
        }
    }
@@ -1096,7 +1101,7 @@
    hdd_context_t *pHddCtx;
    hdd_station_ctx_t *pHddStaCtx;
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
    int valid;
 
    if (NULL == pAdapter)
@@ -1139,12 +1144,11 @@
    else
    {
        /* request was sent -- wait for the response */
-       lrc = wait_for_completion_interruptible_timeout(&context.completion,
+       rc = wait_for_completion_timeout(&context.completion,
                                     msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-       if (lrc <= 0)
-       {
-          hddLog(VOS_TRACE_LEVEL_ERROR, "%s: SME %s while retrieving SNR",
-                 __func__, (0 == lrc) ? "timeout" : "interrupt");
+       if (!rc) {
+          hddLog(VOS_TRACE_LEVEL_ERROR,
+              FL("SME timed out while retrieving SNR"));
           /* we'll now returned a cached value below */
        }
    }
@@ -1235,7 +1239,7 @@
    hdd_context_t *pHddCtx = NULL;
    hdd_station_ctx_t *pHddStaCtx = NULL;
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
 
    if (NULL == pAdapter)
    {
@@ -1278,12 +1282,11 @@
    else
    {
        /* request was sent -- wait for the response */
-       lrc = wait_for_completion_interruptible_timeout(&context.completion,
+       rc = wait_for_completion_timeout(&context.completion,
                                     msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-       if (lrc <= 0)
-       {
-          hddLog(VOS_TRACE_LEVEL_ERROR,"%s: SME %s while retrieving RSSI",
-                 __func__, (0 == lrc) ? "timeout" : "interrupt");
+       if (!rc) {
+          hddLog(VOS_TRACE_LEVEL_ERROR,
+              FL("SME timed out while retrieving RSSI"));
           /* we'll now returned a cached value below */
        }
    }
@@ -1366,7 +1369,7 @@
 {
    v_CONTEXT_t pVosContext;
    hdd_context_t *pHddCtx;
-   VOS_STATUS hdd_reconnect_all_adapters( hdd_context_t *pHddCtx );
+
 #if 0
    hdd_wext_state_t *pWextState;
    v_U32_t roamId;
@@ -1453,7 +1456,9 @@
 
    for (i=0; i < CSR_MAX_NUM_KEY; i++)
    {
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT   
       if (pWextState->roamProfile.Keys.KeyMaterial[i])
+#endif
       {
          pWextState->roamProfile.Keys.KeyLength[i] = 0;
       }
@@ -1647,13 +1652,13 @@
                                           eCSR_DISCONNECT_REASON_IBSS_LEAVE );
             if(VOS_STATUS_SUCCESS == vosStatus)
             {
-                 long ret;
-                 ret = wait_for_completion_interruptible_timeout(
+                 unsigned long rc;
+                 rc = wait_for_completion_timeout(
                                   &pAdapter->disconnect_comp_var,
                                     msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-                 if (ret <= 0)
+                 if (!rc)
                      hddLog(VOS_TRACE_LEVEL_ERROR,
-                            FL("failed wait on disconnect_comp_var %ld"), ret);
+                            FL("failed wait on disconnect_comp_var"));
             }
 }
     }
@@ -2112,7 +2117,8 @@
         switch ( elementId )
          {
             case IE_EID_VENDOR:
-                if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen) /* should have at least OUI */
+                if ((IE_LEN_SIZE+IE_EID_SIZE+IE_VENDOR_OUI_SIZE) > eLen ||
+					eLen > MAX_WPA_RSN_IE_LEN-2) /* should have at least OUI */
                 {
                     kfree(base_genie);
                     return -EINVAL;
@@ -2250,7 +2256,9 @@
     tCsrRoamProfile *pRoamProfile = &(pWextState->roamProfile);
     int keyId;
     eCsrAuthType authType = eCSR_AUTH_TYPE_NONE;
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     int i;
+#endif
 
     ENTER();
 
@@ -2281,6 +2289,7 @@
         dwrq->flags |= IW_ENCODE_DISABLED;
     }
 
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     for(i=0; i < MAX_WEP_KEYS; i++)
     {
         if(pRoamProfile->Keys.KeyMaterial[i] == NULL)
@@ -2297,6 +2306,7 @@
     {
         dwrq->flags |= IW_ENCODE_NOKEY;
     }
+#endif
 
     authType = ((hdd_station_ctx_t*)WLAN_HDD_GET_STATION_CTX_PTR(pAdapter))->conn_info.authType;
 
@@ -2754,7 +2764,7 @@
 {
    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
    struct statsContext context;
 
    if (NULL == pAdapter)
@@ -2793,13 +2803,11 @@
    else
    {
        /* request was sent -- wait for the response */
-       lrc = wait_for_completion_interruptible_timeout(&context.completion,
-                                    msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
-       if (lrc <= 0)
-       {
+       rc = wait_for_completion_timeout(&context.completion,
+                                msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
+       if (!rc) {
           hddLog(VOS_TRACE_LEVEL_ERROR,
-                 "%s: SME %s while retrieving Class A statistics",
-                 __func__, (0 == lrc) ? "timeout" : "interrupt");
+              FL("SME timed out while retrieving Class A statistics"));
       }
    }
 
@@ -2888,7 +2896,7 @@
 {
    hdd_station_ctx_t *pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR(pAdapter);
    eHalStatus hstatus;
-   long lrc;
+   unsigned long rc;
    struct statsContext context;
 
    if (NULL == pAdapter)
@@ -2924,14 +2932,12 @@
    else
    {
       /* request was sent -- wait for the response */
-      lrc = wait_for_completion_interruptible_timeout(&context.completion,
-                                    msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
+      rc = wait_for_completion_timeout(&context.completion,
+                           msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
 
-      if (lrc <= 0)
-      {
-         hddLog(VOS_TRACE_LEVEL_ERROR,
-                "%s: SME %s while retrieving statistics",
-                __func__, (0 == lrc) ? "timeout" : "interrupt");
+      if (!rc) {
+          hddLog(VOS_TRACE_LEVEL_ERROR,
+              FL("SME timed out while retrieving statistics"));
       }
    }
 
@@ -3160,15 +3166,15 @@
        sme_SetDHCPTillPowerActiveFlag(pHddCtx->hHal, TRUE);
        if (eHAL_STATUS_PMC_PENDING == status)
        {
+           unsigned long rc;
            /* request was sent -- wait for the response */
-           int lrc = wait_for_completion_interruptible_timeout(
+           rc = wait_for_completion_timeout(
                    &context.completion,
                    msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
 
-           if (lrc <= 0)
-           {
-               hddLog(VOS_TRACE_LEVEL_ERROR,"%s: SME %s while requesting fullpower ",
-                  __func__, (0 == lrc) ? "timeout" : "interrupt");
+           if (!rc) {
+               hddLog(VOS_TRACE_LEVEL_ERROR,
+                  FL("SME timed out while requesting full power"));
            }
        }
    }
@@ -3186,15 +3192,14 @@
                            iw_power_callback_fn, &context);
            if (eHAL_STATUS_PMC_PENDING == status)
            {
+               unsigned long rc;
                /* request was sent -- wait for the response */
-               int lrc = wait_for_completion_interruptible_timeout(
+               rc = wait_for_completion_timeout(
                            &context.completion,
                            msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
-               if (lrc <= 0)
-               {
+               if (!rc) {
                    hddLog(VOS_TRACE_LEVEL_ERROR,
-                          "%s: SME %s while requesting BMPS",
-                          __func__, (0 == lrc) ? "timeout" : "interrupt");
+                       FL("SME timed out while requesting BMPS"));
                }
            }
        }
@@ -3468,7 +3473,7 @@
     }
     else if( strncasecmp(cmd, "COUNTRY", 7) == 0 ) {
         char *country_code;
-        long lrc;
+        unsigned long rc;
         eHalStatus eHal_status;
 
         country_code =  cmd + 8;
@@ -3484,13 +3489,12 @@
                                             eSIR_TRUE);
 
         /* Wait for completion */
-        lrc = wait_for_completion_interruptible_timeout(&pAdapter->change_country_code,
-                                    msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
+        rc = wait_for_completion_timeout(&pAdapter->change_country_code,
+                                  msecs_to_jiffies(WLAN_WAIT_TIME_STATS));
 
-        if (lrc <= 0)
-        {
-            hddLog(VOS_TRACE_LEVEL_ERROR,"%s: SME %s while setting country code ",
-                   __func__, "Timed out");
+        if (!rc) {
+            hddLog(VOS_TRACE_LEVEL_ERROR,
+               FL("SME timedout while setting country code"));
         }
 
         if (eHAL_STATUS_SUCCESS != eHal_status)
@@ -3774,8 +3778,9 @@
        if(!fKeyPresent) {
 
           for(i=0;i < CSR_MAX_NUM_KEY; i++) {
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
              if(pWextState->roamProfile.Keys.KeyMaterial[i])
+#endif
                 pWextState->roamProfile.Keys.KeyLength[i] = 0;
           }
        }
@@ -3793,13 +3798,13 @@
            status = sme_RoamDisconnect( WLAN_HDD_GET_HAL_CTX(pAdapter), pAdapter->sessionId, eCSR_DISCONNECT_REASON_UNSPECIFIED );
            if(eHAL_STATUS_SUCCESS == status)
            {
-                 long ret;
-                 ret = wait_for_completion_interruptible_timeout(
-                                         &pAdapter->disconnect_comp_var,
-                                          msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-                if (ret <= 0)
+                 unsigned long rc;
+                 rc = wait_for_completion_timeout(
+                              &pAdapter->disconnect_comp_var,
+                               msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
+                if (!rc)
                      hddLog(VOS_TRACE_LEVEL_ERROR,
-                            FL("failed wait on disconnect_comp_var %ld"), ret);
+                            FL("failed wait on disconnect_comp_var"));
            }
        }
 
@@ -3892,8 +3897,9 @@
     int keyId;
     eCsrEncryptionType encryptionType = eCSR_ENCRYPT_TYPE_NONE;
     eCsrAuthType authType = eCSR_AUTH_TYPE_NONE;
-    int i;
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
+    int i = 0;
+#endif
     ENTER();
 
     if ((WLAN_HDD_GET_CTX(pAdapter))->isLogpInProgress)
@@ -3922,7 +3928,7 @@
     {
         dwrq->flags |= IW_ENCODE_DISABLED;
     }
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     for(i=0; i < MAX_WEP_KEYS; i++)
     {
         if(pRoamProfile->Keys.KeyMaterial[i] == NULL)
@@ -3940,6 +3946,7 @@
         dwrq->flags |= IW_ENCODE_NOKEY;
     }
     else
+#endif        
     {
         dwrq->flags |= IW_ENCODE_ENABLED;
     }
@@ -4022,8 +4029,14 @@
        }
        else {
          /*Static wep, update the roam profile with the keys */
+#ifdef CONFIG_VD_PREVENT_NO_EFFECT
+          if((ext->key_len <= eCSR_SECURITY_WEP_KEYSIZE_MAX_BYTES) &&
+                                                               key_index < CSR_MAX_NUM_KEY) 
+#else                                                               
           if(ext->key && (ext->key_len <= eCSR_SECURITY_WEP_KEYSIZE_MAX_BYTES) &&
-                                                               key_index < CSR_MAX_NUM_KEY) {
+                                                               key_index < CSR_MAX_NUM_KEY) 
+#endif
+		  {
              vos_mem_copy(&pRoamProfile->Keys.KeyMaterial[key_index][0],ext->key,ext->key_len);
              pRoamProfile->Keys.KeyLength[key_index] = (v_U8_t)ext->key_len;
 
@@ -4313,13 +4326,13 @@
 
                 if(eHAL_STATUS_SUCCESS == status)
                 {
-                    long ret;
-                    ret = wait_for_completion_interruptible_timeout(
-                                      &pAdapter->disconnect_comp_var,
-                                       msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
-                    if (ret <= 0)
+                    unsigned long rc;
+                    rc = wait_for_completion_timeout(
+                                   &pAdapter->disconnect_comp_var,
+                                   msecs_to_jiffies(WLAN_WAIT_TIME_DISCONNECT));
+                    if (!rc)
                         hddLog(VOS_TRACE_LEVEL_ERROR,
-                            FL("failed wait on disconnect_comp_var %ld"), ret);
+                            FL("failed wait on disconnect_comp_var"));
                 }
                 else
                     hddLog(LOGE,"%s %d Command Disassociate/Deauthenticate : csrRoamDisconnect failure returned %d",
@@ -4571,6 +4584,8 @@
 #endif
 
 /* set param sub-ioctls */
+
+
 static int iw_setint_getnone(struct net_device *dev, struct iw_request_info *info,
                        union iwreq_data *wrqu, char *extra)
 {
@@ -4598,13 +4613,12 @@
         return -EBUSY;
     }
 
+    memset(&smeConfig, 0x00, sizeof(smeConfig));
     switch(sub_cmd)
     {
         case WE_SET_11D_STATE:
         {
             if((ENABLE_11D == set_value) || (DISABLE_11D == set_value)) {
-
-                memset(&smeConfig, 0x00, sizeof(smeConfig));
                 sme_GetConfigParam(hHal, &smeConfig);
                 smeConfig.csrConfig.Is11dSupportEnabled = (v_BOOL_t)set_value;
 
@@ -4663,16 +4677,14 @@
                               eSME_FULL_PWR_NEEDED_BY_HDD);
                  if (eHAL_STATUS_PMC_PENDING == status)
                  {
-                    int lrc = wait_for_completion_interruptible_timeout(
-                                  &context.completion,
-                                  msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
+                    unsigned long rc;
+                    rc = wait_for_completion_timeout(
+                                &context.completion,
+                                 msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
 
-                    if (lrc <= 0)
-                    {
+                    if (!rc) {
                        hddLog(VOS_TRACE_LEVEL_ERROR,
-                              "%s: SME %s while requesting fullpower",
-                              __func__, (0 == lrc) ?
-                              "timeout" : "interrupt");
+                           FL("SME timed out while requesting full power"));
                     }
                  }
                  /* either we have a response or we timed out.  if we timed
@@ -4711,15 +4723,13 @@
                            iw_power_callback_fn, &context);
                  if (eHAL_STATUS_PMC_PENDING == status)
                  {
-                    int lrc = wait_for_completion_interruptible_timeout(
-                                  &context.completion,
-                                  msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
-                    if (lrc <= 0)
-                    {
+                    unsigned long rc;
+                    rc = wait_for_completion_timeout(
+                              &context.completion,
+                              msecs_to_jiffies(WLAN_WAIT_TIME_POWER));
+                    if (!rc) {
                        hddLog(VOS_TRACE_LEVEL_ERROR,
-                              "%s: SME %s while requesting BMPS",
-                              __func__, (0 == lrc) ? "timeout" :
-                              "interrupt");
+                           FL("SME timed out while requesting BMPS"));
                     }
                  }
                  /* either we have a response or we timed out.  if we
@@ -5236,7 +5246,6 @@
                        phddctx->cfg_ini->nChannelBondingMode5GHz)))
                chwidth = true;
 
-           memset(&smeConfig, 0x00, sizeof(smeConfig));
            sme_GetConfigParam(hHal, &smeConfig);
            switch (set_value) {
            case eHT_CHANNEL_WIDTH_20MHZ:
@@ -5997,6 +6006,8 @@
         }
 #endif
 #endif
+
+
         default:
         {
            hddLog(LOGE, "%s: Invalid sub command %d", __func__, sub_cmd);
@@ -6931,13 +6942,7 @@
                     len += buf;
                     break;
                 }
-                pMac = PMAC_STRUCT( hHal );
-                if (!pMac) {
-                    buf = scnprintf(extra + len,  WE_MAX_STR_LEN - len,
-                            "\n pMac is NULL");
-                    len += buf;
-                    break;
-                }
+
                 pHddStaCtx = WLAN_HDD_GET_STATION_CTX_PTR( useAdapter );
                 if( !pHddStaCtx )
                 {
@@ -6948,7 +6953,7 @@
                 }
 
                 tlState = smeGetTLSTAState(hHal, pHddStaCtx->conn_info.staId[0]);
-
+                pMac = PMAC_STRUCT( hHal );
                 buf = scnprintf(extra + len, WE_MAX_STR_LEN - len,
                         "\n HDD Conn State - %s "
                         "\n \n SME State:"
@@ -7240,6 +7245,7 @@
         }
 #endif /* FEATURE_OEM_DATA_SUPPORT */
 #endif
+
         default:
         {
             hddLog(LOGE, "%s: Invalid IOCTL command %d", __func__, sub_cmd );
@@ -8158,6 +8164,13 @@
                     break;
                 case WLAN_OFFLOAD_ARP_AND_BC_FILTER_ENABLE:
                     hddLog(VOS_TRACE_LEVEL_WARN, "   BC Filtering enable");
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+                    hddLog(VOS_TRACE_LEVEL_WARN, "	 ARP offload enable");
+                    hddLog(VOS_TRACE_LEVEL_WARN, "	 IP address: %d.%d.%d.%d",
+                    		pRequest->params.hostIpv4Addr[0], pRequest->params.hostIpv4Addr[1],
+                    		pRequest->params.hostIpv4Addr[2], pRequest->params.hostIpv4Addr[3]);
+					break;
+#endif
                 case WLAN_OFFLOAD_ENABLE:
                     hddLog(VOS_TRACE_LEVEL_WARN, "   ARP offload enable");
                     hddLog(VOS_TRACE_LEVEL_WARN, "   IP address: %d.%d.%d.%d",
@@ -10010,7 +10023,6 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
         0,
         "dl_report" },
-
     {   WE_SET_TXRX_FWSTATS,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
         0,
@@ -10141,6 +10153,7 @@
 #endif
 #endif
 
+
     {   WLAN_PRIV_SET_NONE_GET_INT,
         0,
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
@@ -10773,6 +10786,7 @@
         IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2,
         0, "set_smps_param" },
 
+
 };
 
 
diff -urN qcacld-new.orig/CORE/HDD/src/wlan_hdd_wmm.c qcacld-new/CORE/HDD/src/wlan_hdd_wmm.c
--- qcacld-new.orig/CORE/HDD/src/wlan_hdd_wmm.c	2016-05-16 10:58:06.458298648 +0800
+++ qcacld-new/CORE/HDD/src/wlan_hdd_wmm.c	2016-05-16 10:58:08.726298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*============================================================================
   @file wlan_hdd_wmm.c
@@ -2704,9 +2705,10 @@
       break;
 
    case SME_QOS_STATUS_RELEASE_FAILURE_RSP:
+#ifndef CONFIG_VD_PREVENT_MISSING_BREAK
       // nothing we can do with the existing flow except leave it
       status = HDD_WLAN_WMM_STATUS_RELEASE_FAILED;
-
+#endif
    default:
       // we didn't get back one of the SME_QOS_STATUS_RELEASE_* status codes
       VOS_TRACE( VOS_MODULE_ID_HDD, WMM_TRACE_LEVEL_ERROR,
diff -urN qcacld-new.orig/CORE/MAC/inc/qwlan_version.h qcacld-new/CORE/MAC/inc/qwlan_version.h
--- qcacld-new.orig/CORE/MAC/inc/qwlan_version.h	2016-05-16 10:58:07.514298648 +0800
+++ qcacld-new/CORE/MAC/inc/qwlan_version.h	2016-05-16 10:58:08.890298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/MAC/inc/sirApi.h qcacld-new/CORE/MAC/inc/sirApi.h
--- qcacld-new.orig/CORE/MAC/inc/sirApi.h	2016-05-16 10:58:07.522298648 +0800
+++ qcacld-new/CORE/MAC/inc/sirApi.h	2016-05-16 10:58:08.890298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
@@ -3814,6 +3815,110 @@
     tANI_U8 configuredMcstBcstFilterSetting;
 }tSirWlanResumeParam,*tpSirWlanResumeParam;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+
+typedef enum ext_wow_type
+{
+    EXT_WOW_TYPE_APP_TYPE1, /* wow type: only enable wakeup for app type1 */
+    EXT_WOW_TYPE_APP_TYPE2, /* wow type: only enable wakeup for app type2 */
+    EXT_WOW_TYPE_APP_TYPE1_2, /* wow type: enable wakeup for app type1&2 */
+    EXT_WOW_TYPE_APP_PULSETEST,
+    EXT_WOW_DISABLED = 255, /* wow type: only enable wakeup for app type1 */
+}EXT_WOW_TYPE;
+
+typedef struct
+{
+    tANI_U8 vdev_id;
+    EXT_WOW_TYPE type;
+    tANI_U32 wakeup_pin_num;
+    tANI_U8 swol_pulsetest_type;
+    tANI_U8 swol_pulsetest_application;
+} tSirExtWoWParams, *tpSirExtWoWParams;
+
+typedef struct
+{
+    tANI_U8 vdev_id;
+    tANI_U8 identification_id[8];
+    tANI_U8 password[16];
+    tANI_U32 id_length;
+    tANI_U32 pass_length;
+
+    tANI_U8 swol_indoor_wakee[6];
+    tANI_U8 swol_indoor_key[8][16];
+    tANI_U8 swol_indoor_key_len[8];
+    tANI_U8 swol_indoor_key_mac[8][6];
+    tANI_U32 swol_indoor_app_mask[8];
+    tANI_U8 swol_indoor_waker_check;
+    tANI_U8 swol_indoor_pw_check;
+    tANI_U8 swol_indoor_pattern;
+    tANI_U8 swol_indoor_exception;
+    tANI_U8 swol_indoor_exception_app;
+} tSirAppType1Params, *tpSirAppType1Params;
+
+/*SWOW waker used format*/
+struct waker{
+    u8 key_mac[6];
+    u8 key_len;
+    u8 key[16]; //Hex format
+    u32 app_mask;
+};
+
+struct ioctl_priv_params {
+    u16 cmd_id; //Mapping to "enum ioctl_priv_cmds"
+    u16 cmd_len;//Read or Write length
+    union {
+    /*Structure of SWOW USED*/
+        struct {
+            u8 cmd;
+            char* arp_ip_addr;
+        } swow_start;       //IOCTL_PRIV_SWOW_START
+
+        struct {
+            u8 waker_id;
+            struct waker write_waker;
+        } swow_waker_w;     //IOCTL_PRIV_SWOW_WAKER_W
+
+        struct {
+            struct waker read_waker[8];
+        } swow_waker_r;     //IOCTL_PRIV_SWOW_WAKER_R
+
+        struct {
+            u8 exception;
+            u8 exception_app;
+        } swow_exception;       //IOCTL_PRIV_SWOW_EXCEPTION_W & IOCTL_PRIV_SWOW_EXCEPTION_R
+
+        struct {
+            u8 pattern;
+        } swow_pattern;       //IOCTL_PRIV_SWOW_PATTEN_W & IOCTL_PRIV_SWOW_PATTEN_R
+
+        struct {
+            u8 waker_check;
+            u8 pw_check;
+        } swow_filter;       //IOCTL_PRIV_SWOW_FILTER_W & IOCTL_PRIV_SWOW_FILTER_R
+
+        struct {
+            u8 type;
+            u8 app;
+        } swow_pulse_test;   //IOCTL_PRIV_SWOW_PULSE_TEST
+    } params;
+} __packed;
+
+enum ioctl_priv_cmds
+{
+    IOCTL_PRIV_SWOW_START       = 33,//Write of swow_start
+    IOCTL_PRIV_SWOW_WAKER_W     = 34,//Write of swow_waker
+    IOCTL_PRIV_SWOW_WAKER_R     = 35,//Read of swow_waker
+    IOCTL_PRIV_SWOW_EXCEPTION_W = 36,//Write of swow_exception
+    IOCTL_PRIV_SWOW_EXCEPTION_R = 37,//Read of swow_exception
+    IOCTL_PRIV_SWOW_PATTEN_W    = 38,//Write of swow_pattern
+    IOCTL_PRIV_SWOW_PATTEN_R    = 39,//Read of swow_pattern
+    IOCTL_PRIV_SWOW_FILTER_W    = 40,//Write of swow_filter
+    IOCTL_PRIV_SWOW_FILTER_R    = 41,//Read of swow_filter
+    IOCTL_PRIV_SWOW_PULSE_TEST  = 42,//Write of swow_pulse_test
+};
+
+#endif
+
 typedef struct sSirWlanSetRxpFilters
 {
     tANI_U8 configuredMcstBcstFilterSetting;
@@ -4902,6 +5007,14 @@
     tANI_U16      mesgLen;
     tANI_BOOLEAN  suspended;
 }  tSirReadyToSuspendInd, *tpSirReadyToSuspendInd;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+typedef struct
+{
+    tANI_U16      mesgType;
+    tANI_U16      mesgLen;
+    tANI_BOOLEAN  status;
+}  tSirReadyToExtWoWInd, *tpSirReadyToExtWoWInd;
+#endif
 typedef struct sSirRateUpdateInd
 {
     tANI_U8 nss; /* 0: 1x1, 1: 2x2 */
diff -urN qcacld-new.orig/CORE/MAC/inc/wniApi.h qcacld-new/CORE/MAC/inc/wniApi.h
--- qcacld-new.orig/CORE/MAC/inc/wniApi.h	2016-05-16 10:58:07.506298648 +0800
+++ qcacld-new/CORE/MAC/inc/wniApi.h	2016-05-16 10:58:08.882298648 +0800
@@ -410,6 +410,9 @@
 #ifdef WLAN_FEATURE_NAN
     eWNI_SME_NAN_EVENT,
 #endif
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    eWNI_SME_READY_TO_EXTWOW_IND,
+#endif
     eWNI_SME_MSG_TYPES_END
 };
 
diff -urN qcacld-new.orig/CORE/MAC/src/cfg/cfgApi.c qcacld-new/CORE/MAC/src/cfg/cfgApi.c
--- qcacld-new.orig/CORE/MAC/src/cfg/cfgApi.c	2016-05-16 10:58:07.538298648 +0800
+++ qcacld-new/CORE/MAC/src/cfg/cfgApi.c	2016-05-16 10:58:08.898298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -865,11 +866,16 @@
             cfgLength = WNI_CFG_MAX_TX_POWER_5_LEN;
             PELOG2(cfgLog(pMac, LOG2, FL("HAL: Reading CFG for 5.0 GHz channels to get regulatory max tx power"));)
             break;
-
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         case eRF_BAND_UNKNOWN:
         default:
             PELOG2(cfgLog(pMac, LOG2, FL("HAL: Invalid current working band for the device"));)
             return WDA_MAX_TXPOWER_INVALID; //Its return, not break.
+#else
+        case eRF_BAND_UNKNOWN:
+            PELOG2(cfgLog(pMac, LOG2, FL("HAL: Invalid current working band for the device"));)
+            break;
+#endif
     }
 
     maxTxPwr = cfgGetDot11dTransmitPower(pMac, cfgId, cfgLength, channel);
diff -urN qcacld-new.orig/CORE/MAC/src/dph/dphHashTable.c qcacld-new/CORE/MAC/src/dph/dphHashTable.c
--- qcacld-new.orig/CORE/MAC/src/dph/dphHashTable.c	2016-05-16 10:58:07.538298648 +0800
+++ qcacld-new/CORE/MAC/src/dph/dphHashTable.c	2016-05-16 10:58:08.898298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -278,6 +279,7 @@
 
     pStaDs->added = 1;
     pStaDs->encPolicy = HAL_ENC_POLICY_NULL;
+    pStaDs->isDisassocDeauthInProgress = 0;
 
 #ifdef WMM_APSD
     pStaDs->stopQueue = 0;
@@ -429,6 +431,7 @@
       else
          prev->next = ptr->next;
       ptr->added = 0;
+      ptr->isDisassocDeauthInProgress = 0;
       ptr->next = 0;
     }
   else
diff -urN qcacld-new.orig/CORE/MAC/src/include/dot11f.h qcacld-new/CORE/MAC/src/include/dot11f.h
--- qcacld-new.orig/CORE/MAC/src/include/dot11f.h	2016-05-16 10:58:07.554298648 +0800
+++ qcacld-new/CORE/MAC/src/include/dot11f.h	2016-05-16 10:58:08.906298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
@@ -92,7 +93,7 @@
 #define DOT11F_BUFFER_OVERFLOW       ( 0x10000005 )
 #define DOT11F_MANDATORY_TLV_MISSING ( 0x00001000 )
 #define DOT11F_FAILED(code)          ( (code) & 0x10000000 )
-#define DOT11F_WARNED(code)          ( ( ( 0 == (code) ) & 0x10000000 ) && code)
+#define DOT11F_WARNED(code)          ( (code) & 0xEFFFFFFF )
 #define DOT11F_SUCCEEDED(code)       ( (code) == 0 )
 
 /*********************************************************************
@@ -5239,7 +5240,7 @@
 typedef struct sDot11fIESuppChannels {
     tANI_U8      present;
     tANI_U8      num_bands;
-    tANI_U8      bands[48][2];
+    tANI_U8      bands[WNI_CFG_VALID_CHANNEL_LIST_LEN][2];
 } tDot11fIESuppChannels;
 
 #define DOT11F_EID_SUPPCHANNELS ( 36 )
diff -urN qcacld-new.orig/CORE/MAC/src/include/dphGlobal.h qcacld-new/CORE/MAC/src/include/dphGlobal.h
--- qcacld-new.orig/CORE/MAC/src/include/dphGlobal.h	2016-05-16 10:58:07.554298648 +0800
+++ qcacld-new/CORE/MAC/src/include/dphGlobal.h	2016-05-16 10:58:08.906298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -643,6 +644,7 @@
 
      */
 
+    tANI_U8 isDisassocDeauthInProgress;
     struct sDphHashNode  *next;
 
 
diff -urN qcacld-new.orig/CORE/MAC/src/include/sirParams.h qcacld-new/CORE/MAC/src/include/sirParams.h
--- qcacld-new.orig/CORE/MAC/src/include/sirParams.h	2016-05-16 10:58:07.538298648 +0800
+++ qcacld-new/CORE/MAC/src/include/sirParams.h	2016-05-16 10:58:08.898298648 +0800
@@ -727,6 +727,13 @@
 #ifdef DHCP_SERVER_OFFLOAD
 #define SIR_HAL_SET_DHCP_SERVER_OFFLOAD    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 284)
 #endif /* DHCP_SERVER_OFFLOAD */
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define SIR_HAL_CONFIG_EXT_WOW             (SIR_HAL_ITC_MSG_TYPES_BEGIN + 287)
+#define SIR_HAL_CONFIG_APP_TYPE1_PARAMS    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 288)
+#define SIR_HAL_CONFIG_APP_TYPE2_PARAMS    (SIR_HAL_ITC_MSG_TYPES_BEGIN + 289)
+#endif
+
 #define SIR_HAL_LED_FLASHING_REQ           (SIR_HAL_ITC_MSG_TYPES_BEGIN + 293)
 
 #ifdef MDNS_OFFLOAD
diff -urN qcacld-new.orig/CORE/MAC/src/pe/include/limGlobal.h qcacld-new/CORE/MAC/src/pe/include/limGlobal.h
--- qcacld-new.orig/CORE/MAC/src/pe/include/limGlobal.h	2016-05-16 10:58:07.562298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/include/limGlobal.h	2016-05-16 10:58:08.906298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -72,7 +73,7 @@
 #define LIM_HASH_MISS_TIMER_MS                  10000
 
 // Deferred Message Queue Length
-#define MAX_DEFERRED_QUEUE_LEN                  20
+#define MAX_DEFERRED_QUEUE_LEN                  80
 
 // Maximum Buffer size
 #define LIM_MAX_BUF_SIZE                        8192
diff -urN qcacld-new.orig/CORE/MAC/src/pe/include/limSession.h qcacld-new/CORE/MAC/src/pe/include/limSession.h
--- qcacld-new.orig/CORE/MAC/src/pe/include/limSession.h	2016-05-16 10:58:07.562298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/include/limSession.h	2016-05-16 10:58:08.906298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -459,6 +460,7 @@
      * gLimOlbcParams, gLimOverlap11gParams, gLimOverlapHt20Params etc
      */
     tANI_U16 old_protection_state;
+    bool add_bss_failed;
 }tPESession, *tpPESession;
 
 #define LIM_MAX_ACTIVE_SESSIONS 4
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limApi.c qcacld-new/CORE/MAC/src/pe/lim/limApi.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limApi.c	2016-05-16 10:58:07.570298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limApi.c	2016-05-16 10:58:08.914298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2011-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limAssocUtils.c qcacld-new/CORE/MAC/src/pe/lim/limAssocUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limAssocUtils.c	2016-05-16 10:58:07.626298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limAssocUtils.c	2016-05-16 10:58:08.942298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limAssocUtils.cc contains the utility functions
@@ -731,12 +732,14 @@
     // increment a debug count
     pMac->lim.gLimNumRxCleanup++;
 #endif
-
-    if (psessionEntry->limSmeState == eLIM_SME_JOIN_FAILURE_STATE) {
-        retCode = limDelBss( pMac, pStaDs, psessionEntry->bssIdx, psessionEntry);
+    /* Do DEL BSS or DEL STA only if ADD BSS was success */
+    if (!psessionEntry->add_bss_failed) {
+        if (psessionEntry->limSmeState == eLIM_SME_JOIN_FAILURE_STATE) {
+            retCode = limDelBss( pMac, pStaDs,
+                              psessionEntry->bssIdx, psessionEntry);
+        } else
+            retCode = limDelSta( pMac, pStaDs, true, psessionEntry);
     }
-    else
-        retCode = limDelSta( pMac, pStaDs, true, psessionEntry);
 
     return retCode;
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limFT.c qcacld-new/CORE/MAC/src/pe/lim/limFT.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limFT.c	2016-05-16 10:58:07.602298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limFT.c	2016-05-16 10:58:08.930298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #ifdef WLAN_FEATURE_VOWIFI_11R
 /**=========================================================================
@@ -348,7 +349,7 @@
     if (psessionEntry->is11Rconnection)
     {
         // Only 11r assoc has FT IEs.
-        if (pMac->ft.ftPEContext.pFTPreAuthReq->ft_ies == NULL)
+        if (pMac->ft.ftPEContext.pFTPreAuthReq->ft_ies_length == 0)
         {
             PELOGE(limLog( pMac, LOGE,
                            "%s: FTIEs for Auth Req Seq 1 is absent",
@@ -913,7 +914,7 @@
     }
     pftSessionEntry->htSupportedChannelWidthSet =
                (pBeaconStruct->HTInfo.present)?
-               (cbEnabledMode && pBeaconStruct->HTInfo.recommendedTxWidthSet):0;
+               ((cbEnabledMode && pBeaconStruct->HTInfo.recommendedTxWidthSet)?1:0):0;
     pftSessionEntry->htRecommendedTxWidthSet =
                pftSessionEntry->htSupportedChannelWidthSet;
 
@@ -1107,7 +1108,11 @@
     if (NULL == pFTPreAuthRsp)
     {
        PELOGE(limLog( pMac, LOGE, "Failed to allocate memory");)
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+       VOS_ASSERT_VD(pFTPreAuthRsp != NULL);
+#else
        VOS_ASSERT(pFTPreAuthRsp != NULL);
+#endif
        return;
     }
     vos_mem_zero( pFTPreAuthRsp, rspLen);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limP2P.c qcacld-new/CORE/MAC/src/pe/lim/limP2P.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limP2P.c	2016-05-16 10:58:07.602298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limP2P.c	2016-05-16 10:58:08.930298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
                         L I M _ P 2 P . C
@@ -810,6 +811,7 @@
     v_U8_t              *pIe=NULL;
     tDot11fIEHTCaps     dot11HtCap;
 
+	vos_mem_set(&dot11HtCap, sizeof(tDot11fIEHTCaps), 0);
     PopulateDot11fHTCaps(pMac, psessionEntry, &dot11HtCap);
     pIe = limGetIEPtr(pMac,pIeStartPtr, nBytes,
                                        DOT11F_EID_HTCAPS,ONE_BYTE);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessActionFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessActionFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessActionFrame.c	2016-05-16 10:58:07.626298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessActionFrame.c	2016-05-16 10:58:08.942298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2013 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -441,6 +441,9 @@
     }
     pSta = dphLookupHashEntry(pMac, pHdr->sa, &aid, &psessionEntry->dph.dphHashTable);
 
+    if (pSta == NULL)
+        goto OUT;
+
     operMode = pSta->vhtSupportedChannelWidthSet ? eHT_CHANNEL_WIDTH_80MHZ : pSta->htSupportedChannelWidthSet ? eHT_CHANNEL_WIDTH_40MHZ: eHT_CHANNEL_WIDTH_20MHZ;
     if( operMode != pOperatingModeframe->OperatingMode.chanWidth)
     {
@@ -483,7 +486,7 @@
         limSetNssChange( pMac, psessionEntry, pSta->vhtSupportedRxNss,
                          pSta->staIndex, pHdr->sa);
     }
-
+OUT:
     vos_mem_free(pOperatingModeframe);
     return;
 }
@@ -539,7 +542,8 @@
     }
     pSta = dphLookupHashEntry(pMac, pHdr->sa, &aid, &psessionEntry->dph.dphHashTable);
 
-    {
+    if (pSta != NULL)
+	{
         limLog(pMac, LOGE,
             FL(" received Gid Management Action Frame , staIdx = %d"),
                pSta->staIndex);
@@ -825,8 +829,7 @@
         pMac->lim.gLimAddtsSent = false;
         return;   //Error handling. send the response with error status. need to send DelTS to tear down the TSPEC status.
     }
-    if((addts.tspec.tsinfo.traffic.accessPolicy != SIR_MAC_ACCESSPOLICY_EDCA) ||
-       ((upToAc(addts.tspec.tsinfo.traffic.userPrio) < MAX_NUM_AC)))
+    if(addts.tspec.tsinfo.traffic.accessPolicy != SIR_MAC_ACCESSPOLICY_EDCA)
     {
 #ifdef FEATURE_WLAN_ESE
         retval = limSendHalMsgAddTs(pMac,
@@ -935,18 +938,6 @@
 
     tsinfo = delts.wmeTspecPresent ? &delts.tspec.tsinfo : &delts.tsinfo;
 
-    // if no Admit Control, ignore the request
-    if ((tsinfo->traffic.accessPolicy == SIR_MAC_ACCESSPOLICY_EDCA))
-    {
-
-        if (upToAc(tsinfo->traffic.userPrio) >= MAX_NUM_AC)
-        {
-            limLog(pMac, LOGW, FL("DelTs with UP %d has no AC - ignoring request"),
-                   tsinfo->traffic.userPrio);
-            return;
-        }
-    }
-
     if ((psessionEntry->limSystemRole != eLIM_AP_ROLE) &&
         (psessionEntry->limSystemRole != eLIM_BT_AMP_AP_ROLE))
         limSendSmeDeltsInd(pMac, &delts, aid,psessionEntry);
@@ -2558,6 +2549,7 @@
                     (tANI_U8*)pHdr, frameLen + sizeof(tSirMacMgmtHdr), 0,
                     WDA_GET_RX_CH( pRxPacketInfo ), psessionEntry, 0);
             }
+            break;
 
 #ifdef FEATURE_WLAN_TDLS
            case SIR_MAC_TDLS_DIS_RSP:
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c	2016-05-16 10:58:07.590298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessAssocReqFrame.c	2016-05-16 10:58:08.930298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limProcessAssocReqFrame.cc contains the code
@@ -1478,7 +1479,6 @@
 void limSendMlmAssocInd(tpAniSirGlobal pMac, tpDphHashNode pStaDs, tpPESession psessionEntry)
 {
     tpLimMlmAssocInd        pMlmAssocInd = NULL;
-    tpLimMlmReassocInd      pMlmReassocInd;
     tpSirAssocReq           pAssocReq;
     tANI_U16                temp;
     tANI_U32                phyMode;
@@ -1486,7 +1486,10 @@
     tANI_U8                 *wpsIe = NULL;
     tANI_U32                tmp;
 //    tANI_U16                statusCode;
+#if 0 //not current used.
     tANI_U16                i, j=0;
+    tpLimMlmReassocInd      pMlmReassocInd;
+#endif
 
     // Get a copy of the already parsed Assoc Request
     pAssocReq = (tpSirAssocReq) psessionEntry->parsedAssocReq[pStaDs->assocId];
@@ -1618,6 +1621,7 @@
         limPostSmeMessage(pMac, LIM_MLM_ASSOC_IND, (tANI_U32 *) pMlmAssocInd);
         vos_mem_free(pMlmAssocInd);
     }
+#if 0 //currenlty don't have this case, remove them based on code scan result.
     else
     {
         // If its of Reassociation Request, then post LIM_MLM_REASSOC_IND
@@ -1742,7 +1746,7 @@
         limPostSmeMessage(pMac, LIM_MLM_REASSOC_IND, (tANI_U32 *) pMlmReassocInd);
         vos_mem_free(pMlmReassocInd);
     }
-
+#endif
     return;
 
 } /*** end limSendMlmAssocInd() ***/
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAuthFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessAuthFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessAuthFrame.c	2016-05-16 10:58:07.634298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessAuthFrame.c	2016-05-16 10:58:08.950298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -1192,6 +1193,7 @@
 
                         if (pKeyMapEntry)
                         {
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
                             if (pKeyMapEntry->key == NULL)
                             {
                                 // Log error
@@ -1221,6 +1223,7 @@
                                 return;
                             } // if (pKeyMapEntry->key == NULL)
                             else
+#endif								
                             {
                                 ((tpSirMacAuthFrameBody) plainBody)->authAlgoNumber =
                                 sirSwapU16ifNeeded(pRxAuthFrameBody->authAlgoNumber);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessDeauthFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessDeauthFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessDeauthFrame.c	2016-05-16 10:58:07.590298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessDeauthFrame.c	2016-05-16 10:58:08.930298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -238,7 +239,9 @@
      *     AP we're currently associated with (case a), then proceed
      *     with normal deauth processing.
      */
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     if ( psessionEntry->limReAssocbssId!=NULL )
+#endif
     {
         pRoamSessionEntry = peFindSessionByBssid(pMac, psessionEntry->limReAssocbssId, &roamSessionId);
     }
@@ -468,18 +471,20 @@
     }
 
     if ((pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_STA_RSP_STATE) ||
-        (pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_BSS_RSP_STATE))
-    {
+        (pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_BSS_RSP_STATE) ||
+        (pStaDs->isDisassocDeauthInProgress)) {
         /**
          * Already in the process of deleting context for the peer
          * and received Deauthentication frame. Log and Ignore.
          */
         PELOGE(limLog(pMac, LOGE,
            FL("received Deauth frame from peer that is in state %X, addr "
-           MAC_ADDRESS_STR),
-           pStaDs->mlmStaContext.mlmState,MAC_ADDR_ARRAY(pHdr->sa));)
+           MAC_ADDRESS_STR", isDisassocDeauthInProgress : %d\n"),
+           pStaDs->mlmStaContext.mlmState,MAC_ADDR_ARRAY(pHdr->sa),
+           pStaDs->isDisassocDeauthInProgress);)
         return;
     }
+    pStaDs->isDisassocDeauthInProgress++;
     pStaDs->mlmStaContext.disassocReason = (tSirMacReasonCodes)reasonCode;
     pStaDs->mlmStaContext.cleanupTrigger = eLIM_PEER_ENTITY_DEAUTH;
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessDisassocFrame.c qcacld-new/CORE/MAC/src/pe/lim/limProcessDisassocFrame.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessDisassocFrame.c	2016-05-16 10:58:07.582298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessDisassocFrame.c	2016-05-16 10:58:08.914298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -268,15 +269,17 @@
     }
 
     if ((pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_STA_RSP_STATE) ||
-        (pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_BSS_RSP_STATE))
-    {
+        (pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_BSS_RSP_STATE) ||
+        (pStaDs->isDisassocDeauthInProgress)) {
         /**
          * Already in the process of deleting context for the peer
          * and received Disassociation frame. Log and Ignore.
          */
         PELOGE(limLog(pMac, LOGE,
-               FL("received Disassoc frame in state %d from "MAC_ADDRESS_STR),
-               pStaDs->mlmStaContext.mlmState, MAC_ADDR_ARRAY(pHdr->sa));)
+               FL("received Disassoc frame in state %d from "MAC_ADDRESS_STR
+               ",isDisassocDeauthInProgress : %d\n"),
+               pStaDs->mlmStaContext.mlmState, MAC_ADDR_ARRAY(pHdr->sa),
+               pStaDs->isDisassocDeauthInProgress);)
 
         return;
     }
@@ -297,6 +300,7 @@
 
     } // if (pStaDs->mlmStaContext.mlmState != eLIM_MLM_LINK_ESTABLISHED_STATE)
 
+    pStaDs->isDisassocDeauthInProgress++;
     pStaDs->mlmStaContext.cleanupTrigger = eLIM_PEER_ENTITY_DISASSOC;
     pStaDs->mlmStaContext.disassocReason = (tSirMacReasonCodes) reasonCode;
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMessageQueue.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2016-05-16 10:58:07.590298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMessageQueue.c	2016-05-16 10:58:08.930298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2011-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -246,12 +246,11 @@
               pMac->lim.gLimPrevMlmState);
         MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DEFERRED));)
     }
-    else
-    {
-        limLog(pMac, LOGE, FL("Dropped lim message (0x%X)"), pMsg->type);
-        MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DROPPED));)
-    }
-
+	else
+	{
+		limLog(pMac, LOGE, FL("Dropped lim message (0x%X)"), pMsg->type);
+		MTRACE(macTraceMsgRx(pMac, NO_SESSION, LIM_TRACE_MAKE_RXMSG(pMsg->type, LIM_MSG_DROPPED));)
+	}
     return retCode;
 } /*** end limDeferMsg() ***/
 
@@ -382,7 +381,10 @@
                                     break ;
                                 }
                         }
-                    }
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+                        break ;
+#endif
+                    }      
                 default:
                     {
                         break ;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2016-05-16 10:58:07.582298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmReqMessages.c	2016-05-16 10:58:08.914298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limProcessMlmMessages.cc contains the code
@@ -399,7 +400,6 @@
 void limContinuePostChannelScan(tpAniSirGlobal pMac)
 {
     tANI_U8 channelNum;
-    tANI_U8 handleError = 0;
     tANI_U8 i = 0;
     tSirRetStatus status = eSIR_SUCCESS;
 
@@ -586,26 +586,7 @@
         // Wait for Beacons to arrive
     } // if (pMac->lim.gLimMlmScanReq->scanType == eSIR_ACTIVE_SCAN)
 
-    if( handleError )
-    {
-        //
-        // FIXME - With this, LIM/SoftMAC will try and recover
-        // state, but eWNI_SME_SCAN_CNF maybe reporting an
-        // incorrect status back to the SME. Some of the possible
-        // errors are:
-        // eSIR_SME_HAL_SCAN_INIT_FAILED
-        // eSIR_SME_RESOURCES_UNAVAILABLE
-        //
-        //Set the resume channel to Any valid channel (invalid).
-        //This will instruct HAL to set it to any previous valid channel.
-        peSetResumeChannel(pMac, 0, 0);
-        limSendHalFinishScanReq( pMac, eLIM_HAL_FINISH_SCAN_WAIT_STATE );
-        //limCompleteMlmScan(pMac, eSIR_SME_HAL_SCAN_INIT_FAILED);
-    }
-    else
-    {
-        limAddScanChannelInfo(pMac, channelNum);
-    }
+    limAddScanChannelInfo(pMac, channelNum);
 
     return;
 }
@@ -2819,6 +2800,9 @@
     tLimMlmDisassocCnf       mlmDisassocCnf;
     tpPESession              psessionEntry;
     extern tANI_BOOLEAN     sendDisassocFrame;
+    tSirSmeDisassocRsp      *pSirSmeDisassocRsp;
+    tANI_U32                *pMsg;
+    tANI_U8                 *pBuf;
 
     if(eHAL_STATUS_SUCCESS != suspendStatus)
     {
@@ -2861,12 +2845,35 @@
                    FL("received MLM_DISASSOC_REQ with invalid BSS id "));)
                 limPrintMacAddr(pMac, pMlmDisassocReq->peerMacAddr, LOGW);
 
-                /// Prepare and Send LIM_MLM_DISASSOC_CNF
-
-                mlmDisassocCnf.resultCode      =
-                                       eSIR_SME_INVALID_PARAMETERS;
+                /*
+                 * Disassociation response due to host triggered disassociation
+                 */
+                pSirSmeDisassocRsp =
+                    vos_mem_malloc(sizeof(tSirSmeDisassocRsp));
+                if (NULL == pSirSmeDisassocRsp) {
+                    /* Log error */
+                    limLog(pMac, LOGP,
+                        FL("call to AllocateMemory failed for eWNI_SME_DISASSOC_RSP"));
+                    return;
+                }
+                limLog(pMac, LOG1,
+                    FL("send eWNI_SME_DISASSOC_RSP with retCode: %d for " MAC_ADDRESS_STR),
+                        eSIR_SME_DEAUTH_STATUS,
+                        MAC_ADDR_ARRAY(pMlmDisassocReq->peerMacAddr));
+                    pSirSmeDisassocRsp->messageType = eWNI_SME_DISASSOC_RSP;
+                    pSirSmeDisassocRsp->length = sizeof(tSirSmeDisassocRsp);
+                    pSirSmeDisassocRsp->sessionId = pMlmDisassocReq->sessionId;
+                    pSirSmeDisassocRsp->transactionId = 0;
+                    pSirSmeDisassocRsp->statusCode = eSIR_SME_DEAUTH_STATUS;
+
+                    pBuf = (tANI_U8 *) pSirSmeDisassocRsp->peerMacAddr;
+                    vos_mem_copy( pBuf, pMlmDisassocReq->peerMacAddr,
+                        sizeof(tSirMacAddr));
+                    pMsg = (tANI_U32*) pSirSmeDisassocRsp;
 
-                goto end;
+                    limSendSmeDisassocDeauthNtf(pMac, eHAL_STATUS_SUCCESS,
+                                                 (tANI_U32*) pMsg);
+                    return;
             }
 
             break;
@@ -3137,7 +3144,9 @@
     tLimMlmDeauthReq        *pMlmDeauthReq;
     tLimMlmDeauthCnf        mlmDeauthCnf;
     tpPESession             psessionEntry;
-
+    tSirSmeDeauthRsp        *pSirSmeDeauthRsp;
+    tANI_U8                 *pBuf;
+    tANI_U32                *pMsg;
 
     if(eHAL_STATUS_SUCCESS != suspendStatus)
     {
@@ -3191,11 +3200,37 @@
                            MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr),
                            MAC_ADDR_ARRAY(currentBssId));
 
-                        /// Prepare and Send LIM_MLM_DEAUTH_CNF
+                        /*
+                         * Deauthentication response to host triggered
+                         * deauthentication.
+                         */
+                        pSirSmeDeauthRsp =
+                            vos_mem_malloc(sizeof(tSirSmeDeauthRsp));
+                        if (NULL == pSirSmeDeauthRsp) {
+                            /* Log error */
+                            limLog(pMac, LOGP,
+                                FL("call to AllocateMemory failed for eWNI_SME_DEAUTH_RSP"));
+                            return;
+                        }
+                        limLog(pMac, LOG1,
+                            FL("send eWNI_SME_DEAUTH_RSP with retCode: %d for " MAC_ADDRESS_STR),
+                            eSIR_SME_DEAUTH_STATUS,
+                            MAC_ADDR_ARRAY(pMlmDeauthReq->peerMacAddr));
+                        pSirSmeDeauthRsp->messageType = eWNI_SME_DEAUTH_RSP;
+                        pSirSmeDeauthRsp->length = sizeof(tSirSmeDeauthRsp);
+                        pSirSmeDeauthRsp->statusCode = eSIR_SME_DEAUTH_STATUS;
+                        pSirSmeDeauthRsp->sessionId = pMlmDeauthReq->sessionId;
+                        pSirSmeDeauthRsp->transactionId = 0;
+
+                       pBuf = (tANI_U8 *) pSirSmeDeauthRsp->peerMacAddr;
+                       vos_mem_copy(pBuf, pMlmDeauthReq->peerMacAddr,
+                           sizeof(tSirMacAddr));
+                       pMsg = (tANI_U32*)pSirSmeDeauthRsp;
 
-                        mlmDeauthCnf.resultCode = eSIR_SME_INVALID_PARAMETERS;
+                       limSendSmeDisassocDeauthNtf(pMac, eHAL_STATUS_SUCCESS,
+                                            (tANI_U32*) pMsg);
 
-                        goto end;
+                       return;
                     }
 
                     if ((psessionEntry->limMlmState ==
@@ -3797,7 +3832,7 @@
         {
             // This shouldn't be the case, but when this happens, this timeout should be for the last channelId.
             // Get the channelNum as close to correct as possible.
-            if(pMac->lim.gpLimMlmScanReq->channelList.channelNumber)
+            if(pMac->lim.gpLimMlmScanReq->channelList.numChannels)
             {
                 channelNum = pMac->lim.gpLimMlmScanReq->channelList.channelNumber[pMac->lim.gpLimMlmScanReq->channelList.numChannels - 1];
             }
@@ -3873,7 +3908,7 @@
         }
         else
         {
-            if(pMac->lim.gpLimMlmScanReq->channelList.channelNumber)
+            if(pMac->lim.gpLimMlmScanReq->channelList.numChannels)
             {
                 channelNum = pMac->lim.gpLimMlmScanReq->channelList.channelNumber[pMac->lim.gpLimMlmScanReq->channelList.numChannels - 1];
             }
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c	2016-05-16 10:58:07.590298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessMlmRspMessages.c	2016-05-16 10:58:08.914298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limProcessMlmRspMessages.cc contains the code
@@ -413,7 +414,6 @@
         peDeleteSession(pMac,psessionEntry);
         psessionEntry = NULL;
         PELOGE(limLog(pMac, LOGE,FL("Start BSS Failed "));)
-        return;
     }
     /// Send response to Host
     limSendSmeStartBssRsp(pMac, eWNI_SME_START_BSS_RSP,
@@ -1107,6 +1107,7 @@
         // Log error
         limLog(pMac, LOGP,
            FL("call to AllocateMemory failed for eWNI_SME_AUTH_IND"));
+		return;
     }
     limCopyU16((tANI_U8 *) &pSirSmeAuthInd->messageType, eWNI_SME_AUTH_IND);
     limAuthIndSerDes(pMac, (tpLimMlmAuthInd) pMsgBuf,
@@ -1458,6 +1459,14 @@
         case eLIM_STA_IN_IBSS_ROLE:
             break;
         case eLIM_STA_ROLE:
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+        psessionEntry->limSmeState = eLIM_SME_WT_DEAUTH_STATE;
+        MTRACE(macTrace(pMac, TRACE_CODE_SME_STATE, psessionEntry->peSessionId, psessionEntry->limSmeState));
+        PELOG1(limLog(pMac, LOG1,
+          FL("*** Received Deauthentication from staId=%d ***"),
+          pMlmDeauthInd->aid);)
+        break;
+#endif
         case eLIM_BT_AMP_STA_ROLE:
             psessionEntry->limSmeState = eLIM_SME_WT_DEAUTH_STATE;
             MTRACE(macTrace(pMac, TRACE_CODE_SME_STATE, psessionEntry->peSessionId, psessionEntry->limSmeState));
@@ -1522,9 +1531,9 @@
     if ((psessionEntry->limSystemRole == eLIM_STA_ROLE)|| (psessionEntry->limSystemRole == eLIM_BT_AMP_STA_ROLE))
     {
         // Deauth Confirm from MLM
-        if (psessionEntry->limSmeState != eLIM_SME_WT_DEAUTH_STATE)
-        {
-            /**
+        if ((psessionEntry->limSmeState != eLIM_SME_WT_DISASSOC_STATE) &&
+            (psessionEntry->limSmeState != eLIM_SME_WT_DEAUTH_STATE)) {
+            /*
              * Should not have received Deauth confirm
              * from MLM in other states.
              * Log error
@@ -1779,12 +1788,18 @@
             pStaDs->mlmStaContext.protStatusCode = protStatusCode;
             //Done: 7-27-2009. JIM_FIX_ME: at the end of limCleanupRxPath, make sure PE is sending eWNI_SME_JOIN_RSP to SME
             limCleanupRxPath(pMac, pStaDs, psessionEntry);
+            /* Cleanup if add bss failed */
+            if(psessionEntry->add_bss_failed) {
+              dphDeleteHashEntry(pMac, pStaDs->staAddr, pStaDs->assocId,
+                                   &psessionEntry->dph.dphHashTable);
+              goto error;
+            }
             vos_mem_free(psessionEntry->pLimJoinReq);
             psessionEntry->pLimJoinReq = NULL;
             return;
         }
     }
-
+error:
     vos_mem_free(psessionEntry->pLimJoinReq);
     psessionEntry->pLimJoinReq = NULL;
     //Delete teh session if JOIN failure occurred.
@@ -1850,11 +1865,17 @@
             pStaDs->mlmStaContext.cleanupTrigger = eLIM_JOIN_FAILURE;
             pStaDs->mlmStaContext.resultCode = resultCode;
             pStaDs->mlmStaContext.protStatusCode = protStatusCode;
+            /* Cleanup if add bss failed */
+            if(psessionEntry->add_bss_failed) {
+              dphDeleteHashEntry(pMac, pStaDs->staAddr, pStaDs->assocId,
+                                   &psessionEntry->dph.dphHashTable);
+              goto error;
+            }
             limCleanupRxPath(pMac, pStaDs, psessionEntry);
             return;
         }
     }
-
+error:
     //Delete teh session if REASSOC failure occurred.
     if(resultCode != eSIR_SME_SUCCESS)
     {
@@ -3192,6 +3213,7 @@
                 psessionEntry->peSessionId);
         // Return Assoc confirm to SME with failure
         mlmAssocCnf.resultCode = (tSirResultCodes) eSIR_SME_REFUSED;
+        psessionEntry->add_bss_failed = true;
     }
 
     if(mlmAssocCnf.resultCode != eSIR_SME_SUCCESS)
@@ -4401,12 +4423,7 @@
         vos_mem_free(pMsgBuf);
         return;
     }
-    if(NULL == pMlmDelBACnf)
-    {
-        limLog( pMac, LOGE,
-        FL( "pMlmDelBACnf is NULL - ignoring DELBA CNF from HAL" ));
-        return;
-    }
+
     // Need to validate baState
     LIM_GET_STA_BA_STATE(pSta, pMlmDelBACnf->baTID, &curBaState);
     if( eLIM_BA_STATE_WT_DEL_RSP != curBaState )
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2016-05-16 10:58:07.626298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessSmeReqMessages.c	2016-05-16 10:58:08.942298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -778,7 +778,7 @@
                                  IS_DOT11_MODE_HT(psessionEntry->dot11mode)?1:0;
             else
                 psessionEntry->htSupportedChannelWidthSet =
-                                 (pSmeStartBssReq->cbMode)?1:0;
+                                 (pSmeStartBssReq->cbMode > 0)?1:0;
             psessionEntry->htRecommendedTxWidthSet = psessionEntry->htSupportedChannelWidthSet;
             psessionEntry->htSecondaryChannelOffset = pSmeStartBssReq->cbMode;
             VOS_TRACE(VOS_MODULE_ID_PE, VOS_TRACE_LEVEL_INFO,
@@ -1951,7 +1951,7 @@
 
         /* Copy The channel Id to the session Table */
         psessionEntry->currentOperChannel = pSmeJoinReq->bssDescription.channelId;
-        psessionEntry->htSupportedChannelWidthSet = (pSmeJoinReq->cbMode)?1:0; // This is already merged value of peer and self - done by csr in csrGetCBModeFromIes
+        psessionEntry->htSupportedChannelWidthSet = (pSmeJoinReq->cbMode > 0)?1:0; // This is already merged value of peer and self - done by csr in csrGetCBModeFromIes
         psessionEntry->htRecommendedTxWidthSet = psessionEntry->htSupportedChannelWidthSet;
         psessionEntry->htSecondaryChannelOffset = pSmeJoinReq->cbMode;
 
@@ -2353,7 +2353,7 @@
          psessionEntry->pLimReAssocReq->bssDescription.channelId;
 
     psessionEntry->reAssocHtSupportedChannelWidthSet =
-         (psessionEntry->pLimReAssocReq->cbMode)?1:0;
+         (psessionEntry->pLimReAssocReq->cbMode != PHY_SINGLE_CHANNEL_CENTERED)?1:0;
     psessionEntry->reAssocHtRecommendedTxWidthSet =
          psessionEntry->reAssocHtSupportedChannelWidthSet;
     psessionEntry->reAssocHtSecondaryChannelOffset =
@@ -2899,6 +2899,20 @@
                      MAC_ADDR_ARRAY(smeDisassocCnf.peerMacAddr));)
             return;
         }
+        /*
+         * If MlM state is either of del_sta or del_bss state, then no need to
+         * go ahead and clean up further as there must be some cleanup in
+         * progress from upper layer disassoc/deauth request.
+         */
+        if((pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_STA_RSP_STATE) ||
+           (pStaDs->mlmStaContext.mlmState == eLIM_MLM_WT_DEL_BSS_RSP_STATE)) {
+           limLog(pMac, LOGE, FL("No need to cleanup for addr:"MAC_ADDRESS_STR
+               "as Mlm state is %d"),
+               MAC_ADDR_ARRAY(smeDisassocCnf.peerMacAddr),
+               pStaDs->mlmStaContext.mlmState);
+           return;
+        }
+
         /* Delete FT session if there exists one */
         limFTCleanup(pMac);
         limCleanupRxPath(pMac, pStaDs, psessionEntry);
@@ -3498,6 +3512,8 @@
     tANI_U8                 assocId = 0;
     tANI_U8                 staCount = 0;
 
+    vos_mem_zero(&getAssocSTAsReq, sizeof(getAssocSTAsReq));
+
     if (!limIsSmeGetAssocSTAsReqValid(pMac, &getAssocSTAsReq, (tANI_U8 *) pMsgBuf))
     {
         limLog(pMac, LOGE,
@@ -3609,7 +3625,7 @@
  */
 void limProcessSmeGetWPSPBCSessions(tpAniSirGlobal pMac, tANI_U32 *pMsgBuf)
 {
-    tSirSmeGetWPSPBCSessionsReq  GetWPSPBCSessionsReq;
+    tSirSmeGetWPSPBCSessionsReq  *pGetWPSPBCSessionsReq;
     tpPESession                  psessionEntry = NULL;
     tSap_Event                   sapEvent;
     tpWLAN_SAPEventCB            pSapEventCallback = NULL;
@@ -3618,7 +3634,15 @@
 
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.status = VOS_STATUS_E_FAULT;
 
-    if (limIsSmeGetWPSPBCSessionsReqValid(pMac,  &GetWPSPBCSessionsReq, (tANI_U8 *) pMsgBuf) != eSIR_SUCCESS)
+	pGetWPSPBCSessionsReq = vos_mem_malloc(sizeof(tSirSmeGetWPSPBCSessionsReq));
+	if ( NULL == pGetWPSPBCSessionsReq ) {
+		limLog(pMac, LOGE,
+			FL("Allocation memeory falied at %s"), __func__);
+		return;
+	}
+	vos_mem_set(pGetWPSPBCSessionsReq, sizeof(tSirSmeGetWPSPBCSessionsReq), 0);
+
+    if (limIsSmeGetWPSPBCSessionsReqValid(pMac,  pGetWPSPBCSessionsReq, (tANI_U8 *) pMsgBuf) != eSIR_SUCCESS)
     {
         limLog(pMac, LOGE,
                         FL("received invalid eWNI_SME_GET_ASSOC_STAS_REQ message"));
@@ -3627,7 +3651,7 @@
 
     // Get Associated stations from PE
     // Find PE session Entry
-    if ((psessionEntry = peFindSessionByBssid(pMac, GetWPSPBCSessionsReq.bssId, &sessionId)) == NULL)
+	if ((psessionEntry = peFindSessionByBssid(pMac, pGetWPSPBCSessionsReq->bssId, &sessionId)) == NULL)
     {
         limLog(pMac, LOGE,
                         FL("session does not exist for given bssId"));
@@ -3646,7 +3670,7 @@
     sapEvent.sapHddEventCode =  eSAP_GET_WPSPBC_SESSION_EVENT;
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.module = VOS_MODULE_ID_PE;
 
-    if (vos_mem_compare( zeroMac, GetWPSPBCSessionsReq.pRemoveMac, sizeof(tSirMacAddr)))
+	if (vos_mem_compare( zeroMac, pGetWPSPBCSessionsReq->pRemoveMac, sizeof(tSirMacAddr)))
     { //This is GetWpsSession call
 
       limGetWPSPBCSessions(pMac,
@@ -3655,9 +3679,10 @@
     }
     else
     {
-      limRemovePBCSessions(pMac, GetWPSPBCSessionsReq.pRemoveMac,psessionEntry);
-      /* don't have to inform the HDD/Host */
-      return;
+		limRemovePBCSessions(pMac, pGetWPSPBCSessionsReq->pRemoveMac,psessionEntry);
+		/* don't have to inform the HDD/Host */
+		vos_mem_free(pGetWPSPBCSessionsReq);
+		return;
     }
 
     PELOG4(limLog(pMac, LOGE, FL("wpsPBCOverlap %d"), sapEvent.sapevt.sapGetWPSPBCSessionEvent.wpsPBCOverlap);)
@@ -3666,8 +3691,9 @@
     sapEvent.sapevt.sapGetWPSPBCSessionEvent.status = VOS_STATUS_SUCCESS;
 
 limGetWPSPBCSessionsEnd:
-    pSapEventCallback   = (tpWLAN_SAPEventCB)GetWPSPBCSessionsReq.pSapEventCallback;
-    pSapEventCallback(&sapEvent, GetWPSPBCSessionsReq.pUsrContext);
+    pSapEventCallback   = (tpWLAN_SAPEventCB)pGetWPSPBCSessionsReq->pSapEventCallback;
+    pSapEventCallback(&sapEvent, pGetWPSPBCSessionsReq->pUsrContext);
+	vos_mem_free(pGetWPSPBCSessionsReq);
 }
 
 
@@ -5068,11 +5094,7 @@
 #if defined(WLAN_VOWIFI_DEBUG) || defined(FEATURE_WLAN_ESE)
    PELOG1(limLog( pMac, LOG1, "%s:%d: Allocated memory for pMaxTxParams...will be freed in other module", __func__, __LINE__ );)
 #endif
-   if( pMaxTxParams == NULL )
-   {
-      limLog( pMac, LOGE, "%s:%d: pMaxTxParams is NULL", __func__, __LINE__);
-      return eSIR_FAILURE;
-   }
+
    pMaxTxParams->power = txPower;
    vos_mem_copy( pMaxTxParams->bssId, pSessionEntry->bssId, sizeof(tSirMacAddr) );
    vos_mem_copy( pMaxTxParams->selfStaMacAddr, pSessionEntry->selfMacAddr, sizeof(tSirMacAddr) );
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessTdls.c qcacld-new/CORE/MAC/src/pe/lim/limProcessTdls.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limProcessTdls.c	2016-05-16 10:58:07.618298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limProcessTdls.c	2016-05-16 10:58:08.934298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -1252,7 +1253,7 @@
             tSirMacAddr peerMac, tANI_U8 dialog, tpPESession psessionEntry,
             tANI_U8 *addIe, tANI_U16 addIeLen)
 {
-    tDot11fTDLSSetupReq    tdlsSetupReq ;
+    tDot11fTDLSSetupReq    *ptdlsSetupReq ;
     tANI_U16            caps = 0 ;
     tANI_U32            status = 0 ;
     tANI_U32            nPayload = 0 ;
@@ -1268,6 +1269,11 @@
 //  To support this feature, we need to introduce WNI_CFG_TDLS_CHANNEL_BONDING_MODE
 //  As of now, we hardcoded to max channel bonding of dot11Mode (i.e HT80 for 11ac/HT40 for 11n)
 //  uint32 tdlsChannelBondingMode;
+    if (!psessionEntry)
+    {
+        limLog( pMac, LOGE, FL("psessionEntry is NULL" ));
+        return eSIR_FAILURE;
+    }
 
     /*
      * The scheme here is to fill out a 'tDot11fProbeRequest' structure
@@ -1275,14 +1281,19 @@
      * serialization).  We start by zero-initializing the structure:
      */
     smeSessionId = psessionEntry->smeSessionId;
-
-    vos_mem_set(( tANI_U8* )&tdlsSetupReq, sizeof( tDot11fTDLSSetupReq ), 0);
-    tdlsSetupReq.Category.category = SIR_MAC_ACTION_TDLS ;
-    tdlsSetupReq.Action.action     = SIR_MAC_TDLS_SETUP_REQ ;
-    tdlsSetupReq.DialogToken.token = dialog ;
+    ptdlsSetupReq = (tDot11fTDLSSetupReq*) vos_mem_malloc(sizeof(tDot11fTDLSSetupReq));
+    if (!ptdlsSetupReq)
+    {
+        limLog( pMac, LOGE, FL("ptdlsSetupReq is NULL" ));
+        return eSIR_FAILURE;
+    }
+    vos_mem_set(( tANI_U8* )ptdlsSetupReq, sizeof( tDot11fTDLSSetupReq ), 0);
+    ptdlsSetupReq->Category.category = SIR_MAC_ACTION_TDLS ;
+    ptdlsSetupReq->Action.action     = SIR_MAC_TDLS_SETUP_REQ ;
+    ptdlsSetupReq->DialogToken.token = dialog ;
 
 
-    PopulateDot11fLinkIden( pMac, psessionEntry, &tdlsSetupReq.LinkIdentifier,
+    PopulateDot11fLinkIden( pMac, psessionEntry, &ptdlsSetupReq->LinkIdentifier,
                                                     peerMac, TDLS_INITIATOR) ;
 
     if (cfgGetCapabilityInfo(pMac, &caps, psessionEntry) != eSIR_SUCCESS)
@@ -1294,18 +1305,18 @@
          limLog(pMac, LOGP,
                    FL("could not retrieve Capabilities value"));
     }
-    swapBitField16(caps, ( tANI_U16* )&tdlsSetupReq.Capabilities );
+    swapBitField16(caps, ( tANI_U16* )&ptdlsSetupReq->Capabilities );
 
     /* populate supported rate IE */
     PopulateDot11fSuppRates( pMac, POPULATE_DOT11F_RATES_OPERATIONAL,
-                              &tdlsSetupReq.SuppRates, psessionEntry );
+                              &ptdlsSetupReq->SuppRates, psessionEntry );
 
     /* Populate extended supported rates */
     PopulateDot11fExtSuppRates( pMac, POPULATE_DOT11F_RATES_OPERATIONAL,
-                                &tdlsSetupReq.ExtSuppRates, psessionEntry );
+                                &ptdlsSetupReq->ExtSuppRates, psessionEntry );
 
     /* Populate extended supported rates */
-    PopulateDot11fTdlsExtCapability( pMac, &tdlsSetupReq.ExtCap );
+    PopulateDot11fTdlsExtCapability( pMac, &ptdlsSetupReq->ExtCap );
 
    /*
      * TODO: we need to see if we have to support conditions where we have
@@ -1316,13 +1327,13 @@
     /* Populate QOS info, needed for Peer U-APSD session */
     /* TODO: Now hardcoded, because PopulateDot11fQOSCapsStation() depends on AP's capability, and
     TDLS doesn't want to depend on AP's capability */
-    tdlsSetupReq.QOSCapsStation.present = 1;
-    tdlsSetupReq.QOSCapsStation.max_sp_length = 0;
-    tdlsSetupReq.QOSCapsStation.qack = 0;
-    tdlsSetupReq.QOSCapsStation.acbe_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x08) >> 3) ;
-    tdlsSetupReq.QOSCapsStation.acbk_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x04)>> 2);
-    tdlsSetupReq.QOSCapsStation.acvi_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x02)>> 1);
-    tdlsSetupReq.QOSCapsStation.acvo_uapsd = (pMac->lim.gLimTDLSUapsdMask & 0x01);
+    ptdlsSetupReq->QOSCapsStation.present = 1;
+    ptdlsSetupReq->QOSCapsStation.max_sp_length = 0;
+    ptdlsSetupReq->QOSCapsStation.qack = 0;
+    ptdlsSetupReq->QOSCapsStation.acbe_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x08) >> 3) ;
+    ptdlsSetupReq->QOSCapsStation.acbk_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x04)>> 2);
+    ptdlsSetupReq->QOSCapsStation.acvi_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x02)>> 1);
+    ptdlsSetupReq->QOSCapsStation.acvo_uapsd = (pMac->lim.gLimTDLSUapsdMask & 0x01);
 
     /*
      * we will always try to init TDLS link with 11n capabilities
@@ -1333,21 +1344,21 @@
     wlan_cfgGetInt(pMac,WNI_CFG_DOT11_MODE,&selfDot11Mode);
 
     /* Populate HT/VHT Capabilities */
-    PopulateDot11fTdlsHtVhtCap( pMac, selfDot11Mode, &tdlsSetupReq.HTCaps,
-                               &tdlsSetupReq.VHTCaps, psessionEntry );
+    PopulateDot11fTdlsHtVhtCap( pMac, selfDot11Mode, &ptdlsSetupReq->HTCaps,
+                               &ptdlsSetupReq->VHTCaps, psessionEntry );
 
     /* Populate AID */
     PopulateDotfTdlsVhtAID( pMac, selfDot11Mode, peerMac,
-                            &tdlsSetupReq.AID, psessionEntry );
+                            &ptdlsSetupReq->AID, psessionEntry );
 
     if ( 1 == pMac->lim.gLimTDLSOffChannelEnabled )
         PopulateDot11fTdlsOffchannelParams( pMac, psessionEntry,
-                                            &tdlsSetupReq.SuppChannels,
-                                            &tdlsSetupReq.SuppOperatingClasses);
+                                            &ptdlsSetupReq->SuppChannels,
+                                            &ptdlsSetupReq->SuppOperatingClasses);
     /*
      * now we pack it.  First, how much space are we going to need?
      */
-    status = dot11fGetPackedTDLSSetupReqSize( pMac, &tdlsSetupReq,
+    status = dot11fGetPackedTDLSSetupReqSize( pMac, ptdlsSetupReq,
                                                               &nPayload);
     if ( DOT11F_FAILED( status ) )
     {
@@ -1386,6 +1397,8 @@
     {
         limLog( pMac, LOGP, FL("Failed to allocate %d bytes for a TDLS"
                                "Discovery Request."), nBytes );
+        if (ptdlsSetupReq)
+            vos_mem_free(ptdlsSetupReq);
         return eSIR_MEM_ALLOC_FAILED;
     }
 
@@ -1400,23 +1413,23 @@
     /* fill out the buffer descriptor */
 
     header_offset = limPrepareTdlsFrameHeader(pMac, pFrame,
-                     LINK_IDEN_ADDR_OFFSET(tdlsSetupReq), TDLS_LINK_AP, TDLS_INITIATOR, TID_AC_BK, psessionEntry) ;
+                     &ptdlsSetupReq->LinkIdentifier, TDLS_LINK_AP, TDLS_INITIATOR, TID_AC_BK, psessionEntry) ;
 
 #ifdef FEATURE_WLAN_TDLS_NEGATIVE
     if(pMac->lim.gLimTdlsNegativeBehavior & LIM_TDLS_NEGATIVE_WRONG_BSSID_IN_SETUP_REQ)
     {
-        tdlsSetupReq.LinkIdentifier.bssid[4] = 0xde;
-        tdlsSetupReq.LinkIdentifier.bssid[5] = 0xad;
+        ptdlsSetupReq->LinkIdentifier.bssid[4] = 0xde;
+        ptdlsSetupReq->LinkIdentifier.bssid[5] = 0xad;
         VOS_TRACE(VOS_MODULE_ID_PE, VOS_TRACE_LEVEL_ERROR,
         ("TDLS negative running: wrong BSSID " MAC_ADDRESS_STR " in TDLS Setup Req"),
-         MAC_ADDR_ARRAY(tdlsSetupReq.LinkIdentifier.bssid));
+         MAC_ADDR_ARRAY(ptdlsSetupReq->LinkIdentifier.bssid));
     }
 #endif
     limLog( pMac, LOGW, FL("%s: SupportedChnlWidth %x rxMCSMap %x rxMCSMap %x txSupDataRate %x"),
-            __func__, tdlsSetupReq.VHTCaps.supportedChannelWidthSet, tdlsSetupReq.VHTCaps.rxMCSMap,
-            tdlsSetupReq.VHTCaps.txMCSMap, tdlsSetupReq.VHTCaps.txSupDataRate );
+            __func__, ptdlsSetupReq->VHTCaps.supportedChannelWidthSet, ptdlsSetupReq->VHTCaps.rxMCSMap,
+            ptdlsSetupReq->VHTCaps.txMCSMap, ptdlsSetupReq->VHTCaps.txSupDataRate );
 
-    status = dot11fPackTDLSSetupReq( pMac, &tdlsSetupReq, pFrame
+    status = dot11fPackTDLSSetupReq( pMac, ptdlsSetupReq, pFrame
                                + header_offset, nPayload, &nPayload );
 
     if ( DOT11F_FAILED( status ) )
@@ -1425,6 +1438,8 @@
                                "(0x%08x)."), status );
         palPktFree( pMac->hHdd, HAL_TXRX_FRM_802_11_MGMT,
                                    ( void* ) pFrame, ( void* ) pPacket );
+        if (ptdlsSetupReq)
+            vos_mem_free(ptdlsSetupReq);
         return eSIR_FAILURE;
     }
     else if ( DOT11F_WARNED( status ) )
@@ -1471,12 +1486,17 @@
     {
         pMac->lim.mgmtFrameSessionId = 0xff;
         limLog( pMac, LOGE, FL("could not send TDLS Dis Request frame!" ));
+        if (ptdlsSetupReq)
+            vos_mem_free(ptdlsSetupReq);
         return eSIR_FAILURE;
     }
 
+    if (ptdlsSetupReq)
+        vos_mem_free(ptdlsSetupReq);
     return eSIR_SUCCESS;
 
 }
+
 /*
  * Send TDLS Teardown frame on Direct link or AP link, depends on reason code.
  */
@@ -1702,7 +1722,7 @@
                     tSirMacAddr peerMac, tANI_U8 dialog, tpPESession psessionEntry,
                     etdlsLinkSetupStatus setupStatus, tANI_U8 *addIe, tANI_U16 addIeLen )
 {
-    tDot11fTDLSSetupRsp  tdlsSetupRsp ;
+    tDot11fTDLSSetupRsp  *ptdlsSetupRsp ;
     tANI_U32            status = 0 ;
     tANI_U16            caps = 0 ;
     tANI_U32            nPayload = 0 ;
@@ -1731,16 +1751,17 @@
      * and then hand it off to 'dot11fPackProbeRequest' (for
      * serialization).  We start by zero-initializing the structure:
      */
-    vos_mem_set( ( tANI_U8* )&tdlsSetupRsp, sizeof( tDot11fTDLSSetupRsp ),0 );
+    ptdlsSetupRsp = (tDot11fTDLSSetupRsp*) vos_mem_malloc(sizeof(tDot11fTDLSSetupRsp));
+    vos_mem_set( ( tANI_U8* )ptdlsSetupRsp, sizeof( tDot11fTDLSSetupRsp ),0 );
 
     /*
      * setup Fixed fields,
      */
-    tdlsSetupRsp.Category.category = SIR_MAC_ACTION_TDLS;
-    tdlsSetupRsp.Action.action     = SIR_MAC_TDLS_SETUP_RSP ;
-    tdlsSetupRsp.DialogToken.token = dialog;
+    ptdlsSetupRsp->Category.category = SIR_MAC_ACTION_TDLS;
+    ptdlsSetupRsp->Action.action     = SIR_MAC_TDLS_SETUP_RSP ;
+    ptdlsSetupRsp->DialogToken.token = dialog;
 
-    PopulateDot11fLinkIden( pMac, psessionEntry, &tdlsSetupRsp.LinkIdentifier,
+    PopulateDot11fLinkIden( pMac, psessionEntry, &ptdlsSetupRsp->LinkIdentifier,
                  peerMac, TDLS_RESPONDER) ;
 
     if (cfgGetCapabilityInfo(pMac, &caps, psessionEntry) != eSIR_SUCCESS)
@@ -1752,18 +1773,18 @@
          limLog(pMac, LOGP,
                    FL("could not retrieve Capabilities value"));
     }
-    swapBitField16(caps, ( tANI_U16* )&tdlsSetupRsp.Capabilities );
+    swapBitField16(caps, ( tANI_U16* )&ptdlsSetupRsp->Capabilities );
 
     /* ipopulate supported rate IE */
     PopulateDot11fSuppRates( pMac, POPULATE_DOT11F_RATES_OPERATIONAL,
-                                &tdlsSetupRsp.SuppRates, psessionEntry );
+                                &ptdlsSetupRsp->SuppRates, psessionEntry );
 
     /* Populate extended supported rates */
     PopulateDot11fExtSuppRates( pMac, POPULATE_DOT11F_RATES_OPERATIONAL,
-                                &tdlsSetupRsp.ExtSuppRates, psessionEntry );
+                                &ptdlsSetupRsp->ExtSuppRates, psessionEntry );
 
     /* Populate extended supported rates */
-    PopulateDot11fTdlsExtCapability( pMac, &tdlsSetupRsp.ExtCap );
+    PopulateDot11fTdlsExtCapability( pMac, &ptdlsSetupRsp->ExtCap );
 
     /*
      * TODO: we need to see if we have to support conditions where we have
@@ -1774,34 +1795,34 @@
     /* Populate QOS info, needed for Peer U-APSD session */
     /* TODO: Now hardcoded, because PopulateDot11fQOSCapsStation() depends on AP's capability, and
     TDLS doesn't want to depend on AP's capability */
-    tdlsSetupRsp.QOSCapsStation.present = 1;
-    tdlsSetupRsp.QOSCapsStation.max_sp_length = 0;
-    tdlsSetupRsp.QOSCapsStation.qack = 0;
-    tdlsSetupRsp.QOSCapsStation.acbe_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x08) >> 3);
-    tdlsSetupRsp.QOSCapsStation.acbk_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x04) >> 2);
-    tdlsSetupRsp.QOSCapsStation.acvi_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x02) >> 1);
-    tdlsSetupRsp.QOSCapsStation.acvo_uapsd = (pMac->lim.gLimTDLSUapsdMask & 0x01);
+    ptdlsSetupRsp->QOSCapsStation.present = 1;
+    ptdlsSetupRsp->QOSCapsStation.max_sp_length = 0;
+    ptdlsSetupRsp->QOSCapsStation.qack = 0;
+    ptdlsSetupRsp->QOSCapsStation.acbe_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x08) >> 3);
+    ptdlsSetupRsp->QOSCapsStation.acbk_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x04) >> 2);
+    ptdlsSetupRsp->QOSCapsStation.acvi_uapsd = ((pMac->lim.gLimTDLSUapsdMask & 0x02) >> 1);
+    ptdlsSetupRsp->QOSCapsStation.acvo_uapsd = (pMac->lim.gLimTDLSUapsdMask & 0x01);
 
     wlan_cfgGetInt(pMac,WNI_CFG_DOT11_MODE,&selfDot11Mode);
 
     /* Populate HT/VHT Capabilities */
-    PopulateDot11fTdlsHtVhtCap( pMac, selfDot11Mode, &tdlsSetupRsp.HTCaps,
-                                &tdlsSetupRsp.VHTCaps, psessionEntry );
+    PopulateDot11fTdlsHtVhtCap( pMac, selfDot11Mode, &ptdlsSetupRsp->HTCaps,
+                                &ptdlsSetupRsp->VHTCaps, psessionEntry );
 
     /* Populate AID */
     PopulateDotfTdlsVhtAID( pMac, selfDot11Mode, peerMac,
-                            &tdlsSetupRsp.AID, psessionEntry );
+                            &ptdlsSetupRsp->AID, psessionEntry );
 
     if ( 1 == pMac->lim.gLimTDLSOffChannelEnabled )
         PopulateDot11fTdlsOffchannelParams( pMac, psessionEntry,
-                                            &tdlsSetupRsp.SuppChannels,
-                                            &tdlsSetupRsp.SuppOperatingClasses);
-    tdlsSetupRsp.Status.status = setupStatus ;
+                                            &ptdlsSetupRsp->SuppChannels,
+                                            &ptdlsSetupRsp->SuppOperatingClasses);
+    ptdlsSetupRsp->Status.status = setupStatus ;
 
     /*
      * now we pack it.  First, how much space are we going to need?
      */
-    status = dot11fGetPackedTDLSSetupRspSize( pMac, &tdlsSetupRsp,
+    status = dot11fGetPackedTDLSSetupRspSize( pMac, ptdlsSetupRsp,
                                                      &nPayload);
     if ( DOT11F_FAILED( status ) )
     {
@@ -1839,6 +1860,9 @@
     {
         limLog( pMac, LOGP, FL("Failed to allocate %d bytes for a TDLS"
                                "Discovery Request."), nBytes );
+        if (ptdlsSetupRsp)
+            vos_mem_free(ptdlsSetupRsp);
+
         return eSIR_MEM_ALLOC_FAILED;
     }
 
@@ -1853,24 +1877,24 @@
     /* fill out the buffer descriptor */
 
     header_offset = limPrepareTdlsFrameHeader(pMac, pFrame,
-                                 LINK_IDEN_ADDR_OFFSET(tdlsSetupRsp),
+                                       &ptdlsSetupRsp->LinkIdentifier,
                                        TDLS_LINK_AP, TDLS_RESPONDER,
                                        TID_AC_BK, psessionEntry) ;
 
 #ifdef FEATURE_WLAN_TDLS_NEGATIVE
     if(pMac->lim.gLimTdlsNegativeBehavior & LIM_TDLS_NEGATIVE_WRONG_BSSID_IN_SETUP_RSP)
     {
-        tdlsSetupRsp.LinkIdentifier.bssid[4] = 0xde;
-        tdlsSetupRsp.LinkIdentifier.bssid[5] = 0xad;
+        ptdlsSetupRsp->LinkIdentifier.bssid[4] = 0xde;
+        ptdlsSetupRsp->LinkIdentifier.bssid[5] = 0xad;
         VOS_TRACE(VOS_MODULE_ID_PE, VOS_TRACE_LEVEL_ERROR,
         ("TDLS negative running: wrong BSSID " MAC_ADDRESS_STR " in TDLS Setup Rsp"),
-         MAC_ADDR_ARRAY(tdlsSetupRsp.LinkIdentifier.bssid));
+         MAC_ADDR_ARRAY(ptdlsSetupRsp->LinkIdentifier.bssid));
     }
 #endif
     limLog( pMac, LOGW, FL("%s: SupportedChnlWidth %x rxMCSMap %x rxMCSMap %x txSupDataRate %x"),
-            __func__, tdlsSetupRsp.VHTCaps.supportedChannelWidthSet, tdlsSetupRsp.VHTCaps.rxMCSMap,
-            tdlsSetupRsp.VHTCaps.txMCSMap, tdlsSetupRsp.VHTCaps.txSupDataRate );
-    status = dot11fPackTDLSSetupRsp( pMac, &tdlsSetupRsp, pFrame
+            __func__, ptdlsSetupRsp->VHTCaps.supportedChannelWidthSet, ptdlsSetupRsp->VHTCaps.rxMCSMap,
+            ptdlsSetupRsp->VHTCaps.txMCSMap, ptdlsSetupRsp->VHTCaps.txSupDataRate );
+    status = dot11fPackTDLSSetupRsp( pMac, ptdlsSetupRsp, pFrame
                                + header_offset, nPayload, &nPayload );
 
     if ( DOT11F_FAILED( status ) )
@@ -1879,6 +1903,8 @@
                                "(0x%08x)."), status );
         palPktFree( pMac->hHdd, HAL_TXRX_FRM_802_11_MGMT,
                                    ( void* ) pFrame, ( void* ) pPacket );
+        if (ptdlsSetupRsp)
+            vos_mem_free(ptdlsSetupRsp);
         return eSIR_FAILURE;
     }
     else if ( DOT11F_WARNED( status ) )
@@ -1925,9 +1951,12 @@
     {
         pMac->lim.mgmtFrameSessionId = 0xff;
         limLog( pMac, LOGE, FL("could not send TDLS Dis Request frame!" ));
+        if (ptdlsSetupRsp)
+            vos_mem_free(ptdlsSetupRsp);
         return eSIR_FAILURE;
     }
-
+    if (ptdlsSetupRsp)
+        vos_mem_free(ptdlsSetupRsp);
     return eSIR_SUCCESS;
 
 }
@@ -2736,6 +2765,7 @@
     tpDphHashNode pSessStaDs = NULL;
     tANI_U16 aid;
 
+    memset(&htCap, 0, sizeof(htCap));
     if (pTdlsAddStaReq->tdlsAddOper == TDLS_OPER_ADD)
     {
         PopulateDot11fHTCaps(pMac, psessionEntry, &htCap);
@@ -5518,7 +5548,7 @@
         return eSIR_MEM_ALLOC_FAILED;
     }
 
-    vos_mem_set( (tANI_U8 *)pMsgTdlsLinkEstablishReq, sizeof(tpTdlsLinkEstablishParams), 0);
+    vos_mem_set( (tANI_U8 *)pMsgTdlsLinkEstablishReq, sizeof(tTdlsLinkEstablishParams), 0);
 
     pMsgTdlsLinkEstablishReq->staIdx = pStaDs->staIndex;
     pMsgTdlsLinkEstablishReq->isResponder = pTdlsLinkEstablishReq->isResponder;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limScanResultUtils.c qcacld-new/CORE/MAC/src/pe/lim/limScanResultUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limScanResultUtils.c	2016-05-16 10:58:07.618298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limScanResultUtils.c	2016-05-16 10:58:08.934298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limScanResultUtils.cc contains the utility functions
@@ -422,8 +423,12 @@
            ( pMac->lim.gLimReturnAfterFirstMatch & 0x01 ) &&
            (pMac->lim.gpLimMlmScanReq->numSsid) &&
            !limIsScanRequestedSSID(pMac, &pBPR->ssId)) ||
+#ifdef CONFIG_VD_PREVENT_NO_EFFECT
+          (!fFound && pMac->lim.gpLimMlmScanReq &&
+#else
           (!fFound && (pMac->lim.gpLimMlmScanReq &&
                        pMac->lim.gpLimMlmScanReq->bssId) &&
+#endif
            !vos_mem_compare(bssid,
                            &pMac->lim.gpLimMlmScanReq->bssId, 6))))
     {
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2016-05-16 10:58:07.610298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limSendSmeRspMessages.c	2016-05-16 10:58:08.934298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limSendSmeRspMessages.cc contains the functions
@@ -2915,6 +2916,10 @@
 
    pStaDs = dphLookupHashEntry(pMac, psessionEntry->bssId, &aid,
                                       &psessionEntry->dph.dphHashTable);
+   if (NULL == pStaDs) {
+          limLog(pMac, LOGE, FL("pStaDs is NULL"));
+          goto err;
+    }
 
    if (psessionEntry->limSystemRole == eLIM_STA_ROLE)
    {
@@ -2955,7 +2960,7 @@
                                                  psessionEntry,
                                                  csa_params->channel,
                                                  csa_params->new_ch_width);
-          if (psessionEntry->gLimChannelSwitch.secondarySubBand) {
+          if (psessionEntry->gLimChannelSwitch.secondarySubBand > 0) {
               psessionEntry->gLimChannelSwitch.state =
                                      eLIM_CHANNEL_SWITCH_PRIMARY_AND_SECONDARY;
           }
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limSerDesUtils.c qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limSerDesUtils.c	2016-05-16 10:58:07.610298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limSerDesUtils.c	2016-05-16 10:58:08.934298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -287,6 +288,7 @@
                        pBuf,
                        len);
     }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     else if (len < 0)
     {
         limLog(pMac, LOGE,
@@ -294,6 +296,7 @@
                      len, pBssDescription->length);
         return eSIR_FAILURE;
     }
+#endif
 
     return eSIR_SUCCESS;
 } /*** end limGetBssDescription() ***/
@@ -2468,14 +2471,14 @@
         return eSIR_FAILURE;
 
     // Extract pUsrContext
-    vos_mem_copy((tANI_U8 *)pGetAssocSTAsReq->pUsrContext, pBuf, sizeof(void*));
+    pGetAssocSTAsReq->pUsrContext = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
         return eSIR_FAILURE;
 
     // Extract pSapEventCallback
-    vos_mem_copy((tANI_U8 *)pGetAssocSTAsReq->pSapEventCallback, pBuf, sizeof(void*));
+    pGetAssocSTAsReq->pSapEventCallback = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
@@ -2621,14 +2624,14 @@
         return eSIR_FAILURE;
 
    // Extract pUsrContext
-    vos_mem_copy((tANI_U8 *)pGetWPSPBCSessionsReq->pUsrContext, pBuf, sizeof(void*));
+    pGetWPSPBCSessionsReq->pUsrContext = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
         return eSIR_FAILURE;
 
     // Extract pSapEventCallback
-    vos_mem_copy((tANI_U8 *)pGetWPSPBCSessionsReq->pSapEventCallback, pBuf, sizeof(void*));
+    pGetWPSPBCSessionsReq->pSapEventCallback = (void *)pBuf;
     pBuf += sizeof(void*);
     len  -= sizeof(void*);
     if (limCheckRemainingLength(pMac, len) == eSIR_FAILURE)
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limTimerUtils.c qcacld-new/CORE/MAC/src/pe/lim/limTimerUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limTimerUtils.c	2016-05-16 10:58:07.602298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limTimerUtils.c	2016-05-16 10:58:08.930298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limTimerUtils.cc contains the utility functions
@@ -151,6 +152,11 @@
     }
     cfgValue = SYS_MS_TO_TICKS(cfgValue);
 
+    /* add this check for avoid code scan warning */
+    if (!cfgValue1) {
+        cfgValue1 = 1;
+    }
+
     /* Limiting max numm of probe req for each channel scan */
     pMac->lim.maxProbe = (cfgValue/cfgValue1);
 
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limTypes.h qcacld-new/CORE/MAC/src/pe/lim/limTypes.h
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limTypes.h	2016-05-16 10:58:07.618298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limTypes.h	2016-05-16 10:58:08.934298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2012-2013 Qualcomm Atheros, Inc.
@@ -683,6 +684,8 @@
 void limSendNullDataFrame(tpAniSirGlobal, tpDphHashNode);
 void limSendDisassocMgmtFrame(tpAniSirGlobal, tANI_U16, tSirMacAddr, tpPESession, tANI_BOOLEAN waitForAck);
 void limSendDeauthMgmtFrame(tpAniSirGlobal, tANI_U16, tSirMacAddr, tpPESession, tANI_BOOLEAN waitForAck);
+void limSendSmeDisassocDeauthNtf(tpAniSirGlobal pMac, eHalStatus status,
+                                 tANI_U32 *pCtx);
 
 void limContinueChannelScan(tpAniSirGlobal);
 tSirResultCodes limMlmAddBss(tpAniSirGlobal, tLimMlmStartReq *,tpPESession psessionEntry);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c qcacld-new/CORE/MAC/src/pe/lim/limUtils.c
--- qcacld-new.orig/CORE/MAC/src/pe/lim/limUtils.c	2016-05-16 10:58:07.642298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/lim/limUtils.c	2016-05-16 10:58:08.950298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file limUtils.cc contains the utility functions
@@ -5903,8 +5904,7 @@
   // Requesting the ADDBA recipient to populate the size.
   // If ADDBA is accepted, a non-zero buffer size should
   // be returned in the ADDBA Rsp
-  if ((TRUE == psessionEntry->isCiscoVendorAP) &&
-        (eHT_CHANNEL_WIDTH_80MHZ != pStaDs->htSupportedChannelWidthSet))
+  if (TRUE == psessionEntry->isCiscoVendorAP)
   {
      /* Cisco AP has issues in receiving more than 25 "mpdu in ampdu"
         causing very low throughput in HT40 case */
@@ -7554,7 +7554,7 @@
         {
             limLog( pMac, LOGE,
                FL("****Invalid IEs eid = %d elem_len=%d left=%d*****"),
-                                               elem_id,elem_len,left);
+								   elem_id,elem_len,left);
             return NULL;
         }
         if (SIR_MAC_EID_VENDOR == elem_id)
@@ -8057,6 +8057,7 @@
     v_U8_t              *p_ie=NULL;
     tDot11fIEHTCaps     dot11_ht_cap;
 
+    vos_mem_set(&dot11_ht_cap, sizeof(tDot11fIEHTCaps), 0);
     PopulateDot11fHTCaps(p_mac, p_session_entry, &dot11_ht_cap);
     p_ie = limGetIEPtr(p_mac, p_ie_start, num_bytes, DOT11F_EID_HTCAPS,
                                                     ONE_BYTE);
diff -urN qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmAP.c qcacld-new/CORE/MAC/src/pe/pmm/pmmAP.c
--- qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmAP.c	2016-05-16 10:58:07.554298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/pmm/pmmAP.c	2016-05-16 10:58:08.906298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  *
@@ -77,7 +78,6 @@
     // Generate partial virtual bitmap
     tANI_U8 N1 = minAid / 8;
     tANI_U8 N2 = maxAid / 8;
-    if (N1 & 1) N1--;
 
     *timLength = N2 - N1 + 4;
     val = dtimPeriod;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmApi.c qcacld-new/CORE/MAC/src/pe/pmm/pmmApi.c
--- qcacld-new.orig/CORE/MAC/src/pe/pmm/pmmApi.c	2016-05-16 10:58:07.554298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/pmm/pmmApi.c	2016-05-16 10:58:08.906298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file pmmApi.cc contains functions related to the API exposed
@@ -2033,12 +2034,6 @@
     }
     (void) vos_mem_copy(pBcastPtrn, pMbMsg->data, sizeof(*pBcastPtrn));
 
-    if (NULL == pBcastPtrn)
-    {
-        pmmLog(pMac, LOGE, FL("Add broadcast pattern message is NULL "));
-        return;
-    }
-
     msgQ.type = WDA_WOWL_ADD_BCAST_PTRN;
     msgQ.reserved = 0;
     msgQ.bodyptr = pBcastPtrn;
@@ -2081,12 +2076,6 @@
     }
     (void) vos_mem_copy(pDeletePtrn, pMbMsg->data, sizeof(*pDeletePtrn));
 
-    if (NULL == pDeletePtrn)
-    {
-        pmmLog(pMac, LOGE, FL("Delete broadcast pattern message is NULL "));
-        return;
-    }
-
     msgQ.type = WDA_WOWL_DEL_BCAST_PTRN;
     msgQ.reserved = 0;
     msgQ.bodyptr = pDeletePtrn;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/rrm/rrmApi.c qcacld-new/CORE/MAC/src/pe/rrm/rrmApi.c
--- qcacld-new.orig/CORE/MAC/src/pe/rrm/rrmApi.c	2016-05-16 10:58:07.570298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/rrm/rrmApi.c	2016-05-16 10:58:08.906298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -637,7 +638,11 @@
    mmhMsg.type    = eWNI_SME_BEACON_REPORT_REQ_IND;
    mmhMsg.bodyptr = pSmeBcnReportReq;
    MTRACE(macTraceMsgTx(pMac, pSessionEntry->peSessionId, mmhMsg.type));
-   return limSysProcessMmhMsgApi(pMac, &mmhMsg, ePROT);
+
+   /* Fix enum type mixing defect, return success since
+      limSysProcessMmhMsgApi always return success now. */
+   limSysProcessMmhMsgApi(pMac, &mmhMsg, ePROT);
+   return eRRM_SUCCESS;
 }
 
 // --------------------------------------------------------------------
diff -urN qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconGen.c qcacld-new/CORE/MAC/src/pe/sch/schBeaconGen.c
--- qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconGen.c	2016-05-16 10:58:07.562298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/sch/schBeaconGen.c	2016-05-16 10:58:08.906298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file schBeaconGen.cc contains beacon generation related
@@ -773,7 +774,7 @@
         size = (size + 3) & (~3);
         if( eSIR_SUCCESS != schSendBeaconReq( pMac, psessionEntry->pSchBeaconFrameBegin,
                                               size, psessionEntry))
-            PELOGE(schLog(pMac, LOGE, FL("schSendBeaconReq() returned an error (zsize %d)"), size);)
+            schLog(pMac, LOGE, FL("schSendBeaconReq() returned an error (zsize %d)"), size);
         else
         {
             pMac->sch.gSchBeaconsWritten++;
diff -urN qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconProcess.c qcacld-new/CORE/MAC/src/pe/sch/schBeaconProcess.c
--- qcacld-new.orig/CORE/MAC/src/pe/sch/schBeaconProcess.c	2016-05-16 10:58:07.562298648 +0800
+++ qcacld-new/CORE/MAC/src/pe/sch/schBeaconProcess.c	2016-05-16 10:58:08.906298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file schBeaconProcess.cc contains beacon processing related
@@ -433,7 +434,7 @@
             if(pBeacon->edcaParams.qosInfo.count != psessionEntry->gLimEdcaParamSetCount)
             {
                 if (schBeaconEdcaProcess(pMac, &pBeacon->edcaParams, psessionEntry) != eSIR_SUCCESS)
-                    PELOGE(schLog(pMac, LOGE, FL("EDCA parameter processing error"));)
+                    schLog(pMac, LOGE, FL("EDCA parameter processing error"));
                 else if(pStaDs != NULL)
                 {
                     // If needed, downgrade the EDCA parameters
diff -urN qcacld-new.orig/CORE/SAP/src/sapApiLinkCntl.c qcacld-new/CORE/SAP/src/sapApiLinkCntl.c
--- qcacld-new.orig/CORE/SAP/src/sapApiLinkCntl.c	2016-05-16 10:58:06.502298648 +0800
+++ qcacld-new/CORE/SAP/src/sapApiLinkCntl.c	2016-05-16 10:58:08.738298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -140,8 +141,8 @@
     VOS_STATUS sapstatus;
 #ifdef SOFTAP_CHANNEL_RANGE
     v_U32_t operatingBand;
-    v_U32_t event;
 #endif
+    v_U32_t event = eSAP_CHANNEL_SELECTION_FAILED;
 
     /*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
     VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_INFO_HIGH, "In %s, before switch on scanStatus = %d", __func__, scanStatus);
@@ -589,7 +590,7 @@
             VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_INFO_HIGH, "In %s, CSR roamResult = %s (%d)\n",
                        __func__, "eCSR_ROAM_RESULT_AUTHENTICATED", roamResult);
             /* Fill in the event structure */
-            sapSignalHDDevent( sapContext, pCsrRoamInfo,eSAP_STA_SET_KEY_EVENT, (v_PVOID_t)eSAP_STATUS_SUCCESS);
+            vosStatus = sapSignalHDDevent( sapContext, pCsrRoamInfo,eSAP_STA_SET_KEY_EVENT, (v_PVOID_t)eSAP_STATUS_SUCCESS);
             if(!VOS_IS_STATUS_SUCCESS(vosStatus))
             {
                 halStatus = eHAL_STATUS_FAILURE;
diff -urN qcacld-new.orig/CORE/SAP/src/sapChSelect.c qcacld-new/CORE/SAP/src/sapChSelect.c
--- qcacld-new.orig/CORE/SAP/src/sapChSelect.c	2016-05-16 10:58:06.502298648 +0800
+++ qcacld-new/CORE/SAP/src/sapChSelect.c	2016-05-16 10:58:08.738298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -1551,7 +1552,9 @@
         vhtSupport = 0;
         centerFreq = 0;
 
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         if (pScanResult->BssDescriptor.ieFields != NULL)
+#endif		
         {
             ieLen = (pScanResult->BssDescriptor.length + sizeof(tANI_U16) + sizeof(tANI_U32) - sizeof(tSirBssDescription));
             vos_mem_set((tANI_U8 *) pBeaconStruct, sizeof(tSirProbeRespBeacon), 0);
diff -urN qcacld-new.orig/CORE/SAP/src/sapFsm.c qcacld-new/CORE/SAP/src/sapFsm.c
--- qcacld-new.orig/CORE/SAP/src/sapFsm.c	2016-05-16 10:58:06.494298648 +0800
+++ qcacld-new/CORE/SAP/src/sapFsm.c	2016-05-16 10:58:08.738298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -1596,6 +1597,34 @@
                 /* Perform sme_ScanRequest */
                 vosStatus = sapGotoChannelSel(sapContext, sapEvent);
             }
+            else if (msg == eSAP_MAC_READY_FOR_CONNECTIONS)
+            {
+                /* Close the SME session*/
+                if (eSAP_TRUE == sapContext->isSapSessionOpen)
+                {
+                    tHalHandle hHal = VOS_GET_HAL_CB(sapContext->pvosGCtx);
+
+                    if (NULL == hHal)
+                    {
+                        VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_ERROR,
+                                   "In %s, NULL hHal in state %s, msg %d",
+                                   __func__, "eSAP_DISCONNECTED", msg);
+                    }
+                    else
+                    {
+                        sapContext->isSapSessionOpen = eSAP_FALSE;
+                        if (!HAL_STATUS_SUCCESS(
+                            sap_CloseSession(hHal,
+                                     sapContext,
+                                     sapRoamSessionCloseCallback, TRUE)))
+                        {
+                            vosStatus = sapSignalHDDevent(sapContext, NULL,
+                                              eSAP_STOP_BSS_EVENT,
+                                              (v_PVOID_t) eSAP_STATUS_SUCCESS);
+                        }
+                    }
+                }
+            }
             else
             {
                  VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_ERROR, "In %s, in state %s, event msg %d",
@@ -1868,12 +1897,12 @@
                  VOS_TRACE( VOS_MODULE_ID_SAP, VOS_TRACE_LEVEL_ERROR, "In %s, from state %s => %s",
                             __func__, "eSAP_STARTING", "eSAP_DISCONNECTED");
 
+                 /*Advance outer statevar */
+                 sapContext->sapsMachine = eSAP_DISCONNECTED;
+
                  /*Action code for transition */
                  vosStatus = sapSignalHDDevent( sapContext, NULL, eSAP_START_BSS_EVENT,(v_PVOID_t) eSAP_STATUS_FAILURE);
                  vosStatus =  sapGotoDisconnected(sapContext);
-
-                 /*Advance outer statevar */
-                 sapContext->sapsMachine = eSAP_DISCONNECTED;
              }
              else if (msg == eSAP_HDD_STOP_INFRA_BSS)
              {
diff -urN qcacld-new.orig/CORE/SAP/src/sapModule.c qcacld-new/CORE/SAP/src/sapModule.c
--- qcacld-new.orig/CORE/SAP/src/sapModule.c	2016-05-16 10:58:06.502298648 +0800
+++ qcacld-new/CORE/SAP/src/sapModule.c	2016-05-16 10:58:08.738298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -158,7 +159,11 @@
 #else
     if (NULL == pvosGCtx)
     {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+       VOS_ASSERT_VD(pvosGCtx);
+#else
        VOS_ASSERT(pvosGCtx);
+#endif
        return VOS_STATUS_E_FAULT;
     }
     /*------------------------------------------------------------------------
@@ -1174,7 +1179,9 @@
         return VOS_STATUS_E_RESOURCES;
     }
 
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     if (pSapCtx->denyMacList != NULL)
+#endif
     {
         for (i = 0; i < (pSapCtx->nDenyMac-1); i++)
         {
@@ -1184,8 +1191,9 @@
     }
     sapPrintACL(pSapCtx->denyMacList, pSapCtx->nDenyMac);
     pSapCtx->nDenyMac  = 0;
-
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
     if (pSapCtx->acceptMacList!=NULL)
+#endif
     {
         for (i = 0; i < (pSapCtx->nAcceptMac-1); i++)
         {
diff -urN qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c qcacld-new/CORE/SERVICES/BMI/ol_fw.c
--- qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/BMI/ol_fw.c	2016-05-16 10:58:08.822298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <linux/firmware.h>
 #include "ol_if_athvar.h"
@@ -42,7 +43,7 @@
 #include "if_ath_sdio.h"
 #include "regtable.h"
 #endif
-
+#include "wlan_hdd_main.h"
 
 #define ATH_MODULE_NAME bmi
 #include "a_debug.h"
@@ -395,7 +396,7 @@
 
 	switch (file) {
 	default:
-		printk("%s: Unknown file type\n", __func__);
+		printk(KERN_ERR "%s: Unknown file type\n", __func__);
 		return -1;
 	case ATH_OTP_FILE:
 #if defined(CONFIG_CNSS) || defined(HIF_SDIO)
@@ -439,7 +440,7 @@
 #endif
 		break;
 	case ATH_PATCH_FILE:
-		printk("%s: no Patch file defined\n", __func__);
+		printk(KERN_ERR "%s: no Patch file defined\n", __func__);
 		return EOK;
 	case ATH_BOARD_DATA_FILE:
 #ifdef QCA_WIFI_FTM
@@ -470,7 +471,7 @@
 		if (vos_get_conparam() != VOS_FTM_MODE &&
 		   !WLAN_IS_EPPING_ENABLED(vos_get_conparam())) {
 #ifdef CONFIG_CNSS
-			printk("%s: no Setup file defined\n", __func__);
+			printk(KERN_ERR "%s: no Setup file defined\n", __func__);
 			return -1;
 #else
 #ifdef HIF_SDIO
@@ -485,7 +486,7 @@
 					__func__, filename);
 #endif /* CONFIG_CNSS */
 		} else {
-			printk("%s: no Setup file needed\n", __func__);
+			printk(KERN_ERR "%s: no Setup file needed\n", __func__);
 			return -1;
 		}
 		break;
@@ -493,7 +494,7 @@
 
 	if (request_firmware(&fw_entry, filename, scn->sc_osdev->device) != 0)
 	{
-		printk("%s: Failed to get %s\n", __func__, filename);
+		printk(KERN_ERR "%s: Failed to get %s\n", __func__, filename);
 
 		if (file == ATH_OTP_FILE)
 			return -ENOENT;
@@ -503,11 +504,11 @@
 		 * board data file is not present. */
 		if (filename == scn->fw_files.utf_board_data) {
 			filename = scn->fw_files.board_data;
-			printk("%s: Trying to load default %s\n",
+			printk(KERN_ERR "%s: Trying to load default %s\n",
 				__func__, filename);
 			if (request_firmware(&fw_entry, filename,
 				scn->sc_osdev->device) != 0) {
-				printk("%s: Failed to get %s\n",
+				printk(KERN_ERR "%s: Failed to get %s\n",
 					__func__, filename);
 				return -1;
 			}
@@ -520,7 +521,7 @@
 	}
 
         if (!fw_entry || !fw_entry->data) {
-               printk("Invalid fw_entries\n");
+               printk(KERN_ERR "Invalid fw_entries\n");
                return A_ERROR;
         }
 
@@ -534,7 +535,7 @@
 
 		tempEeprom = OS_MALLOC(scn->sc_osdev, fw_entry_size, GFP_ATOMIC);
 		if (!tempEeprom) {
-			printk("%s: Memory allocation failed\n", __func__);
+			printk(KERN_ERR "%s: Memory allocation failed\n", __func__);
 			release_firmware(fw_entry);
 			return A_ERROR;
 		}
@@ -549,6 +550,10 @@
 		case TARGET_TYPE_AR6004:
 			board_data_size =  AR6004_BOARD_DATA_SZ;
 			board_ext_data_size = AR6004_BOARD_EXT_DATA_SZ;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+            break;
+#endif
+
 		case TARGET_TYPE_AR9888:
 			board_data_size =  AR9888_BOARD_DATA_SZ;
 			board_ext_data_size = AR9888_BOARD_EXT_DATA_SZ;
@@ -559,7 +564,7 @@
 		BMIReadMemory(scn->hif_hdl,
 				HOST_INTEREST_ITEM_ADDRESS(scn->target_type, hi_board_ext_data),
 				(u_int8_t *)&board_ext_address, 4, scn);
-		printk("Board extended Data download address: 0x%x\n", board_ext_address);
+		printk(KERN_INFO "Board extended Data download address: 0x%x\n", board_ext_address);
 
 		/*
 		 * Check whether the target has allocated memory for extended board
@@ -685,17 +690,22 @@
 	}
 
 	if (status != EOK) {
-		printk("%s, BMI operation failed: %d\n", __func__, __LINE__);
+		printk(KERN_ERR "%s, BMI operation failed: %d\n", __func__, __LINE__);
 		release_firmware(fw_entry);
 		return A_ERROR;
 	}
 
 	release_firmware(fw_entry);
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+		"%s: transferring file: %s size %d bytes done!", __func__,
+		filename, fw_entry_size);
+#else
 	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
 		"%s: transferring file: %s size %d bytes done!", __func__,
 		(filename!=NULL)?filename:"", fw_entry_size);
-
+#endif
 	return status;
 }
 
@@ -931,6 +941,8 @@
 A_UINT32 fw_stack_addr;
 void *fw_ram_seg_addr[FW_RAM_SEG_CNT];
 
+
+
 /* ol_ramdump_handler is to receive information of firmware crash dump, and
  * save it in host memory. It consists of 5 parts: registers, call stack,
  * DRAM dump, IRAM dump, and AXI dump, and they are reported to host in order.
@@ -965,11 +977,11 @@
 		SIId = (scn->target_fw_version & 0xf00000) >> 20;
 		CRMId = scn->target_fw_version & 0x7fff;
 		pr_err("Firmware crash detected...\n");
-		pr_err("Host SW version: %s\n", QWLAN_VERSIONSTR);
+		pr_err("Host SW version: %s\n", hdd_get_version_string());
 		pr_err("FW version: %d.%d.%d.%d", MSPId, mSPId, SIId, CRMId);
 
 		if (vos_is_load_unload_in_progress(VOS_MODULE_ID_VOSS, NULL)) {
-			printk("%s: Loading/Unloading is in progress, ignore!\n",
+			printk(KERN_INFO "%s: Loading/Unloading is in progress, ignore!\n",
 				__func__);
 			return;
 		}
@@ -2330,4 +2342,4 @@
 
 	return status;
 }
-#endif
+#endif
\ No newline at end of file
diff -urN qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.h qcacld-new/CORE/SERVICES/BMI/ol_fw.h
--- qcacld-new.orig/CORE/SERVICES/BMI/ol_fw.h	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/BMI/ol_fw.h	2016-05-16 10:58:08.822298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -31,6 +32,7 @@
 #ifdef QCA_WIFI_FTM
 #include "vos_types.h"
 #endif
+#include "ol_if_athvar.h"
 
 #define AR6004_VERSION_REV1_3        0x31c8088a
 
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_nbuf.c qcacld-new/CORE/SERVICES/COMMON/adf/adf_nbuf.c
--- qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_nbuf.c	2016-05-16 10:58:06.782298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/adf/adf_nbuf.c	2016-05-16 10:58:08.754298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 #include <linux/kernel.h>
@@ -93,6 +94,7 @@
      */
     skb_reserve(skb, reserve);
 
+
     return skb;
 }
 
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_mem.h qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_mem.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_mem.h	2016-05-16 10:58:06.790298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_mem.h	2016-05-16 10:58:08.754298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -44,6 +45,10 @@
 #endif
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_memory.h>
+#endif
+
 /**
  * @brief Allocate a memory buffer. Note this call can block.
  *
@@ -54,17 +59,24 @@
 static inline void *
 adf_os_mem_alloc(adf_os_device_t osdev, adf_os_size_t size)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     void *p_mem;
 #endif
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        p_mem = wcnss_prealloc_get(size);
        if (NULL != p_mem)
            return p_mem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		p_mem = vos_prealloc_get(size);
+		if (NULL != p_mem)
+			return p_mem;
+	}
 #endif
 
     return __adf_os_mem_alloc(osdev, size);
@@ -81,11 +93,16 @@
 static inline void
 adf_os_mem_free(void *buf)
 {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if (wcnss_prealloc_put(buf))
     {
         return;
     }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (vos_prealloc_put(buf))
+	{
+		return;
+	}
 #endif
 
     __adf_os_mem_free(buf);
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_time.h qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_time.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/adf/adf_os_time.h	2016-05-16 10:58:06.782298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/adf/adf_os_time.h	2016-05-16 10:58:08.754298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -151,7 +152,7 @@
 
    return (((a_uint64_t)ts.tv_sec * 1000000) + (ts.tv_nsec / 1000));
 #else
-   return adf_os_ticks_to_msecs(adf_os_ticks()) * 1000;
+   return ((a_uint64_t)adf_os_ticks_to_msecs(adf_os_ticks())) * 1000;
 #endif /* CONFIG_CNSS */
 }
 #endif
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/dbglog.h qcacld-new/CORE/SERVICES/COMMON/dbglog.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/dbglog.h	2016-05-16 10:58:07.362298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/dbglog.h	2016-05-16 10:58:08.774298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/dbglog_host.h	2016-05-16 10:58:06.790298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/dbglog_host.h	2016-05-16 10:58:08.754298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/hif.h qcacld-new/CORE/SERVICES/COMMON/hif.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/hif.h	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/hif.h	2016-05-16 10:58:08.774298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h qcacld-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h	2016-05-16 10:58:06.854298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/ol_txrx_ctrl_api.h	2016-05-16 10:58:08.766298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -661,6 +662,11 @@
 ol_txrx_get_tx_pending(
     ol_txrx_pdev_handle pdev);
 
+void ol_txrx_dump_tx_desc(ol_txrx_pdev_handle pdev);
+
+#if defined(CONFIG_HL_SUPPORT)
+int ol_txrx_get_tx_pending_hl( struct ol_txrx_pdev_t* pdev);
+#endif
 /**
  * @brief Discard all tx frames that are pending in txrx.
  * @details
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/osapi_linux.h qcacld-new/CORE/SERVICES/COMMON/osapi_linux.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/osapi_linux.h	2016-05-16 10:58:06.862298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/osapi_linux.h	2016-05-16 10:58:08.766298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/queue.h qcacld-new/CORE/SERVICES/COMMON/queue.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/queue.h	2016-05-16 10:58:06.862298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/queue.h	2016-05-16 10:58:08.766298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -130,31 +131,50 @@
  * _REMOVE          +   +   +   +
  *
  */
-#define QUEUE_MACRO_DEBUG 0
+#define    QUEUE_MACRO_DEBUG 0
 #if QUEUE_MACRO_DEBUG
-/* Store the last 2 places the queue element or head was altered */
-struct qm_trace {
-    char * lastfile;
-    int lastline;
-    char * prevfile;
-    int prevline;
-};
-
-#define TRACEBUF    struct qm_trace trace;
-#define TRASHIT(x)  do {(x) = (void *)-1;} while (0)
-
-#define QMD_TRACE_HEAD(head) do {                   \
-    (head)->trace.prevline = (head)->trace.lastline;        \
-    (head)->trace.prevfile = (head)->trace.lastfile;        \
-    (head)->trace.lastline = __LINE__;              \
-    (head)->trace.lastfile = __FILE__;              \
+	/* Store the last 2 places the queue element or head was altered */
+	struct qm_trace {
+		char * lastfile;
+		int lastline;
+		char * prevfile;
+		int prevline;
+	};
+	
+#define    TRACEBUF    struct qm_trace trace;
+#define    TRASHIT(x)    do {(x) = (void *)NULL;} while (0)
+
+#define    QMD_TRACE_HEAD(head) do {                    \
+		(head)->trace.prevline = (head)->trace.lastline;		\
+		(head)->trace.prevfile = (head)->trace.lastfile;		\
+		(head)->trace.lastline = __LINE__;				  \
+		(head)->trace.lastfile = __FILE__;				  \
+	} while (0)
+
+	
+#define    QMD_TRACE_ELEM(elem) do {                    \
+		(elem)->trace.prevline = (elem)->trace.lastline;		\
+		(elem)->trace.prevfile = (elem)->trace.lastfile;		\
+		(elem)->trace.lastline = __LINE__;				  \
+		(elem)->trace.lastfile = __FILE__;				  \
+	} while (0)
+	
+
+
+#define QMD_DUMP_TRACE_ELEM(elem) do { \
+	printk(KERN_CRIT "crtical txq error dump elem\n"); \
+	printk(KERN_CRIT "prevl %d\n", (elem)->list_elem.trace.prevline);\
+	printk(KERN_CRIT "prevf %s\n", (elem)->list_elem.trace.prevfile);\
+	printk(KERN_CRIT "lastl %d\n", (elem)->list_elem.trace.lastline);\
+	printk(KERN_CRIT "lastf %s\n", (elem)->list_elem.trace.lastfile);\
 } while (0)
 
-#define QMD_TRACE_ELEM(elem) do {                   \
-    (elem)->trace.prevline = (elem)->trace.lastline;        \
-    (elem)->trace.prevfile = (elem)->trace.lastfile;        \
-    (elem)->trace.lastline = __LINE__;              \
-    (elem)->trace.lastfile = __FILE__;              \
+#define QMD_DUMP_TRACE_HEAD(head) do { \
+	printk(KERN_CRIT "crtical txq error dump head\n"); \
+	printk(KERN_CRIT "prevl %d\n", (head)->trace.prevline);\
+	printk(KERN_CRIT "prevf %s\n", (head)->trace.prevfile);\
+	printk(KERN_CRIT "lastl %d\n", (head)->trace.lastline);\
+	printk(KERN_CRIT "lastf %s\n", (head)->trace.lastfile);\
 } while (0)
 
 #else
@@ -162,6 +182,8 @@
 #define QMD_TRACE_HEAD(head)
 #define TRACEBUF
 #define TRASHIT(x)
+#define QMD_DUMP_TRACE_ELEM(elem)
+#define QMD_DUMP_TRACE_HEAD(head)
 #endif  /* QUEUE_MACRO_DEBUG */
 
 /*
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/sys/queue.h qcacld-new/CORE/SERVICES/COMMON/sys/queue.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/sys/queue.h	2016-05-16 10:58:07.362298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/sys/queue.h	2016-05-16 10:58:08.774298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -156,11 +157,32 @@
     (elem)->trace.lastfile = __FILE__;                \
 } while (0)
 
+
+
+#define QMD_DUMP_TRACE_ELEM(elem) do { \
+	printk(KERN_CRIT "crtical txq error dump elem\n"); \
+	printk(KERN_CRIT "prevl %d\n", (elem)->list_elem.trace.prevline);\
+	printk(KERN_CRIT "prevf %s\n", (elem)->list_elem.trace.prevfile);\
+	printk(KERN_CRIT "lastl %d\n", (elem)->list_elem.trace.lastline);\
+	printk(KERN_CRIT "lastf %s\n", (elem)->list_elem.trace.lastfile);\
+} while (0)
+
+#define QMD_DUMP_TRACE_HEAD(head) do { \
+	printk(KERN_CRIT "crtical txq error dump head\n"); \
+	printk(KERN_CRIT "prevl %d\n", (head)->trace.prevline);\
+	printk(KERN_CRIT "prevf %s\n", (head)->trace.prevfile);\
+	printk(KERN_CRIT "lastl %d\n", (head)->trace.lastline);\
+	printk(KERN_CRIT "lastf %s\n", (head)->trace.lastfile);\
+} while (0)
+
+
 #else
 #define    QMD_TRACE_ELEM(elem)
 #define    QMD_TRACE_HEAD(head)
 #define    TRACEBUF
-#define TRASHIT(x) do {(x) = (void *)0;} while (0)
+#define    TRASHIT(x)
+#define QMD_DUMP_TRACE_ELEM(elem)
+#define QMD_DUMP_TRACE_HEAD(head)
 #endif    /* QUEUE_MACRO_DEBUG */
 
 #ifdef ATHR_RNWF
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/wma_api.h qcacld-new/CORE/SERVICES/COMMON/wma_api.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/wma_api.h	2016-05-16 10:58:06.854298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/wma_api.h	2016-05-16 10:58:08.766298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -129,6 +130,8 @@
 int wma_is_wow_mode_selected(WMA_HANDLE handle);
 int wma_enable_wow_in_fw(WMA_HANDLE handle);
 bool wma_check_scan_in_progress(WMA_HANDLE handle);
+void wma_stop_allscan(WMA_HANDLE wma_handle);
+void wma_scan_completion_timeout(void *data);
 #ifdef FEATURE_WLAN_D0WOW
 int wma_get_client_count(WMA_HANDLE handle);
 #endif
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified_api.h qcacld-new/CORE/SERVICES/COMMON/wmi_unified_api.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified_api.h	2016-05-16 10:58:07.362298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_unified_api.h	2016-05-16 10:58:08.774298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -139,6 +140,7 @@
 void
 wmi_set_target_suspend(wmi_unified_t wmi_handle, A_BOOL val);
 
-
+void
+wmi_set_target_resumeok(wmi_unified_t wmi_handle, A_BOOL val);
 
 #endif /* _WMI_UNIFIED_API_H_ */
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified.h qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/wmi_unified.h	2016-05-16 10:58:06.846298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_unified.h	2016-05-16 10:58:08.766298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -2451,7 +2452,11 @@
     /** set type of the debug output */
     WMI_DBGLOG_TYPE,
     /** Enable Disable debug */
-    WMI_DBGLOG_REPORT_ENABLE
+    WMI_DBGLOG_REPORT_ENABLE,
+    /** Enable fwlog write to file */
+    WMI_DBGLOG_FWLOG_FILE_ENABLE,
+    /** set max size of fwlog file */
+    WMI_DBGLOG_FWLOG_FILE_MAX_SIZE,
 } WMI_DBG_PARAM;
 
 typedef struct {
@@ -2494,7 +2499,7 @@
     PAUSE_TYPE_STA_ADD_BA =     0x6, /** only peer_id and tid_map are valid, actually only one tid is set at one time */
     PAUSE_TYPE_AP_PS =          0x7, /** for pausing AP vdev when all the connected clients are in PS. only vdev_map is valid */
     PAUSE_TYPE_IBSS_PS =        0x8, /** for pausing IBSS vdev when all the peers are in PS. only vdev_map is valid */
-    PAUSE_TYPE_HOST =           0x15,/** host is requesting vdev pause */
+    PAUSE_TYPE_HOST =           0xF, /** host is requesting vdev pause */
 } wmi_tx_pause_type;
 
 typedef enum {
@@ -5808,6 +5813,8 @@
     EXTWOW_TYPE_APP_TYPE1,   /* extend wow type: only enable wakeup for app type1 */
     EXTWOW_TYPE_APP_TYPE2,   /* extend wow type: only enable wakeup for app type2 */
     EXTWOW_TYPE_APP_TYPE1_2, /* extend wow type: enable wakeup for app type1&2 */
+    EXTWOW_TYPE_APP_PULSETEST,
+    EXTWOW_DISABLED = 255,
 } EXTWOW_TYPE;
 
 typedef struct {
@@ -5815,8 +5822,13 @@
     A_UINT32 vdev_id;
     A_UINT32 type;
     A_UINT32 wakeup_pin_num;
+    A_UINT32 swol_pulsetest_type;
+    A_UINT32 swol_pulsetest_application;
 } wmi_extwow_enable_cmd_fixed_param;
 
+#define SWOL_INDOOR_MAC_ADDRESS_INDEX_MAX 8
+#define SWOL_INDOOR_KEY_LEN 16
+
 typedef struct {
     A_UINT32 tlv_header; /* TLV tag and len; tag equals wmi_extwow_set_app_type1_params_cmd_fixed_param  */
     A_UINT32 vdev_id;
@@ -5825,8 +5837,35 @@
     A_UINT8  passwd[16];
     A_UINT32 ident_len;
     A_UINT32 passwd_len;
+
+    /* indoor check parameters */
+    /* key for mac addresses specified in swol_indoor_key_mac
+     * Big-endian hosts need to byte-swap the bytes within each 4-byte
+     * segment of this array, so the bytes will return to their original
+     * order when the entire WMI message contents are byte-swapped to
+     * convert from big-endian to little-endian format.
+     */
+    A_UINT8 swol_indoor_key[SWOL_INDOOR_MAC_ADDRESS_INDEX_MAX][SWOL_INDOOR_KEY_LEN];
+    /* key length for specified mac address index
+     * Big-endian hosts need to byte-swap the bytes within each 4-byte
+     * segment of this array, so the bytes will return to their original
+     * order when the entire WMI message contents are byte-swapped to
+     * convert from big-endian to little-endian format.
+     */
+    A_UINT8 swol_indoor_key_len[SWOL_INDOOR_MAC_ADDRESS_INDEX_MAX];
+    /* mac address array allowed to wakeup host*/
+    wmi_mac_addr swol_indoor_key_mac[SWOL_INDOOR_MAC_ADDRESS_INDEX_MAX];
+    /* app mask for the mac addresses specified in swol_indoor_key_mac */
+    A_UINT32 swol_indoor_app_mask[SWOL_INDOOR_MAC_ADDRESS_INDEX_MAX];
+    A_UINT32 swol_indoor_waker_check; /* whether to do indoor waker check */
+    A_UINT32 swol_indoor_pw_check;    /* whether to check password */
+    A_UINT32 swol_indoor_pattern;     /* wakeup pattern */
+    A_UINT32 swol_indoor_exception;   /* wakeup when exception happens */
+    A_UINT32 swol_indoor_exception_app;
 } wmi_extwow_set_app_type1_params_cmd_fixed_param;
 
+
+
 typedef struct {
     A_UINT32 tlv_header;  /* TLV tag and len; tag equals wmi_extwow_set_app_type2_params_cmd_fixed_param  */
     A_UINT32 vdev_id;
@@ -5853,8 +5892,42 @@
     wmi_mac_addr gateway_mac;
     A_UINT32 tcp_tx_timeout_val;
     A_UINT32 tcp_rx_timeout_val;
-} wmi_extwow_set_app_type2_params_cmd_fixed_param;
 
+    /** add extra parameter for backward-compatible */
+    /*
+     * For all byte arrays, natural order is used.  E.g.
+     * rc4_write_sandbox[0] holds the 1st RC4 S-box byte,
+     * rc4_write_sandbox[1] holds the 2nd RC4 S-box byte, etc.
+     */
+
+    /* used to encrypt transmit packet such as keep-alive */
+    A_UINT8  rc4_write_sandbox[256];
+    A_UINT32 rc4_write_x;
+    A_UINT32 rc4_write_y;
+
+    /* used to decrypt received packet such as wow data */
+    A_UINT8  rc4_read_sandbox[256];
+    A_UINT32 rc4_read_x;
+    A_UINT32 rc4_read_y;
+
+    /* used to caculate HMAC hash for transmit packet such as keep-alive */
+    A_UINT8  ssl_write_seq[8];
+    A_UINT8  ssl_sha1_write_key[64];
+    A_UINT32 ssl_sha1_write_key_len;
+
+    /* used to calculate HAMC hash for receive packet such as wow data */
+    A_UINT8  ssl_read_seq[8];
+    A_UINT8  ssl_sha1_read_key[64];
+    A_UINT32 ssl_sha1_read_key_len;
+
+    /* optional element for specifying TCP options data to include in
+     * transmit packets such as keep-alive
+     */
+    A_UINT32 tcp_options_len;
+    A_UINT8  tcp_options[40];
+
+    A_UINT32 async_id; /* keep-alive request id */
+} wmi_extwow_set_app_type2_params_cmd_fixed_param;
 
 
 #define WMI_RXERR_CRC               0x01    /* CRC error on frame */
diff -urN qcacld-new.orig/CORE/SERVICES/COMMON/wmi_version.h qcacld-new/CORE/SERVICES/COMMON/wmi_version.h
--- qcacld-new.orig/CORE/SERVICES/COMMON/wmi_version.h	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/COMMON/wmi_version.h	2016-05-16 10:58:08.782298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_phyerr.c qcacld-new/CORE/SERVICES/DFS/src/dfs_process_phyerr.c
--- qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_phyerr.c	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/DFS/src/dfs_process_phyerr.c	2016-05-16 10:58:08.782298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -237,7 +238,7 @@
    const char *cbuf = (const char *) buf;
    u_int8_t dur = 0;
    u_int8_t pulse_bw_info, pulse_length_ext, pulse_length_pri;
-   int pri_found, ext_found;
+   int pri_found = 0, ext_found = 0;
    int early_ext = 0;
    int event_width;
 
@@ -721,10 +722,11 @@
     */
    ATH_DFSEVENTQ_LOCK(dfs);
    empty = STAILQ_EMPTY(&(dfs->dfs_eventq));
-   ATH_DFSEVENTQ_UNLOCK(dfs);
    if (empty) {
+   	  ATH_DFSEVENTQ_UNLOCK(dfs);
       return;
    }
+   ATH_DFSEVENTQ_UNLOCK(dfs);
 
    /*
     * If the channel is a turbo G channel, then the event is
diff -urN qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_radarevent.c qcacld-new/CORE/SERVICES/DFS/src/dfs_process_radarevent.c
--- qcacld-new.orig/CORE/SERVICES/DFS/src/dfs_process_radarevent.c	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/DFS/src/dfs_process_radarevent.c	2016-05-16 10:58:08.782298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
 
@@ -482,7 +483,7 @@
                                             This is normally 2 but can be higher for W53.
                                         */
 
-                                        if ( (deltaT > (dfs->dfs_pri_multiplier * rf->rf_maxpri) ) || (deltaT < rf->rf_minpri) ) {
+                                        if ( (deltaT > (u_int64_t)((u_int64_t)dfs->dfs_pri_multiplier * rf->rf_maxpri) ) || (deltaT < rf->rf_minpri) ) {
                                                 DFS_DPRINTK(dfs, ATH_DEBUG_DFS2,
                                                 "filterID %d : Rejecting on individual filter max PRI deltaT=%lld rf->rf_minpri=%u",
                                                 rf->rf_pulseid, (unsigned long long)deltaT, rf->rf_minpri);
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/common/hif_bmi_reg_access.c qcacld-new/CORE/SERVICES/HIF/common/hif_bmi_reg_access.c
--- qcacld-new.orig/CORE/SERVICES/HIF/common/hif_bmi_reg_access.c	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/common/hif_bmi_reg_access.c	2016-05-16 10:58:08.822298648 +0800
@@ -16,7 +16,7 @@
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
  * under proprietary terms before Copyright ownership was assigned
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/common/hif_sdio_common.h qcacld-new/CORE/SERVICES/HIF/common/hif_sdio_common.h
--- qcacld-new.orig/CORE/SERVICES/HIF/common/hif_sdio_common.h	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/common/hif_sdio_common.h	2016-05-16 10:58:08.822298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/DXE/hif_dxe_os.h qcacld-new/CORE/SERVICES/HIF/DXE/hif_dxe_os.h
--- qcacld-new.orig/CORE/SERVICES/HIF/DXE/hif_dxe_os.h	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/DXE/hif_dxe_os.h	2016-05-16 10:58:08.822298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -162,4 +163,4 @@
 
 void hif_dxe_os_stop(hif_dxe_oshandle hif_dxe_osdev);
 
-#endif /* _HIF_DXE_OS_H_ */
\ No newline at end of file
+#endif /* _HIF_DXE_OS_H_ */
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/PCIe/if_pci.c qcacld-new/CORE/SERVICES/HIF/PCIe/if_pci.c
--- qcacld-new.orig/CORE/SERVICES/HIF/PCIe/if_pci.c	2016-05-16 10:58:07.382298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/PCIe/if_pci.c	2016-05-16 10:58:08.814298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/PCIe/if_pci.h qcacld-new/CORE/SERVICES/HIF/PCIe/if_pci.h
--- qcacld-new.orig/CORE/SERVICES/HIF/PCIe/if_pci.h	2016-05-16 10:58:07.382298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/PCIe/if_pci.h	2016-05-16 10:58:08.814298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c qcacld-new/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c
--- qcacld-new.orig/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c	2016-05-16 10:58:07.374298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/sdio/hif_sdio_recv.c	2016-05-16 10:58:08.806298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #define ATH_MODULE_NAME hif
 #include <adf_os_types.h>
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c qcacld-new/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c
--- qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c	2016-05-16 10:58:07.374298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/sdio/linux/if_ath_sdio.c	2016-05-16 10:58:08.806298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #ifndef EXPORT_SYMTAB
 #define EXPORT_SYMTAB
@@ -77,7 +78,7 @@
     HIF_DEVICE_OS_DEVICE_INFO os_dev_info;
     struct sdio_func *func = NULL;
     const struct sdio_device_id *id;
-    u_int32_t target_type;
+    u_int32_t target_type = TARGET_TYPE_UNKNOWN;
     ENTER();
 
     sc = (struct ath_hif_sdio_softc *) A_MALLOC(sizeof(*sc));
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/native_sdio/include/hif_internal.h qcacld-new/CORE/SERVICES/HIF/sdio/linux/native_sdio/include/hif_internal.h
--- qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/native_sdio/include/hif_internal.h	2016-05-16 10:58:07.374298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/sdio/linux/native_sdio/include/hif_internal.h	2016-05-16 10:58:08.806298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c qcacld-new/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c
--- qcacld-new.orig/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c	2016-05-16 10:58:07.382298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/sdio/linux/native_sdio/src/hif.c	2016-05-16 10:58:08.806298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/mmc.h>
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb.c qcacld-new/CORE/SERVICES/HIF/USB/hif_usb.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb.c	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/hif_usb.c	2016-05-16 10:58:08.814298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 #include <adf_os_types.h>
 #include <adf_os_dma.h>
 #include <adf_os_timer.h>
@@ -675,7 +676,7 @@
 		if (A_FAILED(status))
 			break;
 
-		if (NULL == pResponseMessage) {
+		if (NULL == pResponseMessage || NULL == pResponseLength) {
 			/* no expected response */
 			break;
 		}
@@ -872,8 +873,10 @@
 {
 	HIF_DEVICE_USB *device = (HIF_DEVICE_USB *) hif;
 	HIF_USB_PIPE *pipe = NULL;
+#ifndef CONFIG_VD_PREVENT_DEADCODE
 	struct usb_host_interface *iface_desc = NULL;
 	struct usb_endpoint_descriptor *ep_desc;
+#endif
 	A_UINT8 i = 0;
 	for (i = 0; i < HIF_USB_PIPE_MAX; i++) {
 		pipe = &device->pipes[i];
@@ -890,24 +893,26 @@
 		else if (usb_pipecontrol(pipe->usb_pipe_handle))
 			pr_info("Pipe Type control\n");
 	}
-
-	for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
-		ep_desc = &iface_desc->endpoint[i].desc;
-		if (ep_desc) {
-			pr_info(
-			     "ep_desc : %p Index : %d: DescType : %d Addr : %d Maxp : %d Atrrib : %d\n",
-			     ep_desc, i,
-			     ep_desc->bDescriptorType,
-			     ep_desc->bEndpointAddress, ep_desc->wMaxPacketSize,
-			     ep_desc->bmAttributes);
-			if ((ep_desc)
-			    && (usb_endpoint_type(ep_desc) ==
-				USB_ENDPOINT_XFER_ISOC)) {
-				pr_info("ISOC EP Detected\n");
+#ifndef CONFIG_VD_PREVENT_DEADCODE
+	if (iface_desc) {
+		for (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {
+			ep_desc = &iface_desc->endpoint[i].desc;
+			if (ep_desc) {
+				pr_info(
+				"ep_desc : %p Index : %d: DescType : %d Addr : %d Maxp : %d Atrrib : %d\n",
+				ep_desc, i,
+				ep_desc->bDescriptorType,
+				ep_desc->bEndpointAddress, ep_desc->wMaxPacketSize,
+				ep_desc->bmAttributes);
+				if ((ep_desc)
+					&& (usb_endpoint_type(ep_desc) ==
+					USB_ENDPOINT_XFER_ISOC)) {
+						pr_info("ISOC EP Detected\n");
+				}
 			}
 		}
-	}
-
+        }
+#endif
 }
 
 void HIFDump(HIF_DEVICE *hif_device, u_int8_t cmd_id, bool start)
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb_internal.h qcacld-new/CORE/SERVICES/HIF/USB/hif_usb_internal.h
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/hif_usb_internal.h	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/hif_usb_internal.h	2016-05-16 10:58:08.822298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.c	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/if_usb.c	2016-05-16 10:58:08.822298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 #include <osdep.h>
 #include <linux/usb.h>
 #include <linux/slab.h>
@@ -40,9 +41,10 @@
 #include "wlan_hdd_main.h"
 #include "epping_main.h"
 
-#ifdef WLAN_BTAMP_FEATURE
+#if defined(WLAN_BTAMP_FEATURE) || defined(CONFIG_USB_PRELOAD)
 #include "wlan_btc_svc.h"
 #include "wlan_nlink_common.h"
+#include "vos_getBin.h"
 #endif
 
 #ifndef REMOVE_PKT_LOG
@@ -116,6 +118,7 @@
 	return NOTIFY_DONE;
 }
 
+
 static int
 hif_usb_probe(struct usb_interface *interface, const struct usb_device_id *id)
 {
@@ -159,7 +162,7 @@
 
 	if ((usb_control_msg(pdev, usb_sndctrlpipe(pdev, 0),
 			     USB_REQ_SET_CONFIGURATION, 0, 1, 0, NULL, 0,
-			     HZ)) < 0) {
+			     2000)) < 0) {
 		pr_info("%s[%d]\n\r", __func__, __LINE__);
 	}
 	usb_set_interface(pdev, 0, 0);
@@ -200,9 +203,10 @@
 	}
 #endif
 
-#ifdef WLAN_BTAMP_FEATURE
+#if defined(WLAN_BTAMP_FEATURE) || defined(CONFIG_USB_PRELOAD)
 	/* Send WLAN UP indication to Nlink Service */
-	send_btc_nlink_msg(WLAN_MODULE_UP_IND, 0);
+	if (!WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		send_btc_nlink_msg(WLAN_MODULE_UP_IND, 0);
 #endif
 
 	sc->interface = interface;
@@ -213,7 +217,8 @@
 	return 0;
 
 err_config:
-	HIFDiagWriteCOLDRESET(sc->hif_device);
+	if (sc->hif_device != NULL)
+		HIFDiagWriteCOLDRESET(sc->hif_device);
 	A_FREE(ol_sc);
 err_attach:
 	ret = -EIO;
@@ -309,24 +314,45 @@
 	HIF_DEVICE_USB *device = usb_get_intfdata(interface);
 	struct hif_usb_softc *sc = device->sc;
 	void *vos = vos_get_global_context(VOS_MODULE_ID_HIF, NULL);
-	v_VOID_t * temp_module;
-
-	printk("Enter:%s,Line:%d\n", __func__,__LINE__);
+        ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX, vos);
+        u32 tx_drain_wait_cnt = 0;
+        int tx_pending = 0;
+ 	v_VOID_t * temp_module;
+
+	pr_err("Enter:%s,Line:%d\n", __func__,__LINE__);
+
+        if (!txrx_pdev) {
+            printk("%s: txrx_pdev is NULL\n", __func__);
+            return (-1);
+        }
 
 	temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
 	if (!temp_module) {
-		printk("%s: WDA module is NULL\n", __func__);
+		printk("KERN_ERR %s: WDA module is NULL\n", __func__);
 		return (-1);
 	}
 
 	if (wma_check_scan_in_progress(temp_module)) {
-		printk("%s: Scan in progress. Aborting suspend\n", __func__);
-		return (-1);
+		printk(KERN_ERR "%s: Scan in progress. Cancel all exising scan req\n", __func__);
+		wma_stop_allscan(temp_module);
+          	msleep(10);
 	}
 
+        /* Wait for pending tx completion */
+        while ((tx_pending = ol_txrx_get_tx_pending_hl(txrx_pdev))) {
+            msleep(OL_ATH_TX_DRAIN_WAIT_DELAY);
+            if (++tx_drain_wait_cnt > OL_ATH_TX_DRAIN_WAIT_CNT) {
+                printk(KERN_ERR "%s: tx frames are pending: %d\n", __func__, tx_pending);
+                ol_txrx_dump_tx_desc(txrx_pdev);
+                break;
+            }
+        }
+        ol_txrx_pdev_pause(txrx_pdev);
+
 	/* No need to send WMI_PDEV_SUSPEND_CMDID to FW if WOW is enabled */
 	if (wma_is_wow_mode_selected(temp_module)) {
 		if (wma_enable_wow_in_fw(temp_module)) {
+                        ol_txrx_pdev_unpause(txrx_pdev);
 			pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 			return -1;
 		}
@@ -335,6 +361,7 @@
 		(PM_EVENT_HIBERNATE & state.event) == PM_EVENT_HIBERNATE) {
 		if (wma_suspend_target
 		    (vos_get_context(VOS_MODULE_ID_WDA, vos), 0)) {
+                        ol_txrx_pdev_unpause(txrx_pdev);
 			pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 			return -1;
 		}
@@ -343,10 +370,9 @@
 	sc->suspend_state = 1;
 	usb_hif_flush_all(device);
 
-	printk("Exit:%s,Line:%d\n", __func__,__LINE__);
+	pr_err("Exit:%s,Line:%d\n", __func__,__LINE__);
 	return 0;
 }
-
 #ifdef WLAN_LINK_UMAC_SUSPEND_WITH_BUS_SUSPEND
 void hdd_resume_wlan(void);
 #endif
@@ -357,8 +383,9 @@
 	struct hif_usb_softc *sc = device->sc;
 	void *vos = vos_get_global_context(VOS_MODULE_ID_HIF, NULL);
 	v_VOID_t * temp_module;
+        ol_txrx_pdev_handle txrx_pdev = vos_get_context(VOS_MODULE_ID_TXRX, vos);
 
-	printk("Enter:%s,Line:%d\n", __func__,__LINE__);
+	pr_err("Enter:%s,Line:%d\n", __func__,__LINE__);
 	temp_module = vos_get_context(VOS_MODULE_ID_WDA, vos);
 	if (!temp_module) {
 		printk("%s: WDA module is NULL\n", __func__);
@@ -379,18 +406,16 @@
 		pr_warn("%s[%d]: fail\n", __func__, __LINE__);
 		return (-1);
 	}
-	printk("Exit:%s,Line:%d\n", __func__,__LINE__);
+        ol_txrx_pdev_unpause(txrx_pdev);
+	pr_err("Exit:%s,Line:%d\n", __func__,__LINE__);
 	return 0;
 }
 
 static int hif_usb_reset_resume(struct usb_interface *intf)
 {
-	HIF_DEVICE_USB *device = usb_get_intfdata(intf);
-	struct hif_usb_softc *sc = device->sc;
-
-	printk("Enter:%s,Line:%d \n\r", __func__,__LINE__);
-	HIFDiagWriteCOLDRESET(sc->hif_device);
-	printk("Exit:%s,Line:%d \n\r", __func__,__LINE__);
+	pr_err("Enter:%s,Line:%d \n\r", __func__,__LINE__);
+	hif_usb_resume(usb_sc->interface);
+	pr_err("Exit:%s,Line:%d \n\r", __func__,__LINE__);
 	return 0;
 }
 
@@ -411,7 +436,7 @@
 	.resume = hif_usb_resume,
 	.reset_resume = hif_usb_reset_resume,
 #endif
-	.supports_autosuspend = true,
+	.supports_autosuspend = false,
 };
 
 void hif_init_adf_ctx(adf_os_device_t adf_dev, void *ol_sc)
@@ -461,13 +486,25 @@
 int hif_register_driver(void)
 {
 	int status = 0;
+#ifndef CONFIG_USB_PRELOAD
 	int probe_wait_cnt = 0;
+#endif
 	is_usb_driver_register = 1;
 	init_waitqueue_head(&hif_usb_unload_event_wq);
 	atomic_set(&hif_usb_unload_state, HIF_USB_UNLOAD_STATE_NULL);
 	usb_register_notify(&hif_usb_dev_nb);
 	status = usb_register(&hif_usb_drv_id);
 
+#if defined (CONFIG_USB_PRELOAD)
+	if (!WLAN_IS_EPPING_ENABLED(vos_get_conparam())) {
+		return status;
+	} else {
+		if (usb_sc && status == 0)
+			return 0;
+		else
+			return -1;
+	}
+#else
 	/* wait for usb probe done, 2s at most*/
 	while(!usb_sc && probe_wait_cnt < 10) {
 		A_MSLEEP(200);
@@ -478,6 +515,7 @@
 		return 0;
 	else
 		return -1;
+#endif
 }
 
 void hif_unregister_driver(void)
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.h qcacld-new/CORE/SERVICES/HIF/USB/if_usb.h
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/if_usb.h	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/if_usb.h	2016-05-16 10:58:08.814298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -43,7 +44,7 @@
  * long suspend thread has to sleep before checking pending tx
  * frame count.
  */
-#define OL_ATH_TX_DRAIN_WAIT_DELAY     50	/* ms */
+#define OL_ATH_TX_DRAIN_WAIT_DELAY     100	/* ms */
 /*
  * Wait time (in unit of OL_ATH_TX_DRAIN_WAIT_DELAY) for pending
  * tx frame completion before suspend. Refer: hif_pci_suspend()
diff -urN qcacld-new.orig/CORE/SERVICES/HIF/USB/usbdrv.c qcacld-new/CORE/SERVICES/HIF/USB/usbdrv.c
--- qcacld-new.orig/CORE/SERVICES/HIF/USB/usbdrv.c	2016-05-16 10:58:07.390298648 +0800
+++ qcacld-new/CORE/SERVICES/HIF/USB/usbdrv.c	2016-05-16 10:58:08.822298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 #include <linux/module.h>
 #include <linux/usb.h>
 #include <linux/version.h>
@@ -1015,7 +1016,7 @@
 					 req,
 					 USB_DIR_OUT | USB_TYPE_VENDOR |
 					 USB_RECIP_DEVICE, value, index, buf,
-					 size, 2 * HZ);
+					 size, 2000);
 
 		if (result < 0) {
 			AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (
@@ -1060,7 +1061,7 @@
 					 req,
 					 USB_DIR_IN | USB_TYPE_VENDOR |
 					 USB_RECIP_DEVICE, value, index, buf,
-					 size, 2 * HZ);
+					 size, 2000);
 
 		if (result < 0) {
 			AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
diff -urN qcacld-new.orig/CORE/SERVICES/HTC/htc.c qcacld-new/CORE/SERVICES/HTC/htc.c
--- qcacld-new.orig/CORE/SERVICES/HTC/htc.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/HTC/htc.c	2016-05-16 10:58:08.834298648 +0800
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, 2014 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013, 2014, 2015 The Linux Foundation. All rights reserved.
  *
  * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
  *
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 #include "ol_if_athvar.h"
@@ -143,7 +144,7 @@
 static void HTCCleanup(HTC_TARGET *target)
 {
     HTC_PACKET *pPacket;
-    //adf_nbuf_t netbuf;
+    adf_nbuf_t netbuf;
 
     if (target->hif_dev != NULL) {
         HIFDetachHTC(target->hif_dev);
@@ -161,6 +162,12 @@
     pPacket = target->pBundleFreeTxList;
     while (pPacket) {
         HTC_PACKET *pPacketTmp = (HTC_PACKET *)pPacket->ListLink.pNext;
+        if(pPacket->pContext != NULL) {
+           A_FREE(pPacket->pContext);
+        }
+        netbuf = GET_HTC_PACKET_NET_BUF_CONTEXT(pPacket);
+        if(netbuf != NULL)
+            adf_nbuf_free(netbuf);
         A_FREE(pPacket);
         pPacket = pPacketTmp;
     }
diff -urN qcacld-new.orig/CORE/SERVICES/HTC/htc_recv.c qcacld-new/CORE/SERVICES/HTC/htc_recv.c
--- qcacld-new.orig/CORE/SERVICES/HTC/htc_recv.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/HTC/htc_recv.c	2016-05-16 10:58:08.834298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #include "htc_debug.h"
 #include "htc_internal.h"
@@ -676,10 +677,11 @@
                 break;
         }
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if (A_FAILED(status)) {
             break;
         }
-
+#endif
             /* advance buffer past this record for next time around */
         pBuffer += htc_rec_len;
         Length -= htc_rec_len;
diff -urN qcacld-new.orig/CORE/SERVICES/HTC/htc_send.c qcacld-new/CORE/SERVICES/HTC/htc_send.c
--- qcacld-new.orig/CORE/SERVICES/HTC/htc_send.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/HTC/htc_send.c	2016-05-16 10:58:08.834298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 
@@ -1041,6 +1042,12 @@
     AR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);
     pEndpoint = &target->EndPoint[pPacket->Endpoint];
 
+    if (!pEndpoint->ServiceID) {
+       AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("%s: ServiceID is invalid\n",
+                                                 __func__));
+       return A_EINVAL;
+    }
+
 #ifdef HTC_EP_STAT_PROFILING
     LOCK_HTC_TX(target);
     INC_HTC_EP_STAT(pEndpoint,TxPosted,HTC_PACKET_QUEUE_DEPTH(pPktQueue));
diff -urN qcacld-new.orig/CORE/SERVICES/HTC/linux/htc_smd.c qcacld-new/CORE/SERVICES/HTC/linux/htc_smd.c
--- qcacld-new.orig/CORE/SERVICES/HTC/linux/htc_smd.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/HTC/linux/htc_smd.c	2016-05-16 10:58:08.834298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -456,6 +457,7 @@
 HTC_HANDLE HTCCreate(void *hHIF, HTC_INIT_INFO *pInfo, adf_os_device_t osdev)
 {
 	int status = 0;
+        unsigned long rc;
 	tp_htc_handle htc_handle = NULL;
 
 	HTC_LOGD("Enter");
@@ -527,11 +529,11 @@
 		goto fail;
 	}
 	/* Wait for the event */
-	status = wait_for_completion_interruptible_timeout(
+	rc = wait_for_completion_timeout(
 			&htc_handle->htc_smd_event,
 			msecs_to_jiffies(HTC_SMD_OPEN_TIMEOUT));
 
-	if (!status) {
+	if (!rc) {
 		HTC_LOGE("Timeout occurred while waiting for SMD_SS_OPENED event.");
 		/* since we opened one end of the channel, close it */
 		status = smd_close(htc_handle->smd_channel);
@@ -643,7 +645,8 @@
 	HTC_PACKET          *htc_packet;
 	int                 smd_status;
 	int                 status;
-	HTC_ENDPOINT      *endpoint;
+        unsigned long       rc;
+	HTC_ENDPOINT        *endpoint;
 
 	if ((NULL == htc_handle) || (HTC_CB_MAGIC != htc_handle->htc_magic)) {
 		HTC_LOGE("Invalid parameter");
@@ -672,10 +675,10 @@
 
 	} else {
 		/* close command was sent -- wait for the callback to complete */
-		status = wait_for_completion_interruptible_timeout(
+		rc = wait_for_completion_timeout(
 				&htc_handle->htc_smd_event,
 				msecs_to_jiffies(HTC_SMD_OPEN_TIMEOUT));
-		if (!status) {
+		if (!rc) {
 			HTC_LOGE("failed to receive SMD_EVENT_REOPEN_READY %d", smd_status);
 		}
 
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h qcacld-new/CORE/SERVICES/WMA/regdomain_common.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain_common.h	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain_common.h	2016-05-16 10:58:08.790298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -404,7 +405,6 @@
 	{MKK4_FCCA,     MKK4,           FCCA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN29 },
 
 	/* MKK5 */
-/*	{MKK5_MKKA,     MKK5,           MKKA,           DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN56 },*/
 	{MKK5_MKKB,	MKK5,		MKKA,		DISALLOW_ADHOC_11A | DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA | PSCAN_MKKA_G, CTRY_JAPAN13 },
 	{MKK5_MKKA2,MKK5,		MKKA,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3 | PSCAN_MKKA2 | PSCAN_MKKA2_G, CTRY_JAPAN14 },
 	{MKK5_MKKC,	MKK5,		MKKC,		DISALLOW_ADHOC_11A_TURB | NEED_NFC | LIMIT_FRAME_4MS, NEED_NFC, PSCAN_MKK3, CTRY_JAPAN15 },
@@ -668,7 +668,9 @@
     {CTRY_VENEZUELA,   FCC1_WORLD,    "VE", "VENEZUELA",      YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_VIET_NAM,    ETSI3_WORLD,   "VN", "VIET NAM",       YES,  NO, YES, YES, YES, YES, YES, YES, 7000 },
     {CTRY_YEMEN,       NULL1_WORLD,   "YE", "YEMEN",          YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
-    {CTRY_ZIMBABWE,    NULL1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 }
+    {CTRY_ZIMBABWE,    NULL1_WORLD,   "ZW", "ZIMBABWE",       YES,  NO, YES, YES, YES,  NO,  NO, NO, 7000 },
+
+
 };
 
 
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h qcacld-new/CORE/SERVICES/WMA/regdomain.h
--- qcacld-new.orig/CORE/SERVICES/WMA/regdomain.h	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/regdomain.h	2016-05-16 10:58:08.790298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -1087,7 +1088,7 @@
 
     CTRY_AUSTRALIA2           = 5000,    /* Australia for AP only */
     CTRY_CANADA2              = 5001,    /* Canada for AP only */
-    CTRY_BELGIUM2             = 5002     /* Belgium/Cisco implementation */
+    CTRY_BELGIUM2             = 5002,    /* Belgium/Cisco implementation */
 };
 int32_t regdmn_get_country_alpha2(struct regulatory *reg);
 void regdmn_set_regval(struct regulatory *reg);
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wlan_nv.c qcacld-new/CORE/SERVICES/WMA/wlan_nv.c
--- qcacld-new.orig/CORE/SERVICES/WMA/wlan_nv.c	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wlan_nv.c	2016-05-16 10:58:08.790298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /** ------------------------------------------------------------------------- *
     ------------------------------------------------------------------------- *
@@ -147,74 +148,74 @@
                 {1500},    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
 
                //11ac 20MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_13_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_19_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_26_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_13_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_19_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_26_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
 #ifdef WCN_PRONTO
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
 #endif
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_7_2_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_14_4_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_21_6_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_28_8_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_43_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_57_7_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_72_2_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_86_6_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_7_2_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_14_4_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_21_6_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_28_8_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_43_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_57_7_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_72_2_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_SGI_86_6_MBPS,
 #ifdef WCN_PRONTO
-                {0000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_SGI_96_1_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_SGI_96_1_MBPS,
 #endif
 
                //11ac 40MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_13_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_27_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_40_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_54_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_81_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_108_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_121_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_135_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_162_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_180_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_15_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_30_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_45_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_60_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_90_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_120_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_135_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_150_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_180_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_200_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_13_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_27_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_40_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_54_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_81_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_108_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_121_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_135_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_162_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_NGI_180_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_15_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_30_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_45_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_60_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_90_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_120_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_135_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_150_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_180_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_40MHZ_MCS_1NSS_CB_SGI_200_MBPS,
 
                //11ac 80MHZ NG, SG
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_29_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_87_8_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_117_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_175_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_234_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_263_3_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_292_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_351_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_390_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_32_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_65_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_97_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_130_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_195_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_260_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_292_5_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_325_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_390_MBPS,
-                {0000},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_433_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_29_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_87_8_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_117_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_175_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_234_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_263_3_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_292_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_351_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_NGI_390_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_32_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_65_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_97_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_130_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_195_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_260_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_292_5_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_325_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_390_MBPS,
+                {0},    // HAL_PHY_RATE_VHT_80MHZ_MCS_1NSS_CB_SGI_433_3_MBPS,
 #endif
             },  //    RF_SUBBAND_2_4_GHZ
             // 5G Low
@@ -284,7 +285,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11AC rates
                ///11A duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -304,7 +305,7 @@
                 {1250},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_39_MBPS,
                 {1200},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_52_MBPS,
                 {1100},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_58_5_MBPS,
-                {1000,    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
+                {1000},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_65_MBPS,
                 { 900},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_78_MBPS,
 #ifdef WCN_PRONTO
                 { 800},     // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_NGI_86_5_MBPS,
@@ -434,7 +435,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_111AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -584,7 +585,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -735,7 +736,7 @@
                 {1300},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_135_MBPS,
                 {1200},    // HAL_PHY_RATE_MCS_1NSS_MM_SG_CB_150_MBPS,
 
-#ifdef WLAN_FEATUURE_11AC
+#ifdef WLAN_FEATURE_11AC
                 ///11CAC rates
                ///11Ad duplicate 80MHz Rates
                 {1700},    // HAL_PHY_RATE_11AC_DUP_6_MBPS,
@@ -745,7 +746,7 @@
                 {1600},    // HAL_PHY_RATE_11AC_DUP_24_MBPS,
                 {1550},    // HAL_PHY_RATE_11AC_DUP_36_MBPS,
                 {1550},    // HAL_PHY_RATE_11AC_DUP_48_MBPS,
-                {1500,,    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
+                {1500},    // HAL_PHY_RATE_11AC_DUP_54_MBPS,
 
                ///11a c 20MHZ NG, SG
                 {1400},    // HAL_PHY_RATE_VHT_20MHZ_MCS_1NSS_CB_NGI_6_5_MBPS,
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wma.c qcacld-new/CORE/SERVICES/WMA/wma.c
--- qcacld-new.orig/CORE/SERVICES/WMA/wma.c	2016-05-16 10:58:07.374298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wma.c	2016-05-16 10:58:08.806298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**========================================================================
 
@@ -105,6 +106,14 @@
 
 #include "dfs.h"
 #include "radar_filters.h"
+#include "hif.h"
+#if defined(HIF_PCI)
+#include "if_pci.h"
+#elif defined(HIF_USB)
+#include "if_usb.h"
+#elif defined(HIF_SDIO)
+#include "if_ath_sdio.h"
+#endif
 /* ################### defines ################### */
 /*
  * TODO: Following constant should be shared by firwmare in
@@ -263,6 +272,7 @@
 
 static void wma_set_suspend_dtim(tp_wma_handle wma);
 static void wma_set_resume_dtim(tp_wma_handle wma);
+static void wma_set_sap_keepalive(tp_wma_handle wma, u_int8_t vdev_id);
 
 static void *wma_find_vdev_by_addr(tp_wma_handle wma, u_int8_t *addr,
 				   u_int8_t *vdev_id)
@@ -676,6 +686,11 @@
                 vos_mem_copy(iface->bssid, bssParams->bssId, ETH_ALEN);
 		wma_vdev_start_rsp(wma, bssParams, resp_event);
 	}
+
+	if ((wma->interfaces[resp_event->vdev_id].type == WMI_VDEV_TYPE_AP) &&
+		wma->interfaces[resp_event->vdev_id].vdev_up)
+		wma_set_sap_keepalive(wma, resp_event->vdev_id);
+
 	vos_timer_destroy(&req_msg->event_timeout);
 	adf_os_mem_free(req_msg);
 
@@ -888,18 +903,18 @@
 #define PEER_ALL_TID_BITMASK 0xffffffff
 	u_int32_t peer_tid_bitmap = PEER_ALL_TID_BITMASK;
 	u_int8_t *peer_addr = bssid;
-        if (!wma->peer_count)
+        if (!wma->interfaces[vdev_id].peer_count)
         {
              WMA_LOGE("%s: Can't remove peer with peer_addr %pM vdevid %d peer_count %d",
-                    __func__, bssid, vdev_id, wma->peer_count);
+                    __func__, bssid, vdev_id, wma->interfaces[vdev_id].peer_count);
              return;
         }
 	if (peer)
 		ol_txrx_peer_detach(peer);
 
-	wma->peer_count--;
+	wma->interfaces[vdev_id].peer_count--;
 	WMA_LOGE("%s: Removed peer with peer_addr %pM vdevid %d peer_count %d",
-                    __func__, bssid, vdev_id, wma->peer_count);
+                    __func__, bssid, vdev_id, wma->interfaces[vdev_id].peer_count);
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
 	if (roam_synch_in_progress)
 		return;
@@ -1470,6 +1485,144 @@
 	return status;
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+static void wma_send_status_of_ext_wow(tp_wma_handle wma, boolean status)
+{
+	tSirReadyToExtWoWInd *ready_to_extwow;
+	VOS_STATUS vstatus;
+	vos_msg_t vos_msg;
+	u_int8_t len;
+
+	WMA_LOGD("Posting ready to suspend indication to umac");
+
+	len = sizeof(tSirReadyToExtWoWInd);
+	ready_to_extwow = (tSirReadyToExtWoWInd *) vos_mem_malloc(len);
+
+	if (NULL == ready_to_extwow) {
+		WMA_LOGE("%s: Memory allocation failure", __func__);
+		return;
+	}
+
+	ready_to_extwow->mesgType = eWNI_SME_READY_TO_EXTWOW_IND;
+	ready_to_extwow->mesgLen = len;
+	ready_to_extwow->status= status;
+
+	vos_msg.type = eWNI_SME_READY_TO_EXTWOW_IND;
+	vos_msg.bodyptr = (void *) ready_to_extwow;
+	vos_msg.bodyval = 0;
+
+	vstatus = vos_mq_post_message(VOS_MQ_ID_SME, &vos_msg);
+	if (vstatus != VOS_STATUS_SUCCESS) {
+		WMA_LOGE("Failed to post ready to suspend");
+		vos_mem_free(ready_to_extwow);
+	}
+}
+
+static int wma_enable_ext_wow(tp_wma_handle wma,
+			 tpSirExtWoWParams params)
+{
+	wmi_extwow_enable_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+
+	len = sizeof(wmi_extwow_enable_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_enable_cmd_fixed_param *) wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+		       WMITLV_TAG_STRUC_wmi_extwow_enable_cmd_fixed_param,
+		       WMITLV_GET_STRUCT_TLVLEN(
+				wmi_extwow_enable_cmd_fixed_param));
+
+	cmd->vdev_id = params->vdev_id;
+	cmd->type = params->type;
+	cmd->wakeup_pin_num = params->wakeup_pin_num;
+	cmd->swol_pulsetest_type = params->swol_pulsetest_type;
+	cmd->swol_pulsetest_application = params->swol_pulsetest_application;
+
+	WMA_LOGD("%s: vdev_id %d type %d Wakeup_pin_num %x",
+		 __func__, cmd->vdev_id,
+		 cmd->type, cmd->wakeup_pin_num);
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_ENABLE_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set EXTWOW Enable", __func__);
+		wmi_buf_free(buf);
+		wma_send_status_of_ext_wow(wma, FALSE);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	wma_send_status_of_ext_wow(wma, TRUE);
+	return VOS_STATUS_SUCCESS;
+
+}
+
+static int wma_set_app_type1_params_in_fw(tp_wma_handle wma,
+			 tpSirAppType1Params appType1Params)
+{
+	wmi_extwow_set_app_type1_params_cmd_fixed_param *cmd;
+	wmi_buf_t buf;
+	int32_t len;
+	int ret;
+	int i;
+
+	len = sizeof(wmi_extwow_set_app_type1_params_cmd_fixed_param);
+	buf = wmi_buf_alloc(wma->wmi_handle, len);
+	if (!buf) {
+		WMA_LOGE("%s: Failed allocate wmi buffer", __func__);
+		return VOS_STATUS_E_NOMEM;
+	}
+
+	cmd = (wmi_extwow_set_app_type1_params_cmd_fixed_param *)
+						    wmi_buf_data(buf);
+
+	WMITLV_SET_HDR(&cmd->tlv_header,
+	    WMITLV_TAG_STRUC_wmi_extwow_set_app_type1_params_cmd_fixed_param,
+	    WMITLV_GET_STRUCT_TLVLEN(
+			wmi_extwow_set_app_type1_params_cmd_fixed_param));
+
+	cmd->vdev_id = appType1Params->vdev_id;
+	vos_mem_copy(cmd->ident, appType1Params->identification_id, sizeof(cmd->ident));
+	cmd->ident_len = appType1Params->id_length;
+	vos_mem_copy(cmd->passwd, appType1Params->password, sizeof(cmd->passwd));
+	cmd->passwd_len = appType1Params->pass_length;
+	WMI_CHAR_ARRAY_TO_MAC_ADDR(appType1Params->swol_indoor_wakee, &cmd->wakee_mac);
+	vos_mem_copy(cmd->swol_indoor_key, appType1Params->swol_indoor_key, sizeof(cmd->swol_indoor_key));
+	vos_mem_copy(cmd->swol_indoor_key_len, appType1Params->swol_indoor_key_len, sizeof(cmd->swol_indoor_key_len));
+	for (i = 0; i < 8; i++) {
+		WMI_CHAR_ARRAY_TO_MAC_ADDR(appType1Params->swol_indoor_key_mac[i], &cmd->swol_indoor_key_mac[i]);
+	}
+	vos_mem_copy(cmd->swol_indoor_app_mask, appType1Params->swol_indoor_app_mask, sizeof(cmd->swol_indoor_app_mask));
+	cmd->swol_indoor_waker_check = appType1Params->swol_indoor_waker_check;
+	cmd->swol_indoor_pw_check = appType1Params->swol_indoor_pw_check;
+	cmd->swol_indoor_pattern = appType1Params->swol_indoor_pattern;
+	cmd->swol_indoor_exception = appType1Params->swol_indoor_exception;
+	cmd->swol_indoor_exception_app = appType1Params->swol_indoor_exception_app;
+	WMA_LOGD("%s: vdev_id %d "
+			 "identification_id %.8s id_length %u "
+			 "password %.16s pass_length %u",
+		__func__, cmd->vdev_id, cmd->ident, cmd->ident_len,
+		cmd->passwd, cmd->passwd_len);
+
+	ret = wmi_unified_cmd_send(wma->wmi_handle, buf, len,
+				   WMI_EXTWOW_SET_APP_TYPE1_PARAMS_CMDID);
+	if (ret) {
+		WMA_LOGE("%s: Failed to set APP TYPE1 PARAMS", __func__);
+		wmi_buf_free(buf);
+		return VOS_STATUS_E_FAILURE;
+	}
+
+	return VOS_STATUS_SUCCESS;
+}
+
+#endif
 static void wma_update_pdev_stats(tp_wma_handle wma,
 					wmi_pdev_stats *pdev_stats)
 {
@@ -3476,6 +3629,7 @@
 	 tdls_event->messageType = WDA_TDLS_PEER_DISCONNECTED;
 	 break;
 	default:
+	 vos_mem_free(tdls_event);
 	 WMA_LOGE("%s: Discarding unknown tdls event(%d) from target",
 	          __func__, peer_event->peer_status);
 	 return -1;
@@ -3720,7 +3874,6 @@
 	int empty;
 	int do_check_chirp = 0;
 	int is_hw_chirp = 0;
-	int is_sw_chirp = 0;
 	int is_pri = 0;
 
 	WMI_DFS_RADAR_EVENTID_param_tlvs *param_tlvs;
@@ -3824,9 +3977,6 @@
 		if (is_hw_chirp) {
 			event->re_flags |= DFS_EVENT_HW_CHIRP;
 		}
-		if (is_sw_chirp) {
-			event->re_flags |= DFS_EVENT_SW_CHIRP;
-		}
 	}
 	/*
 	 * Correctly set which channel is being reported on
@@ -4930,7 +5080,8 @@
 	struct wma_target_req *msg;
 
 	if ((iface->type == WMI_VDEV_TYPE_AP) &&
-	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE)) {
+	    (iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_DEVICE ||
+		iface->sub_type == WMI_UNIFIED_VDEV_SUBTYPE_P2P_GO)) {
 
 		WMA_LOGA("P2P Device: removing self peer %pM",
 				pdel_sta_self_req_param->selfMacAddr);
@@ -5058,9 +5209,9 @@
 {
 	ol_txrx_peer_handle peer;
 
-	if (++wma->peer_count > wma->wlan_resource_config.num_peers) {
+	if (++wma->interfaces[vdev_id].peer_count > wma->wlan_resource_config.num_peers) {
 		WMA_LOGP("%s, the peer count exceeds the limit %d",
-			 __func__, wma->peer_count - 1);
+			 __func__, wma->interfaces[vdev_id].peer_count - 1);
 		goto err;
 	}
 	peer = ol_txrx_peer_attach(pdev, vdev, peer_addr);
@@ -5072,7 +5223,7 @@
 
 		WMA_LOGE("%s: Created peer with peer_addr %pM vdev_id %d,"
 				"peer_count - %d",__func__, peer_addr, vdev_id,
-				wma->peer_count);
+				wma->interfaces[vdev_id].peer_count);
 		return VOS_STATUS_SUCCESS;
 	}
 #endif
@@ -5083,7 +5234,7 @@
 		goto err;
 	}
 	WMA_LOGE("%s: Created peer with peer_addr %pM vdev_id %d, peer_count - %d",
-                    __func__, peer_addr, vdev_id, wma->peer_count);
+                    __func__, peer_addr, vdev_id, wma->interfaces[vdev_id].peer_count);
 
 #ifdef QCA_IBSS_SUPPORT
 	/* for each remote ibss peer, clear its keys */
@@ -5104,7 +5255,7 @@
 
 	return VOS_STATUS_SUCCESS;
 err:
-	wma->peer_count--;
+	wma->interfaces[vdev_id].peer_count--;
 	return VOS_STATUS_E_FAILURE;
 }
 
@@ -5789,7 +5940,7 @@
 	return vos_status;
 
 fail:
-	if(cfg_bin != NULL)
+	if (file_img)
 		vos_mem_free( file_img );
 
 	WMA_LOGD("%s: Exit", __func__);
@@ -6457,7 +6608,7 @@
 		goto error;
 	}
 
-	WMA_LOGI("WMA --> WMI_STOP_SCAN_CMDID");
+	WMA_LOGE("WMA --> WMI_STOP_SCAN_CMDID");
 
 	return VOS_STATUS_SUCCESS;
 error:
@@ -6467,6 +6618,19 @@
 	return vos_status;
 }
 
+void wma_stop_allscan(WMA_HANDLE handle)
+{
+	int i;
+	tp_wma_handle wma_handle = handle;
+	for (i = 0; i < wma_handle->max_bssid; i++){
+		if (wma_handle->interfaces[i].scan_info.scan_id){
+			tAbortScanParams abort_scan_req;
+			abort_scan_req.SessionId = wma_handle->interfaces[i].scan_info.scan_id;
+			wma_stop_scan(wma_handle, &abort_scan_req);
+		}
+	}
+}
+
 /* function   : wma_update_channel_list
  * Descriptin : Function is used to update the support channel list
  * Args       : wma_handle, list of supported channels and power
@@ -8940,13 +9104,16 @@
 		if (!peer) {
 			WMA_LOGP("%s: Failed to find peer %pM", __func__, params->bssId);
 		}
-		msg = wma_fill_vdev_req(wma, tgt_req->vdev_id, WDA_DELETE_BSS_REQ,
+		//Leave SAP/GO part to SAPFsm
+		if ( eSIR_INFRA_AP_MODE != params->bssType) {
+			msg = wma_fill_vdev_req(wma, tgt_req->vdev_id, WDA_DELETE_BSS_REQ,
 						WMA_TARGET_REQ_TYPE_VDEV_STOP, del_bss_params, 2000);
-		if (!msg) {
-			WMA_LOGP("%s: Failed to fill vdev request for vdev_id %d",
-							__func__, tgt_req->vdev_id);
-			goto error0;
-		}
+			if (!msg) {
+				WMA_LOGP("%s: Failed to fill vdev request for vdev_id %d",
+								__func__, tgt_req->vdev_id);
+				goto error0;
+			}
+                }
 		if (wmi_unified_vdev_stop_send(wma->wmi_handle, tgt_req->vdev_id)) {
 				WMA_LOGP("%s: %d Failed to send vdev stop",	__func__, __LINE__);
 				wma_remove_vdev_req(wma, tgt_req->vdev_id,
@@ -9381,12 +9548,20 @@
 {
     wmi_vdev_txbf_en txbf_en;
 
+    vos_mem_zero(&txbf_en, sizeof(wmi_vdev_txbf_en));
+
     /* This is set when Other partner is Bformer
 	and we are capable bformee(enabled both in ini and fw) */
 	txbf_en.sutxbfee = params->vhtTxBFCapable;
 	txbf_en.mutxbfee = params->vhtTxMUBformeeCapable;
 	txbf_en.sutxbfer = 0;
 	txbf_en.mutxbfer = 0;
+#if defined(AR900B)
+	txbf_en.txb_sts_cap = 0;
+	txbf_en.implicit_bf = 0;
+#else
+	txbf_en.reserved = 0;
+#endif
 
 	/* When MU TxBfee is set, SU TxBfee must be set by default */
 	if (txbf_en.mutxbfee)
@@ -11240,7 +11415,7 @@
 		goto send_fail_resp;
 	}
 	msg = wma_fill_vdev_req(wma, vdev_id, WDA_ADD_BSS_REQ,
-				WMA_TARGET_REQ_TYPE_VDEV_START, add_bss, 1000);
+				WMA_TARGET_REQ_TYPE_VDEV_START, add_bss, 3000);
 	if (!msg) {
 		WMA_LOGP("%s Failed to allocate vdev request vdev_id %d",
 			 __func__, vdev_id);
@@ -11816,8 +11991,7 @@
 send_bss_resp:
 		ol_txrx_find_peer_by_addr(pdev, add_bss->bssId,
 					  &add_bss->staContext.staIdx);
-		add_bss->status = (add_bss->staContext.staIdx < 0) ?
-				VOS_STATUS_E_FAILURE : VOS_STATUS_SUCCESS;
+		add_bss->status = VOS_STATUS_SUCCESS;
 		add_bss->bssIdx = add_bss->staContext.smesessionId;
 		vos_mem_copy(add_bss->staContext.staMac, add_bss->bssId,
 				 sizeof(add_bss->staContext.staMac));
@@ -12343,7 +12517,7 @@
 	if (0 == add_sta->updateSta) {
 	 /* its a add sta request **/
 #if defined(CONFIG_HL_SUPPORT)
-         if (add_sta->bssId && vdev->last_real_peer &&
+         if (vdev->last_real_peer &&
             (adf_os_mem_cmp((u8 *)add_sta->bssId,
                              vdev->last_real_peer->mac_addr.raw,
                              IEEE80211_ADDR_LEN) == 0)) {
@@ -12703,7 +12877,7 @@
 #ifndef CONFIG_QCA_WIFI_ISOC
 #ifdef QCA_IBSS_SUPPORT
         /* adjust heart beat thresold timer value for detecting ibss peer departure */
-        if (oper_mode == BSS_OPERATIONAL_MODE_IBSS)
+        if (oper_mode == BSS_OPERATIONAL_MODE_IBSS && add_sta)
                 wma_adjust_ibss_heart_beat_timer(wma, add_sta->smesessionId, 1);
 #endif
 #endif
@@ -13227,7 +13401,7 @@
 send_del_rsp:
 	if (del_sta->respReqd) {
 		WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
-			__func__, del_sta->status);
+					__func__, del_sta->status);
 		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
 	}
 }
@@ -13289,9 +13463,11 @@
 	del_sta->status = VOS_STATUS_SUCCESS;
 
 send_del_rsp:
-	WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
-	         __func__, del_sta->status);
-	wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
+	if (del_sta->respReqd) {
+		WMA_LOGD("%s: Sending del rsp to umac (status: %d)",
+					__func__, del_sta->status);
+		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)del_sta, 0);
+	}
 }
 #endif
 
@@ -13321,15 +13497,20 @@
 send_del_sta_rsp:
 #endif
 	params->status = status;
-	WMA_LOGD("%s: vdev_id %d status %d", __func__, params->smesessionId, status);
-	wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)params, 0);
+	if (params->respReqd) {
+		WMA_LOGD("%s: vdev_id %d status %d", __func__,
+				params->smesessionId, status);
+		wma_send_msg(wma, WDA_DELETE_STA_RSP, (void *)params, 0);
+	}
 }
 
 static void wma_delete_sta(tp_wma_handle wma, tpDeleteStaParams del_sta)
 {
 	tANI_U8 oper_mode = BSS_OPERATIONAL_MODE_STA;
+	u_int8_t smesession_id = del_sta->smesessionId;
+	bool rsp_requested = del_sta->respReqd;
 
-	if (wma_is_vdev_in_ap_mode(wma, del_sta->smesessionId)) {
+	if (wma_is_vdev_in_ap_mode(wma, smesession_id)) {
 #ifdef FEATURE_WLAN_D0WOW
 		wma_del_pm_vote(wma);
 #else
@@ -13338,7 +13519,7 @@
 		oper_mode = BSS_OPERATIONAL_MODE_AP;
 	}
 #ifdef QCA_IBSS_SUPPORT
-	if (wma_is_vdev_in_ibss_mode(wma, del_sta->smesessionId)) {
+	if (wma_is_vdev_in_ibss_mode(wma, smesession_id)) {
 		oper_mode = BSS_OPERATIONAL_MODE_IBSS;
 		WMA_LOGD("%s: to delete sta for IBSS mode", __func__);
         }
@@ -13359,12 +13540,19 @@
 
 #ifndef CONFIG_QCA_WIFI_ISOC
 #ifdef QCA_IBSS_SUPPORT
-        /* adjust heart beat thresold timer value for detecting ibss peer departure */
+	/* adjust heart beat thresold timer value for
+	 * detecting ibss peer departure
+	 */
         if (oper_mode == BSS_OPERATIONAL_MODE_IBSS)
-                wma_adjust_ibss_heart_beat_timer(wma, del_sta->smesessionId, -1);
+		wma_adjust_ibss_heart_beat_timer(wma, smesession_id, -1);
 #endif
 #endif
 
+	if (!rsp_requested) {
+		WMA_LOGD("%s: vdev_id %d status %d", __func__,
+			del_sta->smesessionId, del_sta->status);
+		vos_mem_free(del_sta);
+	}
 }
 
 static int32_t wmi_unified_vdev_stop_send(wmi_unified_t wmi, u_int8_t vdev_id)
@@ -14047,7 +14235,7 @@
 	if (VOS_STATUS_SUCCESS !=
 	vos_mq_post_message(VOS_MQ_ID_WDA, &vos_msg)) {
 		WMA_LOGP("%s: Failed to post WDA_TBTT_UPDATE_IND msg", __func__);
-		vos_mem_free(buf);
+		vos_mem_free(tempBuf);
 		return -1;
 	}
 	WMA_LOGD("WDA_TBTT_UPDATE_IND posted");
@@ -14154,9 +14342,8 @@
 		return;
 	     }
 	     wma->interfaces[vdev_id].vdev_up = TRUE;
+		 wma_set_sap_keepalive(wma, vdev_id);
 	}
-
-	wma_set_sap_keepalive(wma, vdev_id);
 }
 
 #if !defined(REMOVE_PKT_LOG) && !defined(QCA_WIFI_ISOC)
@@ -16938,6 +17125,7 @@
 	return VOS_STATUS_SUCCESS;
 }
 
+
 /*
  * Sends host wakeup indication to FW. On receiving this indication,
  * FW will come out of WOW.
@@ -16984,12 +17172,34 @@
 		WMA_LOGP("%s: Pending commands %d credits %d", __func__,
 				wmi_get_pending_cmds(wma->wmi_handle),
 				wmi_get_host_credits(wma->wmi_handle));
-		if (!vos_is_logp_in_progress(VOS_MODULE_ID_HIF, NULL))
+		if (!vos_is_logp_in_progress(VOS_MODULE_ID_HIF, NULL)) {
+			struct ol_softc *scn = vos_get_context(VOS_MODULE_ID_HIF, wma->vos_context);
+#ifndef CONFIG_CUST_PLATFORM
+			struct hif_usb_softc *sc = scn->hif_sc;
+#endif
 			VOS_BUG(0);
+			wmi_set_target_resumeok(wma->wmi_handle, FALSE);
+                        //do COLD Reset first
+			if (scn) {
+#ifndef CONFIG_CUST_PLATFORM
+				if (sc) {
+					HIFDiagWriteAccess(sc->hif_device, 0x800, 0x100);
+				}
+#endif
+	 			kobject_uevent(&scn->adf_dev->dev->kobj, KOBJ_OFFLINE);
+				printk(KERN_ERR "Send offline event\n");
+			}
+			else {
+				WMA_LOGE("%s: Failed to get HIF context", __func__);
+				VOS_ASSERT(0);
+				return VOS_STATUS_E_FAULT;
+			}
+                }
 		else
 			WMA_LOGE("%s: SSR in progress, ignore resume timeout", __func__);
 	} else {
 		WMA_LOGD("Host wakeup received");
+		wmi_set_target_resumeok(wma->wmi_handle, TRUE);
 	}
 
 	if (VOS_STATUS_SUCCESS == vos_status)
@@ -20051,7 +20261,7 @@
 	return VOS_STATUS_SUCCESS;
 }
 
-static int wma_get_hotlist_entries_per_page(void *cmd, int numap)
+static int wma_get_hotlist_entries_per_page(int cmd_len, int numap)
 {
 	uint32_t avail_space = 0;
 	int num_entries = 0;
@@ -20060,7 +20270,7 @@
 	 * be passed in  wma message request.
 	 */
 	avail_space = WMA_MAX_EXTSCAN_MSG_SIZE -
-				(sizeof(*cmd) - sizeof(WMI_TLV_HDR_SIZE));
+				(cmd_len - WMI_TLV_HDR_SIZE);
 	num_entries = avail_space / sizeof(wmi_extscan_hotlist_entry);
 	return num_entries;
 }
@@ -20082,8 +20292,7 @@
 	int numap = photlist->numAp;
 	int len = sizeof(*cmd);
 
-	len += WMI_TLV_HDR_SIZE;
-	cmd_len = len;
+	cmd_len = len + WMI_TLV_HDR_SIZE;
 
 	/* setbssid hotlist expects the bssid list
 	 * to be non zero value
@@ -20094,7 +20303,7 @@
 		return VOS_STATUS_E_INVAL;
 	}
 	num_entries = wma_get_hotlist_entries_per_page(
-					cmd, numap);
+					len, numap);
 
 	/* Split the hot list entry pages and send multiple command
 	 * requests if the buffer reaches  the maximum request size
@@ -21359,6 +21568,18 @@
 					(tHalHiddenSsidVdevRestart *)msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
 			break;
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+		case WDA_WLAN_EXT_WOW:
+			wma_enable_ext_wow(wma_handle,
+				(tSirExtWoWParams *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+		case WDA_WLAN_SET_APP_TYPE1_PARAMS:
+			wma_set_app_type1_params_in_fw(wma_handle,
+				(tSirAppType1Params *)msg->bodyptr);
+			vos_mem_free(msg->bodyptr);
+			break;
+#endif
 		case WDA_VDEV_START_RSP_IND:
 			wma_vdev_start_rsp_ind(wma_handle, msg->bodyptr);
 			vos_mem_free(msg->bodyptr);
@@ -22674,7 +22895,6 @@
         scan_event->p2pScanType = wma_handle->interfaces[vdev_id].scan_info.p2p_scan_type;
         scan_event->sessionId = vdev_id;
 
-        /* Reset scan info in interfaces table */
         wma_reset_scan_info(wma_handle, vdev_id);
 
         wma_send_msg(wma_handle, WDA_RX_SCAN_EVENT, (void *) scan_event, 0) ;
@@ -23409,29 +23629,29 @@
 					     struct hdd_tgt_vht_cap *cfg)
 {
 	/* Max MPDU length */
+#ifndef CONFIG_VD_PREVENT_DEADCODE
 	if (wh->vht_cap_info & IEEE80211_VHTCAP_MAX_MPDU_LEN_3839)
 		cfg->vht_max_mpdu = 0;
-	else if (wh->vht_cap_info & IEEE80211_VHTCAP_MAX_MPDU_LEN_7935)
-		cfg->vht_max_mpdu = 1;
-	else if (wh->vht_cap_info & IEEE80211_VHTCAP_MAX_MPDU_LEN_11454)
-		cfg->vht_max_mpdu = 2;
-	else
-		cfg->vht_max_mpdu = 0;
-
+	else 
+#endif
+	{
+		if (wh->vht_cap_info & IEEE80211_VHTCAP_MAX_MPDU_LEN_7935)
+			cfg->vht_max_mpdu = 1;
+		else if (wh->vht_cap_info & IEEE80211_VHTCAP_MAX_MPDU_LEN_11454)
+			cfg->vht_max_mpdu = 2;
+		else
+			cfg->vht_max_mpdu = 0;
+	}
 	/* supported channel width */
-	if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80)
-		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
-
-	else if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_160)
+	if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_160)
 		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_160MHZ;
 
 	else if (wh->vht_cap_info & IEEE80211_VHTCAP_SUP_CHAN_WIDTH_80_160) {
 		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
 		cfg->supp_chan_width |= 1 << eHT_CHANNEL_WIDTH_160MHZ;
 	}
-
 	else
-		cfg->supp_chan_width = 0;
+		cfg->supp_chan_width = 1 << eHT_CHANNEL_WIDTH_80MHZ;
 
 	/* LDPC capability */
 	cfg->vht_rx_ldpc = wh->vht_cap_info & IEEE80211_VHTCAP_RX_LDPC;
@@ -23688,7 +23908,7 @@
 
 	wma_handle->target_fw_version = ev->fw_build_vers;
 
-	WMA_LOGE("%s: Firmware build version : %08x",
+	pr_err("%s: Firmware build version : %08x",
 			__func__, ev->fw_build_vers);
 
 	if (ev->hw_bd_id) {
@@ -24582,6 +24802,37 @@
 
 	if (wmi_pending_cmds) {
 		WMA_LOGE("Failed to deliver WMI_PDEV_RESUME_CMDID command %d\n", timeout);
+		/*
+			Trigger SSR since Target maybe already dead
+		*/
+		if (!vos_is_logp_in_progress(VOS_MODULE_ID_HIF, NULL)) {
+			struct ol_softc *scn = vos_get_context(VOS_MODULE_ID_HIF, wma_handle->vos_context);
+#ifndef CONFIG_CUST_PLATFORM
+			struct hif_usb_softc *sc = scn->hif_sc;
+#endif
+			VOS_BUG(0);
+			wmi_set_target_resumeok(wma_handle->wmi_handle, FALSE);
+			//trigger SSR
+			if (scn) {
+                //do COLD Reset first
+#ifndef CONFIG_CUST_PLATFORM
+				if (sc) {
+					HIFDiagWriteAccess(sc->hif_device, 0x800, 0x100);
+				}
+#endif
+	 			kobject_uevent(&scn->adf_dev->dev->kobj, KOBJ_OFFLINE);
+				printk(KERN_ERR "Send offline event\n");
+			}
+			else {
+				WMA_LOGE("%s: Failed to get HIF context", __func__);
+#ifndef CONFIG_CUST_PLATFORM
+				VOS_ASSERT(0);
+#endif
+				return -1;
+			}
+        }
+		else
+			WMA_LOGE("%s: SSR in progress, ignore resume fail", __func__);
 		ret = -1;
 	}
 
@@ -25058,10 +25309,10 @@
 		WMITLV_GET_STRUCT_TLVLEN(
 			wmi_pdev_set_regdomain_cmd_fixed_param));
 	cmd->reg_domain = reg_dmn;
-	cmd->reg_domain_2G = regdmn2G;
-	cmd->reg_domain_5G = regdmn5G;
-	cmd->conformance_test_limit_2G = ctl2G;
-	cmd->conformance_test_limit_5G = ctl5G;
+	cmd->reg_domain_2G = (A_UINT32)regdmn2G;
+	cmd->reg_domain_5G = (A_UINT32)regdmn5G;
+	cmd->conformance_test_limit_2G = (A_UINT32)ctl2G;
+	cmd->conformance_test_limit_5G = (A_UINT32)ctl5G;
 
 	if (wmi_unified_cmd_send(wma->wmi_handle, buf, len,
 				WMI_PDEV_SET_REGDOMAIN_CMDID)) {
@@ -25746,17 +25997,6 @@
 	u_int32_t regdmn = wma->reg_cap.eeprom_rd;
 	u_int32_t regdmn5G;
 
-	if (regdmn < 0)
-	{
-		WMA_LOGE("%s:DFS-Invalid regdomain",__func__);
-		/*
-		 * Set the DFS reg domain to unintlialized domain
-		 * to indicate dfs regdomain configuration failure
-		 */
-		wma->dfs_ic->current_dfs_regdomain = DFS_UNINIT_DOMAIN;
-		return;
-	}
-
 	regdmn5G = get_regdmn_5g(regdmn);
 	ctl = regdmn_get_ctl_for_regdmn(regdmn5G);
 
diff -urN qcacld-new.orig/CORE/SERVICES/WMA/wma.h qcacld-new/CORE/SERVICES/WMA/wma.h
--- qcacld-new.orig/CORE/SERVICES/WMA/wma.h	2016-05-16 10:58:07.366298648 +0800
+++ qcacld-new/CORE/SERVICES/WMA/wma.h	2016-05-16 10:58:08.790298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -510,6 +511,7 @@
 #endif
 	v_BOOL_t ps_enabled;
 	u_int32_t dtim_policy;
+	u_int32_t peer_count;
 	v_BOOL_t roam_synch_in_progress;
 };
 
@@ -626,7 +628,6 @@
 	u_int32_t scan_id;
 	struct wma_txrx_node *interfaces;
 	pdev_cli_config_t pdevconfig;
-	u_int32_t peer_count;
 	struct list_head vdev_resp_queue;
 	adf_os_spinlock_t vdev_respq_lock;
         adf_os_spinlock_t vdev_detach_lock;
diff -urN qcacld-new.orig/CORE/SERVICES/WMI/wmi_tlv_helper.c qcacld-new/CORE/SERVICES/WMI/wmi_tlv_helper.c
--- qcacld-new.orig/CORE/SERVICES/WMI/wmi_tlv_helper.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/WMI/wmi_tlv_helper.c	2016-05-16 10:58:08.834298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /* wmi_tlv_platform.c file will be different for different components like Pronto firmware, Pronto windows host driver,
      Pronto LA host driver because their memory management functions are different */
@@ -63,8 +64,9 @@
 
 
 #ifdef NO_DYNAMIC_MEM_ALLOC
-static wmitlv_cmd_param_info *g_WmiStaticCmdParamInfoBuf = NULL;
-A_UINT32                      g_WmiStaticMaxCmdParamTlvs=0;
+static wmitlv_cmd_param_info g_WmiStaticCmdParamInfoarray[256];
+static wmitlv_cmd_param_info *g_WmiStaticCmdParamInfoBuf = g_WmiStaticCmdParamInfoarray;
+A_UINT32                      g_WmiStaticMaxCmdParamTlvs=256;
 #endif
 
 /* TLV helper routines */
diff -urN qcacld-new.orig/CORE/SERVICES/WMI/wmi_unified.c qcacld-new/CORE/SERVICES/WMI/wmi_unified.c
--- qcacld-new.orig/CORE/SERVICES/WMI/wmi_unified.c	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/WMI/wmi_unified.c	2016-05-16 10:58:08.834298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 /*
@@ -172,7 +173,7 @@
 		CASE_RETURN_STRING(WMI_PDEV_GET_TPC_CONFIG_CMDID);
 
 		/** set the base MAC address for the physical device before a VDEV is created.
-		 *  For firmware that doesnt support this feature and this command, the pdev
+		 *  For firmware that doesnt support this feature and this command, the pdev
 		 *  MAC address will not be changed. */
 		CASE_RETURN_STRING(WMI_PDEV_SET_BASE_MACADDR_CMDID);
 
@@ -599,7 +600,7 @@
 	if (adf_os_atomic_read(&wmi_handle->is_target_suspended) &&
 		( (WMI_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID != cmd_id) &&
 		  (WMI_PDEV_RESUME_CMDID != cmd_id)) ){
-		pr_err("%s: Target is suspended  could not send WMI command\n", __func__);
+		pr_err("%s: Target is suspended  could not send WMI command 0x%x\n", __func__, cmd_id);
 		VOS_ASSERT(0);
 		return -EBUSY;
 	}
@@ -893,6 +894,8 @@
     wmi_handle->scn_handle = scn_handle;
     adf_os_atomic_init(&wmi_handle->pending_cmds);
     adf_os_atomic_init(&wmi_handle->is_target_suspended);
+    adf_os_atomic_init(&wmi_handle->is_target_resumeok);
+    wmi_set_target_resumeok(wmi_handle, TRUE);
 #ifndef QCA_WIFI_ISOC
     adf_os_spinlock_init(&wmi_handle->eventq_lock);
     adf_nbuf_queue_init(&wmi_handle->event_queue);
@@ -909,15 +912,16 @@
 {
 #ifndef QCA_WIFI_ISOC
     wmi_buf_t buf;
-
-    vos_flush_work(&wmi_handle->rx_event_work);
-    adf_os_spin_lock_bh(&wmi_handle->eventq_lock);
-    buf = adf_nbuf_queue_remove(&wmi_handle->event_queue);
-    while (buf) {
-	adf_nbuf_free(buf);
-	buf = adf_nbuf_queue_remove(&wmi_handle->event_queue);
+    if ( wmi_handle != NULL) {
+        vos_flush_work(&wmi_handle->rx_event_work);
+        adf_os_spin_lock_bh(&wmi_handle->eventq_lock);
+        buf = adf_nbuf_queue_remove(&wmi_handle->event_queue);
+        while (buf) {
+            adf_nbuf_free(buf);
+            buf = adf_nbuf_queue_remove(&wmi_handle->event_queue);
+        }
+        adf_os_spin_unlock_bh(&wmi_handle->eventq_lock);
     }
-    adf_os_spin_unlock_bh(&wmi_handle->eventq_lock);
 #endif
     if (wmi_handle != NULL) {
         OS_FREE(wmi_handle);
@@ -1003,3 +1007,8 @@
 {
 	adf_os_atomic_set(&wmi_handle->is_target_suspended, val);
 }
+
+void wmi_set_target_resumeok(wmi_unified_t wmi_handle, A_BOOL val)
+{
+	adf_os_atomic_set(&wmi_handle->is_target_resumeok, val);
+}
\ No newline at end of file
diff -urN qcacld-new.orig/CORE/SERVICES/WMI/wmi_unified_priv.h qcacld-new/CORE/SERVICES/WMI/wmi_unified_priv.h
--- qcacld-new.orig/CORE/SERVICES/WMI/wmi_unified_priv.h	2016-05-16 10:58:07.398298648 +0800
+++ qcacld-new/CORE/SERVICES/WMI/wmi_unified_priv.h	2016-05-16 10:58:08.834298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -92,5 +93,6 @@
 #endif /*WMI_INTERFACE_EVENT_LOGGING*/
 
 	adf_os_atomic_t  is_target_suspended;
+	adf_os_atomic_t  is_target_resumeok;
 };
 #endif
diff -urN qcacld-new.orig/CORE/SME/inc/csrApi.h qcacld-new/CORE/SME/inc/csrApi.h
--- qcacld-new.orig/CORE/SME/inc/csrApi.h	2016-05-16 10:58:06.590298648 +0800
+++ qcacld-new/CORE/SME/inc/csrApi.h	2016-05-16 10:58:08.746298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2011-2014 Qualcomm Atheros, Inc.
@@ -1762,6 +1763,11 @@
 eCsrBand csrGetCurrentBand (tHalHandle hHal);
 
 typedef void (*csrReadyToSuspendCallback)(void *pContext, boolean suspended);
+
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+typedef void (*csrReadyToExtWoWCallback)(void *pContext, boolean status);
+#endif
+
 #ifdef WLAN_FEATURE_ROAM_OFFLOAD
 eHalStatus csrRoamIssueFTRoamOffloadSynch(tHalHandle hHal, tANI_U32 sessionId,
                                           tSirBssDescription *pBssDescription);
diff -urN qcacld-new.orig/CORE/SME/inc/sme_Api.h qcacld-new/CORE/SME/inc/sme_Api.h
--- qcacld-new.orig/CORE/SME/inc/sme_Api.h	2016-05-16 10:58:06.590298648 +0800
+++ qcacld-new/CORE/SME/inc/sme_Api.h	2016-05-16 10:58:08.746298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
@@ -2191,6 +2192,51 @@
 eHalStatus sme_ConfigureResumeReq( tHalHandle hHal,
                              tpSirWlanResumeParam  wlanResumeParam);
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureExtWoW
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanExtParams- Depicts the wlan Ext params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureExtWoW( tHalHandle hHal,
+                          tpSirExtWoWParams  wlanExtParams,
+                          csrReadyToSuspendCallback callback,
+                          void *callbackContext);
+
+
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType1Params
+
+  \brief
+    SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType1Params- Depicts the wlan Indoor params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType1Params( tHalHandle hHal,
+                          tpSirAppType1Params  wlanAppType1Params);
+
+#endif
 
 /* ---------------------------------------------------------------------------
 
diff -urN qcacld-new.orig/CORE/SME/inc/sme_Trace.h qcacld-new/CORE/SME/inc/sme_Trace.h
--- qcacld-new.orig/CORE/SME/inc/sme_Trace.h	2016-05-16 10:58:06.598298648 +0800
+++ qcacld-new/CORE/SME/inc/sme_Trace.h	2016-05-16 10:58:08.746298648 +0800
@@ -112,6 +112,11 @@
     TRACE_CODE_SME_RX_HDD_CONFIG_RXPFIL,
     TRACE_CODE_SME_RX_HDD_CONFIG_SUSPENDIND,
     TRACE_CODE_SME_RX_HDD_CONFIG_RESUMEREQ,
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+    TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW,
+    TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1,
+    TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2,
+#endif
     TRACE_CODE_SME_RX_HDD_SET_MAXTXPOW,
     TRACE_CODE_SME_RX_HDD_SET_TXPOW,
     TRACE_CODE_SME_RX_HDD_SET_TMLEVEL,
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c qcacld-new/CORE/SME/src/csr/csrApiRoam.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiRoam.c	2016-05-16 10:58:06.662298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiRoam.c	2016-05-16 10:58:08.750298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -261,7 +261,9 @@
 void csrRoamJoinRetryTimerHandler(void *pv);
 #endif
 extern void SysProcessMmhMsg(tpAniSirGlobal pMac, tSirMsgQ* pMsg);
+#ifdef WLAN_BTAMP_FEATURE
 extern void btampEstablishLogLinkHdlr(void* pMsg);
+#endif
 static void csrSerDesUnpackDiassocRsp(tANI_U8 *pBuf, tSirSmeDisassocRsp *pRsp);
 void csrReinitPreauthCmd(tpAniSirGlobal pMac, tSmeCmd *pCommand);
 
@@ -401,11 +403,13 @@
     /* Copy 2 or 3 bytes country code */
     vos_mem_copy(pMac->scan.countryCodeDefault, apCntryCode, cntryCodeLength);
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     /* If 2 bytes country code, 3rd byte must be filled with space */
     if((WNI_CFG_COUNTRY_CODE_LEN - 1) == cntryCodeLength)
     {
         vos_mem_set(pMac->scan.countryCodeDefault + 2, 1, 0x20);
     }
+#endif
     vos_mem_copy(pMac->scan.countryCodeCurrent, pMac->scan.countryCodeDefault,
                  WNI_CFG_COUNTRY_CODE_LEN);
     status = csrInitGetChannels( pMac );
@@ -2341,8 +2345,9 @@
   tANI_U32 count=0;
   tSirMacChanInfo *pChanInfo;
   tSirMacChanInfo *pChanInfoStart;
+#if 0
   tANI_BOOLEAN applyConfig = TRUE;
-
+#endif
   pMac->scan.currentCountryRSSI = -128;
   if(!ps11dinfo)
   {
@@ -2397,6 +2402,7 @@
       vos_mem_free(pChanInfoStart);
   }
   //Only apply them to CFG when not in STOP state. Otherwise they will be applied later
+#if 0 //currently this is not applied but it should .marked it out first as this is not a target feature at this time.
   if( HAL_STATUS_SUCCESS(status) )
   {
       for( index = 0; index < CSR_ROAM_SESSION_MAX; index++ )
@@ -2414,6 +2420,7 @@
     }
 
   }
+#endif
   return (status);
 }
 /* Initialize the Channel + Power List in the local cache and in the CFG */
@@ -3014,7 +3021,11 @@
 {
     eHalStatus status = eHAL_STATUS_SUCCESS;
     eCsrCfgDot11Mode cfgDot11Mode;
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD( pIes != NULL );
+#else
     VOS_ASSERT( pIes != NULL );
+#endif
     if (pIes == NULL)
         return eHAL_STATUS_FAILURE;
 
@@ -3544,7 +3555,11 @@
     tANI_U16 rateBitmap = 0;
     vos_mem_set(pOpRateSet, sizeof(tSirMacRateSet), 0);
     vos_mem_set(pExRateSet, sizeof(tSirMacRateSet), 0);
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD( pIes != NULL );
+#else
     VOS_ASSERT( pIes != NULL );
+#endif
 
     if( NULL != pIes )
     {
@@ -3619,7 +3634,11 @@
     tANI_U32 PropRatesEnable = 0;
     tANI_U8 MCSRateIdxSet[ SIZE_OF_SUPPORTED_MCS_SET ];
     tANI_U32 MCSRateLength = 0;
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD( pIes != NULL );
+#else
     VOS_ASSERT( pIes != NULL );
+#endif
     if( NULL != pIes )
     {
         csrIsPhyModeMatch( pMac, phyMode, pBssDesc, pProfile, &cfgDot11Mode, pIes );
@@ -6126,6 +6145,23 @@
 #ifndef WLAN_MDM_CODE_REDUCTION_OPT
             sme_QosCsrEventInd(pMac, (tANI_U8)sessionId, SME_QOS_CSR_REASSOC_FAILURE, NULL);
 #endif
+
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+            smsLog(pMac, LOGW, FL("failed to join WDS"));
+            csrFreeConnectBssDesc(pMac, sessionId);
+            csrRoamFreeConnectProfile(pMac, &pSession->connectedProfile);
+            csrRoamFreeConnectedInfo( pMac, &pSession->connectedInfo );
+            vos_mem_set(&roamInfo, sizeof(tCsrRoamInfo), 0);
+            roamInfo.pBssDesc = pCommand->u.roamCmd.pLastRoamBss;
+            roamInfo.statusCode = pSession->joinFailStatusCode.statusCode;
+            roamInfo.reasonCode = pSession->joinFailStatusCode.reasonCode;
+            csrRoamCallCallback(pMac, sessionId, &roamInfo, pCommand->u.roamCmd.roamId,
+            						eCSR_ROAM_WDS_IND,
+            						eCSR_ROAM_RESULT_WDS_NOT_ASSOCIATED);
+            //Need to issue stop_bss
+            break;
+#endif
+
         case eCsrJoinWdsFailure:
             smsLog(pMac, LOGW, FL("failed to join WDS"));
             csrFreeConnectBssDesc(pMac, sessionId);
@@ -6553,7 +6589,9 @@
     do
     {
         vos_mem_set(pDstProfile, sizeof(tCsrRoamProfile), 0);
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         if(pSrcProfile->bssid)
+#endif
         {
             pDstProfile->BSSIDs.bssid = vos_mem_malloc(sizeof(tCsrBssid));
             if ( NULL == pDstProfile->BSSIDs.bssid )
@@ -6568,7 +6606,9 @@
             vos_mem_copy(pDstProfile->BSSIDs.bssid, pSrcProfile->bssid,
                          sizeof(tCsrBssid));
         }
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         if(pSrcProfile->SSID.ssId)
+#endif
         {
             pDstProfile->SSIDs.SSIDList = vos_mem_malloc(sizeof(tCsrSSIDInfo));
             if ( NULL == pDstProfile->SSIDs.SSIDList )
@@ -6922,6 +6962,7 @@
         {
             vos_mem_set(pScanFilter, sizeof(tCsrScanResultFilter), 0);
             //Try to connect to any BSS
+#ifndef CONFIG_VD_PREVENT_DEADCODE
             if(NULL == pProfile)
             {
                 //No encryption
@@ -6929,6 +6970,7 @@
                 pScanFilter->EncryptionType.encryptionType[0] = eCSR_ENCRYPT_TYPE_NONE;
             }//we don't have a profile
             else
+#endif
             {
                 //Here is the profile we need to connect to
                 status = csrRoamPrepareFilterFromProfile(pMac, pProfile, pScanFilter);
@@ -7013,10 +7055,12 @@
                             }
                         }
                     }
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
                     else
                     {
                         fCallCallback = eANI_BOOLEAN_TRUE;
                     }
+#endif
                 } while (0);
                 if(NULL != pProfile)
                 {
@@ -7069,17 +7113,13 @@
             smsLog(pMac, LOG1, FL("Not connected to the same SSID asked in the profile"));
          }
       }
-      else if (!vos_mem_compare(&modProfileFields,
-                                &pSession->connectedProfile.modifyProfileFields,
-                                sizeof(tCsrRoamModifyProfileFields)))
-      {
-         fCallCallback = eANI_BOOLEAN_FALSE;
-      }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
       else
       {
          smsLog(pMac, LOG1, FL("Either the profile is NULL or none of the fields "
                                "in tCsrRoamModifyProfileFields got modified"));
       }
+#endif
    }
    else
    {
@@ -8040,7 +8080,11 @@
                 if ( NULL == pScanResult)
                 {
                    // If we are roaming TO an Infrastructure BSS...
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+                   VOS_ASSERT_VD(pScanResult != NULL);
+#else
                    VOS_ASSERT(pScanResult != NULL);
+#endif
                    return;
                 }
                 if ( csrIsInfraBssDesc( pBssDesc ) )
@@ -8459,8 +8503,10 @@
             csrFreeScanFilter(pMac, pScanFilter);
             vos_mem_free(pScanFilter);
         }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if (pCurRoamProfile)
             vos_mem_free(pCurRoamProfile);
+#endif
 
         /* Inform the upper layers that the reassoc failed */
         vos_mem_zero(&roamInfo, sizeof(tCsrRoamInfo));
@@ -8578,9 +8624,7 @@
                           pSmeRsp->messageType, pSmeRsp->messageType,
                           macTraceGetcsrRoamSubState(
                           pMac->roam.curSubState[pSmeRsp->sessionId]));
-    pSmeRsp->messageType = (pSmeRsp->messageType);
-    pSmeRsp->length = (pSmeRsp->length);
-    pSmeRsp->statusCode = (pSmeRsp->statusCode);
+
     switch (pSmeRsp->messageType)
     {
 
@@ -10594,11 +10638,12 @@
             csrRoamCallCallback(pMac, sessionId, &roamInfo, 0,
                     eCSR_ROAM_INFRA_IND, eCSR_ROAM_RESULT_MAX_ASSOC_EXCEEDED);
             break;
-
+#ifdef WLAN_BTAMP_FEATURE
         case eWNI_SME_BTAMP_LOG_LINK_IND:
             smsLog( pMac, LOG1, FL("Establish logical link req from HCI serialized through MC thread"));
             btampEstablishLogLinkHdlr( pSirMsg );
             break;
+#endif
         case eWNI_SME_RSSI_IND:
             smsLog( pMac, LOG1, FL("RSSI indication from TL serialized through MC thread"));
             csrRoamRssiIndHdlr( pMac, pSirMsg );
@@ -10804,11 +10849,20 @@
     tCsrRoamSession *pSession = CSR_GET_SESSION( pMac, pInfo->sessionId );
     eHalStatus status = eHAL_STATUS_FAILURE;
 
-    smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
-           macTraceGetNeighbourRoamState(
-           pMac->roam.neighborRoamInfo.neighborRoamState),
-           macTraceGetcsrRoamSubState(
-           pMac->roam.curSubState[pInfo->sessionId]));
+	
+if (pInfo->sessionId < CSR_ROAM_SESSION_MAX) {
+		smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s sub-state=%s"),
+			macTraceGetNeighbourRoamState(
+			pMac->roam.neighborRoamInfo.neighborRoamState),
+			macTraceGetcsrRoamSubState(
+			pMac->roam.curSubState[pInfo->sessionId]));
+	} else {
+		smsLog(pMac, LOGW, FL("WaitForKey timer expired in state=%s pInfo->sessionId (%d) exceed! "),
+			macTraceGetNeighbourRoamState(
+			pMac->roam.neighborRoamInfo.neighborRoamState),
+			pInfo->sessionId);
+		return;
+	}
 
     if( CSR_IS_WAIT_FOR_KEY( pMac, pInfo->sessionId ) )
     {
@@ -11632,9 +11686,14 @@
                                         "\x00\x0f\xac\x02" ,4))
                || (((NULL != &(pIes->WPA)) &&
                     (pIes->WPA.unicast_cipher_count == 1))
+#ifdef CONFIG_VD_PREVENT_NO_EFFECT        
+                    && !memcmp(&(pIes->WPA.unicast_ciphers[0]),
+                    		  "\x00\x0f\xac\x02", 4)))
+#else
                     && ((NULL != &(pIes->WPA.unicast_ciphers[0]))
-                        && !memcmp(&(pIes->WPA.unicast_ciphers[0]),
-                                  "\x00\x0f\xac\x02", 4))))
+                 	&& !memcmp(&(pIes->WPA.unicast_ciphers[0]),
+                 			  "\x00\x0f\xac\x02", 4))))
+#endif                    
             {
                 smsLog(pMac, LOGW, " No channel bonding in TKIP mode ");
                 eRet = PHY_SINGLE_CHANNEL_CENTERED;
@@ -11943,10 +12002,16 @@
 
     switch ( nwType )
     {
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+        default:
+        case eSIR_11A_NW_TYPE:
+        if (eSIR_11A_NW_TYPE != nwType) 
+            smsLog(pMac, LOGE, FL("sees an unknown pSirNwType (%d)"), nwType);
+#else
         default:
             smsLog(pMac, LOGE, FL("sees an unknown pSirNwType (%d)"), nwType);
         case eSIR_11A_NW_TYPE:
-
+#endif
             pParam->operationalRateSet.numRates = 8;
 
             pParam->operationalRateSet.rate[0] = SIR_MAC_RATE_6 | CSR_DOT11_BASIC_RATE_MASK;
@@ -13735,20 +13800,16 @@
             status = eHAL_STATUS_SUCCESS;
             pBuf = pBuf + sizeof ( tSirMacAddr );
         }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if(!HAL_STATUS_SUCCESS(status))
         {
             vos_mem_free(pMsg);
             break;
         }
+#endif
         // reasonCode
         wTmp = pal_cpu_to_be16(reasonCode);
         vos_mem_copy(pBuf, &wTmp, sizeof(tANI_U16));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         pBuf += sizeof(tANI_U16);
         /* The state will be DISASSOC_HANDOFF only when we are doing handoff.
                     Here we should not send the disassoc over the air to the AP */
@@ -13790,15 +13851,9 @@
         pBuf += sizeof(tANI_U16);
         // bssid
         vos_mem_copy(pMsg->bssId, bssId, sizeof( tSirMacAddr ));
-        status = eHAL_STATUS_SUCCESS;
         pBuf = pBuf + sizeof ( tSirMacAddr );
         // bEnable
         *pBuf = (tANI_BOOLEAN)bEnable;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -13868,7 +13923,11 @@
 
         if( NULL == pBuf)
         {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+           VOS_ASSERT_VD(pBuf);
+#else
            VOS_ASSERT(pBuf);
+#endif
            return eHAL_STATUS_FAILURE;
         }
         wTmpBuf = pBuf;
@@ -14020,28 +14079,18 @@
             status = eHAL_STATUS_SUCCESS;
             pBuf =  pBuf + sizeof(tSirMacAddr);
         }
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if(!HAL_STATUS_SUCCESS(status))
         {
             vos_mem_free(pMsg);
             break;
         }
+#endif
                 // Set the peer MAC address before sending the message to LIM
         vos_mem_copy( (tSirMacAddr *) pBuf, bssId, sizeof( pMsg->peerMacAddr ) );
-        status = eHAL_STATUS_SUCCESS;
         pBuf =  pBuf + sizeof(tSirMacAddr);
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         wTmp = pal_cpu_to_be16(reasonCode);
         vos_mem_copy( pBuf, &wTmp,sizeof( tANI_U16 ) );
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -14064,20 +14113,8 @@
         pMsg->length = pal_cpu_to_be16((tANI_U16)sizeof( tSirSmeDisassocCnf ));
         vos_mem_copy(pMsg->peerMacAddr, pDisassocInd->peerMacAddr,
                      sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
 //To test reconn
         vos_mem_copy(pMsg->bssId, pDisassocInd->bssId, sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
 //To test reconn ends
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
@@ -14100,20 +14137,8 @@
         pMsg->statusCode = (tSirResultCodes)pal_cpu_to_be32(eSIR_SME_SUCCESS);
         pMsg->length = pal_cpu_to_be16((tANI_U16)sizeof( tSirSmeDeauthCnf ));
         vos_mem_copy(pMsg->bssId, pDeauthInd->bssId, sizeof(pMsg->bssId));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         vos_mem_copy(pMsg->peerMacAddr, pDeauthInd->peerMacAddr,
                      sizeof(pMsg->peerMacAddr));
-        status = eHAL_STATUS_SUCCESS;
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            vos_mem_free(pMsg);
-            break;
-        }
         status = palSendMBMessage( pMac->hHdd, pMsg );
     } while( 0 );
     return( status );
@@ -15676,17 +15701,23 @@
       pMac->roam.configParam.vccUlMacLossThreshold;
    if (0 == ul_mac_loss_trigger_threshold)
    {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+      VOS_ASSERT_VD( ul_mac_loss_trigger_threshold != 0 );
+#else
       VOS_ASSERT( ul_mac_loss_trigger_threshold != 0 );
+#endif
       return;
    }
    smsLog(pMac, LOGW, "csrRoamVccTrigger: UL_MAC_LOSS_THRESHOLD is %d",
           ul_mac_loss_trigger_threshold );
+#ifndef CONFIG_VD_PREVENT_DEADCODE   
    if(ul_mac_loss_trigger_threshold < ul_mac_loss)
    {
       smsLog(pMac, LOGW, "csrRoamVccTrigger: link quality is POOR ");
       newVccLinkQuality = eCSR_ROAM_LINK_QUAL_POOR_IND;
    }
    else
+#endif
    {
       smsLog(pMac, LOGW, "csrRoamVccTrigger: link quality is GOOD");
       newVccLinkQuality = eCSR_ROAM_LINK_QUAL_GOOD_IND;
@@ -17421,6 +17452,10 @@
                     case eCsrForcedDisassoc:
                     case eCsrForcedDisassocMICFailure:
                         reason = eSME_LINK_DISCONNECTED_BY_HDD;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+                        fNeedFullPower = eANI_BOOLEAN_TRUE;
+                        break;
+#endif
                     case eCsrSmeIssuedDisassocForHandoff:
                     case eCsrForcedDeauth:
                     case eCsrHddIssuedReassocToSameAP:
@@ -17621,7 +17656,11 @@
 
         if (NULL == pBuf)
         {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+           VOS_ASSERT_VD(pBuf);
+#else
            VOS_ASSERT(pBuf);
+#endif
            return eHAL_STATUS_FAILURE;
         }
 
@@ -17666,7 +17705,11 @@
 
         if (NULL == pBuf)
         {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+           VOS_ASSERT_VD(pBuf);
+#else
            VOS_ASSERT(pBuf);
+#endif
            return eHAL_STATUS_FAILURE;
         }
         // transactionId
@@ -18273,7 +18316,6 @@
            FL("Failed to send eWNI_SME_UPDATE_ADDTIONAL_IES msg"
            "!!! status %d"), status);
        vos_mem_free(pLocalBuffer);
-       vos_mem_free(pModifyAddIEInd);
     }
     return status;
 }
@@ -18346,7 +18388,6 @@
            FL("Failed to send eWNI_SME_UPDATE_ADDTIONAL_IES msg"
            "!!! status %d"), status);
        vos_mem_free(pLocalBuffer);
-       vos_mem_free(pUpdateAddIEs);
     }
     return status;
 }
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c qcacld-new/CORE/SME/src/csr/csrApiScan.c
--- qcacld-new.orig/CORE/SME/src/csr/csrApiScan.c	2016-05-16 10:58:06.686298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrApiScan.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /** ------------------------------------------------------------------------- *
     ------------------------------------------------------------------------- *
@@ -428,13 +429,6 @@
             vos_mem_copy(pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList,
                          pMac->scan.baseChannels.channelList, numChn);
             status = eHAL_STATUS_SUCCESS;
-            if( !HAL_STATUS_SUCCESS( status ) )
-            {
-                vos_mem_free(pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList);
-                pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.ChannelList = NULL;
-                smsLog( pMac, LOGE, FL(" Failed to copy memory to channel list ") );
-                return eHAL_STATUS_FAILURE;
-            }
             pScanCmd->u.scanCmd.u.scanRequest.ChannelInfo.numOfChannels = numChn;
         }
 
@@ -598,7 +592,11 @@
     tANI_U8 channelList2G[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
     static tANI_U8 validchannelList[CSR_MAX_2_4_GHZ_SUPPORTED_CHANNELS] = {0};
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD(pScanCmd && pScanRequest);
+#else
     VOS_ASSERT(pScanCmd && pScanRequest);
+#endif
     /* To silence the KW tool null check is added */
     if((pScanCmd == NULL) || (pScanRequest == NULL))
     {
@@ -818,7 +816,7 @@
                         {
                             scanReq.bcnRptReqScan = pScanRequest->bcnRptReqScan;
                             if (pScanRequest->bcnRptReqScan)
-                                scanReq.scanType = pScanRequest->scanType ?
+                                scanReq.scanType = (pScanRequest->scanType != eSIR_PASSIVE_SCAN) ?
                                                    eSIR_PASSIVE_SCAN :
                                                    pScanRequest->scanType;
                             else
@@ -831,7 +829,7 @@
                         else
                         {
                             scanReq.bcnRptReqScan = pScanRequest->bcnRptReqScan;
-                            if (pScanRequest->bcnRptReqScan)
+                            if (pScanRequest->bcnRptReqScan != 0)
                                 scanReq.scanType = pScanRequest->scanType;
                             else
                                 scanReq.scanType = eSIR_ACTIVE_SCAN;
@@ -2843,7 +2841,9 @@
                 (0x00 == pbIe[2]) && (0x50 == pbIe[3]) && (0xf2 == pbIe[4]) && (0x04 == pbIe[5]))
             {
                 //Founrd it
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
                 if((DOT11F_IE_WSCPROBERES_MAX_LEN - 2) >= pbIe[1])
+#endif
                 {
                     vos_mem_copy(pNewBssDescr->WscIeProbeRsp, pbIe, pbIe[1] + 2);
                     pNewBssDescr->WscIeLen = pbIe[1] + 2;
@@ -3118,7 +3118,9 @@
     tANI_S8         rssi_of_current_country;
     tANI_BOOLEAN    fDupBss;
 #ifdef FEATURE_WLAN_WAPI
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     tANI_BOOLEAN fNewWapiBSSForCurConnection = eANI_BOOLEAN_FALSE;
+#endif
 #endif /* FEATURE_WLAN_WAPI */
     tDot11fBeaconIEs *pIesLocal = NULL;
     tANI_U32 sessionId = CSR_SESSION_ID_INVALID;
@@ -3328,11 +3330,13 @@
     }
 
 #ifdef FEATURE_WLAN_WAPI
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if(fNewWapiBSSForCurConnection)
     {
         //remember it first
         csrRoamCallCallback(pMac, sessionId, NULL, 0, eCSR_ROAM_SCAN_FOUND_NEW_BSS, eCSR_ROAM_RESULT_NEW_WAPI_BSS);
     }
+#endif
 #endif /* FEATURE_WLAN_WAPI */
 
     return;
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrNeighborRoam.c qcacld-new/CORE/SME/src/csr/csrNeighborRoam.c
--- qcacld-new.orig/CORE/SME/src/csr/csrNeighborRoam.c	2016-05-16 10:58:06.726298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrNeighborRoam.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 /** ------------------------------------------------------------------------- *
@@ -1095,7 +1096,11 @@
     tpCsrNeighborRoamControlInfo    pNeighborRoamInfo = &pMac->roam.neighborRoamInfo;
     tANI_U8 i = 0;
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD(pScanFilter != NULL);
+#else
     VOS_ASSERT(pScanFilter != NULL);
+#endif
     if (pScanFilter == NULL)
         return eHAL_STATUS_FAILURE;
     vos_mem_zero(pScanFilter, sizeof(tCsrScanResultFilter));
@@ -1611,7 +1616,11 @@
     tCsrRoamConnectedProfile *pCurProfile = &pMac->roam.roamSession[sessionId].connectedProfile;
     tANI_U8 i = 0;
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+    VOS_ASSERT_VD(pScanFilter != NULL);
+#else
     VOS_ASSERT(pScanFilter != NULL);
+#endif
     if (pScanFilter == NULL)
         return eHAL_STATUS_FAILURE;
 
@@ -1703,7 +1712,7 @@
         tCsrScanResultInfo *pScanResult;
         tpCsrNeighborRoamControlInfo    pNeighborRoamInfo = &pMac->roam.neighborRoamInfo;
 #ifdef FEATURE_WLAN_LFR
-        tANI_U32 CurrAPRssi = pNeighborRoamInfo->lookupDOWNRssi;
+        tANI_U32 CurrAPRssi = abs(pNeighborRoamInfo->lookupDOWNRssi);
 #else
         /* We are setting this as default value to make sure we return this value,
         when we do not see this AP in the scan result for some reason.However,it is
@@ -4241,7 +4250,11 @@
 
     if (WLANTL_HO_THRESHOLD_UP != rssiNotification)
     {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+       VOS_ASSERT_VD(WLANTL_HO_THRESHOLD_UP == rssiNotification);
+#else
        VOS_ASSERT(WLANTL_HO_THRESHOLD_UP == rssiNotification);
+#endif
        return VOS_STATUS_E_FAILURE;
     }
     vosStatus = csrNeighborRoamNeighborLookupUpEvent(pMac);
@@ -4285,7 +4298,11 @@
 
     if (WLANTL_HO_THRESHOLD_DOWN != rssiNotification)
     {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+       VOS_ASSERT_VD(WLANTL_HO_THRESHOLD_DOWN == rssiNotification);
+#else
        VOS_ASSERT(WLANTL_HO_THRESHOLD_DOWN == rssiNotification);
+#endif
        return VOS_STATUS_E_FAILURE;
     }
     vosStatus = csrNeighborRoamNeighborLookupDownEvent(pMac);
@@ -4431,6 +4448,21 @@
         case eCSR_NEIGHBOR_ROAM_STATE_PREAUTH_DONE:
             /* Stop pre-auth to reassoc interval timer */
             vos_timer_stop(&pMac->ft.ftSmeContext.preAuthReassocIntvlTimer);
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+            CSR_NEIGHBOR_ROAM_STATE_TRANSITION(eCSR_NEIGHBOR_ROAM_STATE_INIT)
+            pNeighborRoamInfo->roamChannelInfo.IAPPNeighborListReceived = eANI_BOOLEAN_FALSE;
+            csrNeighborRoamResetPreauthControlInfo(pMac);
+            csrNeighborRoamResetReportScanStateControlInfo(pMac);
+#ifdef WLAN_FEATURE_ROAM_SCAN_OFFLOAD
+            if (!csrRoamIsRoamOffloadScanEnabled(pMac))
+            {
+#endif
+                csrNeighborRoamDeregAllRssiIndication(pMac);
+#ifdef WLAN_FEATURE_ROAM_SCAN_OFFLOAD
+            }
+#endif
+            break;
+#endif
         case eCSR_NEIGHBOR_ROAM_STATE_REPORT_SCAN:
         case eCSR_NEIGHBOR_ROAM_STATE_PREAUTHENTICATING:
             CSR_NEIGHBOR_ROAM_STATE_TRANSITION(eCSR_NEIGHBOR_ROAM_STATE_INIT)
@@ -5213,7 +5245,11 @@
 
    if (NULL == pHandoffNode)
    {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+      VOS_ASSERT_VD(NULL != pHandoffNode);
+#else
       VOS_ASSERT(NULL != pHandoffNode);
+#endif
       return;
    }
 #ifdef WLAN_FEATURE_VOWIFI_11R
@@ -5357,7 +5393,7 @@
          * purge non-P2P results from the past */
         csrScanFlushSelectiveResult(pMac, VOS_FALSE);
         /* Once it gets the candidates found indication from PE, will issue a scan
-         - req to PE with freshScan in scanreq structure set as follows:
+         - req to PE with ?freshScan? in scanreq structure set as follows:
          0x42 - Return & purge LFR scan results
         */
         status = csrScanRequestLfrResult(pMac, pNeighborRoamInfo->csrSessionId,
diff -urN qcacld-new.orig/CORE/SME/src/csr/csrUtil.c qcacld-new/CORE/SME/src/csr/csrUtil.c
--- qcacld-new.orig/CORE/SME/src/csr/csrUtil.c	2016-05-16 10:58:06.702298648 +0800
+++ qcacld-new/CORE/SME/src/csr/csrUtil.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /** ------------------------------------------------------------------------- *
     ------------------------------------------------------------------------- *
@@ -2180,7 +2181,11 @@
 
     if (NULL == pIes)
     {
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+       VOS_ASSERT_VD( pIes != NULL );
+#else
        VOS_ASSERT( pIes != NULL );
+#endif
        return( qosType );
     }
 
diff -urN qcacld-new.orig/CORE/SME/src/oemData/oemDataApi.c qcacld-new/CORE/SME/src/oemData/oemDataApi.c
--- qcacld-new.orig/CORE/SME/src/oemData/oemDataApi.c	2016-05-16 10:58:06.622298648 +0800
+++ qcacld-new/CORE/SME/src/oemData/oemDataApi.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #ifdef FEATURE_OEM_DATA_SUPPORT
 /** ------------------------------------------------------------------------- *
@@ -61,11 +62,6 @@
     {
         //initialize all the variables to null
         vos_mem_set(&(pMac->oemData), sizeof(tOemDataStruct), 0);
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            smsLog(pMac, LOGE, "oemData_OemDataReqOpen: Cannot allocate memory for the timer function");
-            break;
-        }
     } while(0);
 
     return status;
@@ -79,16 +75,10 @@
 
 eHalStatus oemData_OemDataReqClose(tHalHandle hHal)
 {
-    eHalStatus status = eHAL_STATUS_SUCCESS;
     tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
 
     do
     {
-        if(!HAL_STATUS_SUCCESS(status))
-        {
-            smsLog(pMac, LOGE, "oemData_OemDataReqClose: Failed in oemData_OemDataReqClose at StopTimers");
-            break;
-        }
 
         if(pMac->oemData.pOemDataRsp != NULL)
         {
@@ -197,12 +187,13 @@
 
     } while(0);
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
     if(!HAL_STATUS_SUCCESS(status) && pOemDataCmd)
     {
         oemData_ReleaseOemDataReqCommand(pMac, pOemDataCmd, eOEM_DATA_REQ_FAILURE);
         pMac->oemData.oemDataReqActive = eANI_BOOLEAN_FALSE;
     }
-
+#endif 
     return status;
 }
 
diff -urN qcacld-new.orig/CORE/SME/src/p2p/p2p_Api.c qcacld-new/CORE/SME/src/p2p/p2p_Api.c
--- qcacld-new.orig/CORE/SME/src/p2p/p2p_Api.c	2016-05-16 10:58:06.614298648 +0800
+++ qcacld-new/CORE/SME/src/p2p/p2p_Api.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 
 
@@ -49,6 +50,39 @@
 #endif
 
 eHalStatus p2pProcessNoAReq(tpAniSirGlobal pMac, tSmeCmd *pNoACmd);
+/*
+ * csr_release_roc_req_cmd() - Release the command
+ * @mac_ctx: Global MAC Context
+ *
+ * Release the remain on channel request command from the queue
+ *
+ * Return: None
+ */
+void csr_release_roc_req_cmd(tpAniSirGlobal mac_ctx)
+{
+	tListElem *entry = NULL;
+	tSmeCmd *cmd = NULL;
+
+	entry = csrLLPeekHead(&mac_ctx->sme.smeCmdActiveList, LL_ACCESS_LOCK);
+	if (entry) {
+		cmd = GET_BASE_ADDR(entry, tSmeCmd, Link);
+		if (eSmeCommandRemainOnChannel == cmd->command) {
+			remainOnChanCallback callback =
+				cmd->u.remainChlCmd.callback;
+			/* process the msg */
+			if (callback)
+				callback(mac_ctx,
+					cmd->u.remainChlCmd.callbackCtx, 0);
+			smsLog(mac_ctx, LOGE,
+				FL("Remove RoC Request from Active Cmd List"));
+			/* Now put this cmd back on the avilable command list */
+			if (csrLLRemoveEntry(&mac_ctx->sme.smeCmdActiveList,
+					entry, LL_ACCESS_LOCK))
+				smeReleaseCommand(mac_ctx, cmd);
+		}
+	}
+}
+
 /*------------------------------------------------------------------
  *
  * handle SME remain on channel request.
@@ -57,7 +91,7 @@
 
 eHalStatus p2pProcessRemainOnChannelCmd(tpAniSirGlobal pMac, tSmeCmd *p2pRemainonChn)
 {
-    eHalStatus status = eHAL_STATUS_SUCCESS;
+    eHalStatus status = eHAL_STATUS_FAILURE;
     tSirRemainOnChnReq* pMsg;
     tANI_U32 len;
     tCsrRoamSession *pSession = CSR_GET_SESSION( pMac, p2pRemainonChn->sessionId );
@@ -65,7 +99,7 @@
     if(!pSession)
     {
        smsLog(pMac, LOGE, FL("  session %d not found "), p2pRemainonChn->sessionId);
-       return eHAL_STATUS_FAILURE;
+       goto error;
     }
 
 #ifdef WLAN_FEATURE_P2P_INTERNAL
@@ -79,14 +113,14 @@
     {
        smsLog(pMac, LOGE, FL("  session %d (P2P session %d) is invalid or listen is disabled "),
             p2pRemainonChn->sessionId, P2PsessionId);
-       return eHAL_STATUS_FAILURE;
+        goto error;
     }
 #else
     if(!pSession->sessionActive)
     {
        smsLog(pMac, LOGE, FL("  session %d is invalid or listen is disabled "),
             p2pRemainonChn->sessionId);
-       return eHAL_STATUS_FAILURE;
+       goto error;
     }
 #endif
 #ifdef WLAN_FEATURE_P2P_INTERNAL
@@ -104,12 +138,12 @@
        /*In coming len for Msg is more then 16bit value*/
        smsLog(pMac, LOGE, FL("  Message length is very large, %d"),
             len);
-       return eHAL_STATUS_FAILURE;
+       goto error;
     }
 
     pMsg = vos_mem_malloc(len);
     if ( NULL == pMsg )
-        status = eHAL_STATUS_FAILURE;
+        goto error;
     else
     {
         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_INFO, "%s call", __func__);
@@ -136,7 +170,9 @@
 #endif
         status = palSendMBMessage(pMac->hHdd, pMsg);
     }
-
+error:
+    if (eHAL_STATUS_FAILURE == status)
+       csr_release_roc_req_cmd(pMac);
     return status;
 }
 
@@ -149,9 +185,10 @@
 
 eHalStatus sme_remainOnChnRsp( tpAniSirGlobal pMac, tANI_U8 *pMsg)
 {
-    eHalStatus                         status = eHAL_STATUS_SUCCESS;
-    tListElem                          *pEntry = NULL;
-    tSmeCmd                            *pCommand = NULL;
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    tListElem  *pEntry = NULL;
+    tSmeCmd    *pCommand = NULL;
+    tSirSmeRsp *pRsp = (tSirSmeRsp *)pMsg;        
     tANI_BOOLEAN fFound;
 
     if (pMac->fP2pListenOffload)
@@ -166,7 +203,8 @@
             remainOnChanCallback callback = pCommand->u.remainChlCmd.callback;
             /* process the msg */
             if( callback )
-                callback(pMac, pCommand->u.remainChlCmd.callbackCtx, 0);
+                callback(pMac, pCommand->u.remainChlCmd.callbackCtx,
+                                                        pRsp->statusCode);        
 
             if (pMac->fP2pListenOffload)
             {
@@ -649,10 +687,12 @@
    vos_mem_zero(&pMac->p2pContext, sizeof( tp2pContext ));
 #endif
 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
    if(!HAL_STATUS_SUCCESS(status))
    {
       sme_p2pClose(hHal);
-    }
+   }
+#endif
 
    return status;
 }
@@ -807,7 +847,7 @@
 #ifdef WLAN_FEATURE_P2P_INTERNAL
         smePushCommand(pMac, pRemainChlCmd, (eP2PRemainOnChnReasonSendFrame == reason));
 #else
-        csrQueueSmeCommand(pMac, pRemainChlCmd, eANI_BOOLEAN_FALSE);
+        status = csrQueueSmeCommand(pMac, pRemainChlCmd, eANI_BOOLEAN_FALSE);
 #endif
     } while(0);
 
diff -urN qcacld-new.orig/CORE/SME/src/pmc/pmcApi.c qcacld-new/CORE/SME/src/pmc/pmcApi.c
--- qcacld-new.orig/CORE/SME/src/pmc/pmcApi.c	2016-05-16 10:58:06.614298648 +0800
+++ qcacld-new/CORE/SME/src/pmc/pmcApi.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /******************************************************************************
 *
@@ -2151,12 +2152,18 @@
     if(pattern == NULL)
     {
         pmcLog(pMac, LOGE, FL("Null broadcast pattern being passed"));
+#ifdef FEATURE_WLAN_DIAG_SUPPORT
+        WLAN_VOS_DIAG_LOG_FREE(log_ptr);
+#endif
         return eHAL_STATUS_FAILURE;
     }
 
     if( pSession == NULL)
     {
         pmcLog(pMac, LOGE, FL("Session not found "));
+#ifdef FEATURE_WLAN_DIAG_SUPPORT
+        WLAN_VOS_DIAG_LOG_FREE(log_ptr);
+#endif
         return eHAL_STATUS_FAILURE;
     }
 
@@ -2932,12 +2939,6 @@
                *((v_U32_t *) &pRequest->aNetworks[1].ssId.ssId[24]),
                *((v_U32_t *) &pRequest->aNetworks[1].ssId.ssId[28]));
 
-    if (!pSession)
-    {
-        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
-                  "%s: pSessionis NULL", __func__);
-        return eHAL_STATUS_FAILURE;
-    }
 
     pRequestBuf = vos_mem_malloc(sizeof(tSirPNOScanReq));
     if (NULL == pRequestBuf)
@@ -3047,7 +3048,7 @@
     vos_msg_t msg;
 
 
-    pRequestBuf = vos_mem_malloc(sizeof(tpSirSetRSSIFilterReq));
+    pRequestBuf = vos_mem_malloc(sizeof(tSirSetRSSIFilterReq));
     if (NULL == pRequestBuf)
     {
         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR, "%s: Not able to allocate memory for PNO request", __func__);
diff -urN qcacld-new.orig/CORE/SME/src/pmc/pmc.c qcacld-new/CORE/SME/src/pmc/pmc.c
--- qcacld-new.orig/CORE/SME/src/pmc/pmc.c	2016-05-16 10:58:06.606298648 +0800
+++ qcacld-new/CORE/SME/src/pmc/pmc.c	2016-05-16 10:58:08.746298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /******************************************************************************
 *
@@ -1981,7 +1982,11 @@
 
     if (NULL == ppCmd)
     {
-       VOS_ASSERT( ppCmd );
+#ifdef CONFIG_VD_PREVENT_DEADCODE        
+       VOS_ASSERT_VD(ppCmd);
+#else
+       VOS_ASSERT(ppCmd);
+#endif
        return eHAL_STATUS_FAILURE;
     }
     do
diff -urN qcacld-new.orig/CORE/SME/src/QoS/sme_Qos.c qcacld-new/CORE/SME/src/QoS/sme_Qos.c
--- qcacld-new.orig/CORE/SME/src/QoS/sme_Qos.c	2016-05-16 10:58:06.638298648 +0800
+++ qcacld-new/CORE/SME/src/QoS/sme_Qos.c	2016-05-16 10:58:08.750298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -700,8 +701,10 @@
    for(sessionId = 0; sessionId < CSR_ROAM_SESSION_MAX; ++sessionId)
    {
       pSession = &sme_QosCb.sessionInfo[sessionId];
+#ifndef CONFIG_VD_PREVENT_DEADCODE
       if (pSession == NULL)
             continue;
+#endif
 
        sme_QosInitACs(pMac, sessionId);
        // this session doesn't require UAPSD
@@ -7087,6 +7090,10 @@
       break;
    case SME_QOS_REASON_MODIFY:
       flow_info->reason = SME_QOS_REASON_REQ_SUCCESS;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+      inform_hdd = VOS_FALSE;
+      break;
+#endif
    case SME_QOS_REASON_REQ_SUCCESS:
    default:
       inform_hdd = VOS_FALSE;
@@ -7311,6 +7318,10 @@
    case SME_QOS_REASON_REQ_SUCCESS:
       hdd_status = SME_QOS_STATUS_SETUP_MODIFIED_IND;
       inform_hdd = VOS_TRUE;
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+      delete_entry = VOS_FALSE;
+      break;
+#endif
    default:
       delete_entry = VOS_FALSE;
       break;
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c qcacld-new/CORE/SME/src/sme_common/sme_Api.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_Api.c	2016-05-16 10:58:06.758298648 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_Api.c	2016-05-16 10:58:08.754298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -91,6 +91,7 @@
                                      tANI_U32 size, tSmeCmd **ppCmd);
 extern void pmcReleaseCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
 extern void qosReleaseCommand( tpAniSirGlobal pMac, tSmeCmd *pCommand );
+extern void csr_release_roc_req_cmd(tpAniSirGlobal mac_ctx);
 extern eHalStatus p2pProcessRemainOnChannelCmd(tpAniSirGlobal pMac, tSmeCmd *p2pRemainonChn);
 extern eHalStatus sme_remainOnChnRsp( tpAniSirGlobal pMac, tANI_U8 *pMsg);
 extern eHalStatus sme_mgmtFrmInd( tHalHandle hHal, tpSirSmeMgmtFrameInd pSmeMgmtFrm);
@@ -966,6 +967,28 @@
                         case eSmeCommandNoAUpdate:
                             csrLLUnlock( &pMac->sme.smeCmdActiveList );
                             p2pProcessNoAReq(pMac,pCommand);
+#ifdef CONFIG_VD_PREVENT_MISSING_BREAK
+                            csrLLUnlock( &pMac->sme.smeCmdActiveList );
+                            if(pMac->psOffloadEnabled)
+                            {
+                                fContinue =
+                                  pmcOffloadProcessCommand(pMac, pCommand);
+                            }
+                            else
+                            {
+                                fContinue = pmcProcessCommand(pMac, pCommand);
+                            }
+                            if( fContinue )
+                            {
+                                //The command failed, remove it
+                                if( csrLLRemoveEntry( &pMac->sme.smeCmdActiveList,
+                                            &pCommand->Link, LL_ACCESS_LOCK ) )
+                                {
+                                    pmcReleaseCommand( pMac, pCommand );
+                                }
+                            }
+                            break;
+#endif                            
                         case eSmeCommandEnterImps:
                         case eSmeCommandExitImps:
                         case eSmeCommandEnterBmps:
@@ -1725,6 +1748,46 @@
    }
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/*--------------------------------------------------------------------------
+
+  \fn - sme_ProcessReadyToExtWoW
+  \brief - On getting ready to Ext WoW indication, this function calls
+             callback registered (HDD callbacks) with SME to inform
+             ready to ExtWoW indication.
+
+  \param hHal - Handle returned by macOpen.
+   pReadyToExtWoW - Parameter received along with ready to Ext WoW
+                                indication from WMA.
+
+  \return None
+
+  \sa
+
+ --------------------------------------------------------------------------*/
+void sme_ProcessReadyToExtWoW( tHalHandle hHal,
+                                 tpSirReadyToExtWoWInd pReadyToExtWoW)
+{
+   tpAniSirGlobal pMac = PMAC_STRUCT( hHal );
+
+   if (NULL == pMac)
+   {
+       VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_FATAL,
+             "%s: pMac is null", __func__);
+       return ;
+   }
+
+   if (NULL != pMac->readyToExtWoWCallback)
+   {
+       pMac->readyToExtWoWCallback (pMac->readyToExtWoWContext,
+                                    pReadyToExtWoW->status);
+       pMac->readyToExtWoWCallback = NULL;
+       pMac->readyToExtWoWContext = NULL;
+   }
+
+}
+#endif
+
 /* ---------------------------------------------------------------------------
     \fn sme_ChangeConfigParams
     \brief The SME API exposed for HDD to provide config params to SME during
@@ -2648,6 +2711,21 @@
                 }
                 break ;
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+           case eWNI_SME_READY_TO_EXTWOW_IND:
+                if (pMsg->bodyptr)
+                {
+                     sme_ProcessReadyToExtWoW(pMac, pMsg->bodyptr);
+                     vos_mem_free(pMsg->bodyptr);
+                }
+                else
+                {
+                     smsLog(pMac, LOGE, "Empty rsp message"
+                     "for (eWNI_SME_READY_TO_EXTWOW_IND), nothing to process");
+                }
+                break ;
+#endif
+
 #ifdef FEATURE_WLAN_CH_AVOID
            /* channel avoid message arrived, send IND to client */
            case eWNI_SME_CH_AVOID_IND:
@@ -6837,7 +6915,7 @@
   tpSmeBtAmpEvent ptrSmeBtAmpEvent = NULL;
   eHalStatus status = eHAL_STATUS_FAILURE;
 
-  ptrSmeBtAmpEvent = vos_mem_malloc(sizeof(tpSmeBtAmpEvent));
+  ptrSmeBtAmpEvent = vos_mem_malloc(sizeof(tSmeBtAmpEvent));
   if (NULL == ptrSmeBtAmpEvent)
      {
         VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR, "%s: "
@@ -7596,6 +7674,122 @@
     return(status);
 }
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureExtWoW
+
+  \brief
+    SME will pass this request to lower mac to configure Extr WoW
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanExtParams- Depicts the wlan Ext params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureExtWoW( tHalHandle hHal,
+                          tpSirExtWoWParams  wlanExtParams,
+                          csrReadyToExtWoWCallback callback,
+                             void *callbackContext)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t vosMessage;
+    tpSirExtWoWParams MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW, NO_SESSION, 0));
+
+    pMac->readyToExtWoWCallback = callback;
+    pMac->readyToExtWoWContext = callbackContext;
+
+    if ( eHAL_STATUS_SUCCESS ==
+              ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanExtParams, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type =  WDA_WLAN_EXT_WOW;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+            pMac->readyToExtWoWCallback = NULL;
+            pMac->readyToExtWoWContext = NULL;
+            vos_mem_free(MsgPtr);
+            status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        pMac->readyToExtWoWCallback = NULL;
+        pMac->readyToExtWoWContext = NULL;
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+
+/* ---------------------------------------------------------------------------
+
+  \fn    sme_ConfigureAppType1Params
+
+  \brief
+   SME will pass this request to lower mac to configure Indoor WoW parameters.
+
+  \param
+
+    hHal - The handle returned by macOpen.
+
+    wlanAppType1Params- Depicts the wlan App Type 1(Indoor) params
+
+  \return eHalStatus
+
+
+--------------------------------------------------------------------------- */
+eHalStatus sme_ConfigureAppType1Params( tHalHandle hHal,
+                          tpSirAppType1Params  wlanAppType1Params)
+{
+    eHalStatus status = eHAL_STATUS_SUCCESS;
+    VOS_STATUS vosStatus = VOS_STATUS_SUCCESS;
+    tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
+    vos_msg_t       vosMessage;
+    tpSirAppType1Params MsgPtr = vos_mem_malloc(sizeof(*MsgPtr));
+
+    if (!MsgPtr)
+        return eHAL_STATUS_FAILURE;
+
+    MTRACE(vos_trace(VOS_MODULE_ID_SME,
+                  TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1, NO_SESSION, 0));
+
+    if ( eHAL_STATUS_SUCCESS ==
+              ( status = sme_AcquireGlobalLock( &pMac->sme ) ) ) {
+
+        /* serialize the req through MC thread */
+        vos_mem_copy(MsgPtr, wlanAppType1Params, sizeof(*MsgPtr));
+        vosMessage.bodyptr = MsgPtr;
+        vosMessage.type    =  WDA_WLAN_SET_APP_TYPE1_PARAMS;
+        vosStatus = vos_mq_post_message( VOS_MQ_ID_WDA, &vosMessage );
+        if ( !VOS_IS_STATUS_SUCCESS(vosStatus) ) {
+           vos_mem_free(MsgPtr);
+           status = eHAL_STATUS_FAILURE;
+        }
+        sme_ReleaseGlobalLock( &pMac->sme );
+    } else {
+        vos_mem_free(MsgPtr);
+    }
+
+    return(status);
+}
+
+#endif
+
 /* ---------------------------------------------------------------------------
 
     \fn sme_GetInfraSessionId
@@ -11016,6 +11210,9 @@
     return(status);
 }
 
+#endif /* QCA_WIFI_2_0 */
+#endif /* FEATURE_WLAN_TDLS */
+#ifdef QCA_WIFI_2_0
 eHalStatus sme_GetLinkSpeed(tHalHandle hHal, tSirLinkSpeedInfo *lsReq, void *plsContext,
                             void (*pCallbackfn)(tSirLinkSpeedInfo *indParam, void *pContext) )
 {
@@ -11055,8 +11252,8 @@
     }
     return(status);
 }
+
 #endif /* QCA_WIFI_2_0 */
-#endif /* FEATURE_WLAN_TDLS */
 /* ---------------------------------------------------------------------------
     \fn sme_IsPmcBmps
     \API to Check if PMC state is BMPS.
@@ -11523,9 +11720,12 @@
    {
       smeConfig.csrConfig.channelBondingMode5GHz =
          eCSR_INI_SINGLE_CHANNEL_CENTERED;
-   } else if ( eCSR_DOT11_MODE_11g_ONLY == eCsrPhyMode)
+   } 
+#ifndef CONFIG_VD_PREVENT_DEADCODE
+   else if ( eCSR_DOT11_MODE_11g_ONLY == eCsrPhyMode)
       smeConfig.csrConfig.channelBondingMode24GHz =
          eCSR_INI_SINGLE_CHANNEL_CENTERED;
+#endif
 
    sme_AdjustCBMode(pMac, &smeConfig, channel);
 
@@ -12541,6 +12741,7 @@
         smsLog(pMac, LOGE, "Invalid Channel Change Resp Message: %d\n",
               status);
     }
+    vos_mem_free(pRoamInfo.channelChangeRespEvent);
     return status;
 }
 
@@ -12670,7 +12871,6 @@
     tpAniSirGlobal pMac = PMAC_STRUCT(hHal);
     u_int8_t *pLevel = vos_mem_malloc(sizeof(*pLevel));
 
-    pLevel = vos_mem_malloc(sizeof(*pLevel));
     if (NULL == pLevel)
     {
        VOS_TRACE(VOS_MODULE_ID_SME, VOS_TRACE_LEVEL_ERROR,
@@ -13158,7 +13358,7 @@
         return eHAL_STATUS_INVALID_PARAMETER;
     }
 
-    if ((wifiBand < WIFI_BAND_UNSPECIFIED) || (wifiBand >= WIFI_BAND_MAX)) {
+    if (wifiBand >= WIFI_BAND_MAX) {
         smsLog(pMac, VOS_TRACE_LEVEL_ERROR,
                      FL("Invalid wifiBand (%d)"), wifiBand);
         return eHAL_STATUS_INVALID_PARAMETER;
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_FTApi.c qcacld-new/CORE/SME/src/sme_common/sme_FTApi.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_FTApi.c	2016-05-16 10:58:06.766298648 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_FTApi.c	2016-05-16 10:58:08.754298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 #ifdef WLAN_FEATURE_VOWIFI_11R
 /**=========================================================================
@@ -261,7 +262,7 @@
 
     keymaterial->key[ 0 ].keyLength = pFTKeyInfo->keyLength;
 
-    if ( pFTKeyInfo->keyLength && pFTKeyInfo->Key )
+    if ( pFTKeyInfo->keyLength )
     {
         vos_mem_copy(&keymaterial->key[ 0 ].key, pFTKeyInfo->Key, pFTKeyInfo->keyLength);
         if(pFTKeyInfo->keyLength == 16)
diff -urN qcacld-new.orig/CORE/SME/src/sme_common/sme_Trace.c qcacld-new/CORE/SME/src/sme_common/sme_Trace.c
--- qcacld-new.orig/CORE/SME/src/sme_common/sme_Trace.c	2016-05-16 10:58:06.726298648 +0800
+++ qcacld-new/CORE/SME/src/sme_common/sme_Trace.c	2016-05-16 10:58:08.750298648 +0800
@@ -120,6 +120,11 @@
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_RXPFIL);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_SUSPENDIND);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_RESUMEREQ);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_EXTWOW);
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE1);
+        CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_CONFIG_APP_TYPE2);
+#endif
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_MAXTXPOW);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_TXPOW);
         CASE_RETURN_STRING(TRACE_CODE_SME_RX_HDD_SET_TMLEVEL);
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/platform/src/VossWrapper.c qcacld-new/CORE/SYS/legacy/src/platform/src/VossWrapper.c
--- qcacld-new.orig/CORE/SYS/legacy/src/platform/src/VossWrapper.c	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/SYS/legacy/src/platform/src/VossWrapper.c	2016-05-16 10:58:08.694298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
   @file VossWrapper.c
@@ -353,7 +354,7 @@
 #endif // Store the timer name, for Debug build only
 
     status = vos_timer_init_debug( &timer_ptr->vosTimer, VOS_TIMER_TYPE_SW,
-          tx_main_timer_func, (v_PVOID_t)timer_ptr, fileName, lineNum);
+          tx_main_timer_func, (v_PVOID_t)timer_ptr, fileName, __func__, lineNum);
     if (VOS_STATUS_SUCCESS != status)
     {
        VOS_TRACE(VOS_MODULE_ID_SYS, VOS_TRACE_LEVEL_ERROR,
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/dot11f.c qcacld-new/CORE/SYS/legacy/src/utils/src/dot11f.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/dot11f.c	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/dot11f.c	2016-05-16 10:58:08.686298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -22216,22 +22216,30 @@
         }
         else break;
         *pnNeeded += ( pIe->akm_suite_count * 4 );
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         if ( pIe->RSN_Cap )
+#endif
         {
             *pnNeeded += 2;
         }
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         else break;
+#endif
         if ( pIe->pmkid_count )
         {
             *pnNeeded += 2;
         }
         else break;
         *pnNeeded += ( pIe->pmkid_count * 16 );
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if ( pIe->gp_mgmt_cipher_suite )
         {
             *pnNeeded += 4;
         }
         else break;
+#else
+        *pnNeeded += 4;
+#endif
         break;
     }
     return status;
@@ -30601,12 +30609,17 @@
         DOT11F_MEMCPY(pCtx, pBuf, &( pSrc->akm_suites ), ( pSrc->akm_suite_count * 4 ));
         *pnConsumed += ( pSrc->akm_suite_count * 4 );
         pBuf += ( pSrc->akm_suite_count * 4 );
-        if ( pSrc->RSN_Cap )        {
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
+        if ( pSrc->RSN_Cap )
+#endif
+		{
             DOT11F_MEMCPY(pCtx, pBuf, pSrc->RSN_Cap, 2);
             *pnConsumed += 2;
             pBuf += 2;
         }
+#ifndef CONFIG_VD_PREVENT_NO_EFFECT
         else break;
+#endif
         if ( pSrc->pmkid_count )        {
             frameshtons(pCtx, pBuf, pSrc->pmkid_count, 0);
             *pnConsumed += 2;
@@ -30616,12 +30629,18 @@
         DOT11F_MEMCPY(pCtx, pBuf, &( pSrc->pmkid ), ( pSrc->pmkid_count * 16 ));
         *pnConsumed += ( pSrc->pmkid_count * 16 );
         pBuf += ( pSrc->pmkid_count * 16 );
+#ifndef CONFIG_VD_PREVENT_DEADCODE
         if ( pSrc->gp_mgmt_cipher_suite )        {
             DOT11F_MEMCPY(pCtx, pBuf, pSrc->gp_mgmt_cipher_suite, 4);
             *pnConsumed += 4;
             // fieldsEndFlag = 1
         }
         else break;
+#else
+        DOT11F_MEMCPY(pCtx, pBuf, pSrc->gp_mgmt_cipher_suite, 4);
+        *pnConsumed += 4;
+        // fieldsEndFlag = 1
+#endif
         break;
     }
     (void)pCtx;
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/logDump.c qcacld-new/CORE/SYS/legacy/src/utils/src/logDump.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/logDump.c	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/logDump.c	2016-05-16 10:58:08.686298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*============================================================================
 logDump.c
@@ -125,8 +126,10 @@
     va_list args;
     va_start(args, fmt);
 
-    if (pMac->gCurrentLogSize >= MAX_LOGDUMP_SIZE)
+    if (pMac->gCurrentLogSize >= MAX_LOGDUMP_SIZE) {
+        va_end(args);
         return 0;
+    }
 
 #if    defined (ANI_OS_TYPE_ANDROID)
     ret = vsnprintf(pBuf, (MAX_LOGDUMP_SIZE - pMac->gCurrentLogSize), fmt, args);
@@ -309,6 +312,7 @@
     endId = ((startId + arg2) < CFG_PARAM_MAX_NUM) ? (startId + arg2) : CFG_PARAM_MAX_NUM;
 
     for (i=startId; i < endId; i++)
+      if (CFG_PARAM_MAX_NUM > i)
         Log_getCfg(pMac, (tANI_U16) i);
 
     return p;
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/macTrace.c qcacld-new/CORE/SYS/legacy/src/utils/src/macTrace.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/macTrace.c	2016-05-16 10:58:06.386298648 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/macTrace.c	2016-05-16 10:58:08.654298648 +0800
@@ -735,6 +735,11 @@
         CASE_RETURN_STRING(WDA_TX_COMPLETE_TIMEOUT_IND);
         CASE_RETURN_STRING(WDA_WLAN_SUSPEND_IND);
         CASE_RETURN_STRING(WDA_WLAN_RESUME_REQ);
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+        CASE_RETURN_STRING(WDA_WLAN_EXT_WOW);
+        CASE_RETURN_STRING(WDA_WLAN_SET_APP_TYPE1_PARAMS);
+        CASE_RETURN_STRING(WDA_WLAN_SET_APP_TYPE2_PARAMS);
+#endif
         CASE_RETURN_STRING(WDA_MSG_TYPES_END);
         CASE_RETURN_STRING(WDA_MMH_TXMB_READY_EVT);
         CASE_RETURN_STRING(WDA_MMH_RXMB_DONE_EVT);
diff -urN qcacld-new.orig/CORE/SYS/legacy/src/utils/src/parserApi.c qcacld-new/CORE/SYS/legacy/src/utils/src/parserApi.c
--- qcacld-new.orig/CORE/SYS/legacy/src/utils/src/parserApi.c	2016-05-16 10:58:06.426298648 +0800
+++ qcacld-new/CORE/SYS/legacy/src/utils/src/parserApi.c	2016-05-16 10:58:08.694298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file parserApi.cc contains the code for parsing
diff -urN qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c
--- qcacld-new.orig/CORE/UTILS/FWLOG/dbglog_host.c	2016-05-16 10:58:06.494298648 +0800
+++ qcacld-new/CORE/UTILS/FWLOG/dbglog_host.c	2016-05-16 10:58:08.738298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /* Host Debug log implementation */
 
@@ -1162,6 +1163,7 @@
     },
 };
 
+
 int dbglog_module_log_enable(wmi_unified_t  wmi_handle, A_UINT32 mod_id,
                   bool isenable)
 {
@@ -1299,16 +1301,12 @@
 			mod_enable_bitmap,bitmap_len);
 }
 
+
+
 int dbglog_report_enable(wmi_unified_t  wmi_handle, bool isenable)
 {
     int bitmap[2] = {0};
 
-    if (isenable > TRUE) {
-        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("dbglog_report_enable:Invalid value %d\n",
-        isenable));
-        return -EINVAL;
-    }
-
     if(isenable){
 	/* set the vap enable bitmap */
         dbglog_set_vap_enable_bitmap(wmi_handle, 0xFFFF);
@@ -1342,6 +1340,7 @@
     return unknown_str;
 }
 
+
 void
 dbglog_printf(
         A_UINT32 timestamp,
@@ -1351,12 +1350,6 @@
     char buf[128];
     va_list ap;
 
-    if (vap_id < DBGLOG_MAX_VDEVID) {
-        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
-    } else {
-        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] ", timestamp));
-    }
-
     va_start(ap, fmt);
     vsnprintf(buf, sizeof(buf), fmt, ap);
     va_end(ap);
@@ -1372,7 +1365,6 @@
 {
     char buf[128];
     va_list ap;
-
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u ", timestamp, vap_id));
     } else {
@@ -1393,7 +1385,40 @@
                              A_UINT32 timestamp, A_UINT16 numargs, A_UINT32 *args)
 {
     int i;
+            len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, "%#x", args[i]);
+            if ((i + 1) < numargs) {
+                dbglog_fwlog_file_ctx.buf_free_idx[len] = ',';
+                dbglog_fwlog_file_ctx.buf_free_idx[len+1] = ' ';
+                len += 2;
+            }
+        }
+        len += snprintf(dbglog_fwlog_file_ctx.buf_free_idx + len, dbglog_fwlog_file_ctx.buf_free_size - len, " )\n");
+        dbglog_fwlog_file_ctx.buf_free_idx += len;
+        dbglog_fwlog_file_ctx.buf_used_size += len;
+        dbglog_fwlog_file_ctx.buf_free_size -= len;
+        if ((dbglog_fwlog_file_ctx.buf_used_size >= FWLOG_FILE_BUF_THREHOLD) ||
+            ((dbglog_fwlog_file_ctx.file_size + dbglog_fwlog_file_ctx.buf_used_size) >= dbglog_fwlog_file_ctx.file_max_size)) {
+            adf_os_timer_cancel(&dbglog_fwlog_file_ctx.timer);
+            dbglog_fwlog_file_write_file();
+        }
+        mutex_unlock(&dbglog_fwlog_file_ctx.lock);
+    } else {
+
+        if (vap_id < DBGLOG_MAX_VDEVID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] %s ( ", timestamp, dbglog_get_msg(mod_id, dbg_id)));
+        }
 
+        for (i = 0; i < numargs; i++) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
+            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
+            if ((i + 1) < numargs) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
+            }
+        }
+        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (" )\n"));
+    }
     if (vap_id < DBGLOG_MAX_VDEVID) {
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (DBGLOG_PRINT_PREFIX "[%u] vap-%u %s ( ", timestamp, vap_id, dbglog_get_msg(mod_id, dbg_id)));
     } else {
@@ -1401,11 +1426,8 @@
     }
 
     for (i = 0; i < numargs; i++) {
-#if USE_NUMERIC
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%u", args[i]));
-#else
         AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("%#x", args[i]));
-#endif
         if ((i + 1) < numargs) {
             AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (", "));
         }
@@ -1445,27 +1467,15 @@
                 totalWriteLen += writeLen;
             }
 
-            if (debugid < MAX_DBG_MSGS){
-                dbgidString = DBG_MSG_ARR[moduleid][debugid];
-                if (dbgidString != NULL) {
-                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("fw:%s(%x %x):%s\n",
-                           dbgidString,
-                           timestamp, buffer[count+1],
-                           parseArgsString));
-                } else {
-                    /* host need sync with FW id */
-                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("fw:%s:m:%x,id:%x(%x %x):%s\n",
-                           "UNKNOWN", moduleid, debugid,
-                           timestamp, buffer[count+1],
-                           parseArgsString));
-                }
-            } else if (debugid == DBGLOG_DBGID_SM_FRAMEWORK_PROXY_DBGLOG_MSG) {
-                /* specific debugid */
-                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("fw:%s:m:%x,id:%x(%x %x):%s\n",
-                       "DBGLOG_SM_MSG", moduleid, debugid,
+
+            dbgidString = DBG_MSG_ARR[moduleid][debugid];
+            if (dbgidString != NULL) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("fw:%s(%x %x):%s\n",
+                       dbgidString,
                        timestamp, buffer[count+1],
                        parseArgsString));
             } else {
+                /* host need sync with FW id */
                 AR_DEBUG_PRINTF(ATH_DEBUG_INFO, ("fw:%s:m:%x,id:%x(%x %x):%s\n",
                        "UNKNOWN", moduleid, debugid,
                        timestamp, buffer[count+1],
diff -urN qcacld-new.orig/CORE/VOSS/inc/i_vos_trace.h qcacld-new/CORE/VOSS/inc/i_vos_trace.h
--- qcacld-new.orig/CORE/VOSS/inc/i_vos_trace.h	2016-05-16 10:58:07.482298648 +0800
+++ qcacld-new/CORE/VOSS/inc/i_vos_trace.h	2016-05-16 10:58:08.874298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -109,10 +110,18 @@
         if ( ! ( _condition ) )                                         \
         {                                                               \
             printk(KERN_CRIT "VOS ASSERT in %s Line %d\n", __func__, __LINE__); \
-            WARN_ON(1);                                                 \
         }                                                               \
     } while(0)
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+#define VOS_ASSERT_VD( _condition ) do {                                \
+        if ( ! ( _condition ) )                                         \
+        {                                                               \
+            printk(KERN_CRIT "VOS ASSERT in %s Line %d\n", __func__, __LINE__); \
+        }                                                               \
+    } while(0)
+#endif
+
 #else
 
 
@@ -121,7 +130,7 @@
   VOS_INLINE_FN void vos_trace_msg( VOS_MODULE_ID module, ... ){}
 
   #define VOS_ASSERT( _condition )
-
+  #define VOS_ASSERT_VD( _condition )
 #endif
 
 #ifdef PANIC_ON_BUG
diff -urN qcacld-new.orig/CORE/VOSS/inc/vos_memory.h qcacld-new/CORE/VOSS/inc/vos_memory.h
--- qcacld-new.orig/CORE/VOSS/inc/vos_memory.h	2016-05-16 10:58:07.474298648 +0800
+++ qcacld-new/CORE/VOSS/inc/vos_memory.h	2016-05-16 10:58:08.870298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -87,6 +88,21 @@
 v_VOID_t * vos_mem_malloc( v_SIZE_t size );
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#define VOS_PRE_ALLOC_GET_THRESHOLD (16*1024)
+
+struct vos_prealloc {
+	v_UINT_t occupied;
+	v_UINT_t size;
+	v_VOID_t *ptr;
+};
+
+v_UINT_t vos_prealloc_init(v_VOID_t);
+v_VOID_t vos_prealloc_deinit(v_VOID_t);
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr);
+v_VOID_t *vos_prealloc_get(v_UINT_t size);
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*----------------------------------------------------------------------------
 
diff -urN qcacld-new.orig/CORE/VOSS/inc/vos_timer.h qcacld-new/CORE/VOSS/inc/vos_timer.h
--- qcacld-new.orig/CORE/VOSS/inc/vos_timer.h	2016-05-16 10:58:07.474298648 +0800
+++ qcacld-new/CORE/VOSS/inc/vos_timer.h	2016-05-16 10:58:08.870298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
@@ -90,8 +91,10 @@
 typedef struct timer_node_s
 {
    hdd_list_node_t pNode;
-   char* fileName;
+   const char* fileName;
+   const char* funcName;
    unsigned int lineNum;
+   unsigned long expire;
    struct vos_timer_s *vosTimer;
 }timer_node_t;
 #endif
@@ -116,6 +119,7 @@
 #ifdef TIMER_MANAGER
 void vos_timer_manager_init(void);
 void vos_timer_exit(void);
+void vos_timer_check_list(void);
 #endif
 
 /*---------------------------------------------------------------------------
@@ -191,11 +195,11 @@
 ---------------------------------------------------------------------------*/
 #ifdef TIMER_MANAGER
 #define vos_timer_init(timer, timerType, callback, userdata) \
-      vos_timer_init_debug(timer, timerType, callback, userdata, __FILE__, __LINE__)
+      vos_timer_init_debug(timer, timerType, callback, userdata, __FILE__, __func__, __LINE__)
 
 VOS_STATUS vos_timer_init_debug( vos_timer_t *timer, VOS_TIMER_TYPE timerType,
                            vos_timer_callback_t callback, v_PVOID_t userData,
-                           char* fileName, v_U32_t lineNum );
+                           const char* fileName, const char* funcName, v_U32_t lineNum );
 #else
 VOS_STATUS vos_timer_init( vos_timer_t *timer, VOS_TIMER_TYPE timerType,
                            vos_timer_callback_t callback, v_PVOID_t userData );
@@ -233,7 +237,12 @@
   \sa
 
 ---------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+VOS_STATUS _vos_timer_destroy( vos_timer_t *timer, const char* func, int line );
+#define vos_timer_destroy(timer) _vos_timer_destroy(timer, __func__, __LINE__)
+#else
 VOS_STATUS vos_timer_destroy( vos_timer_t *timer );
+#endif
 
 
 /*--------------------------------------------------------------------------
@@ -265,7 +274,12 @@
   \sa
 
   -------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+VOS_STATUS _vos_timer_start( vos_timer_t *timer, v_U32_t expirationTime, const char* func, int line);
+#define vos_timer_start(timer, expirationTime) _vos_timer_start(timer, expirationTime, __func__, __LINE__)
+#else
 VOS_STATUS vos_timer_start( vos_timer_t *timer, v_U32_t expirationTime );
+#endif
 
 
 /*--------------------------------------------------------------------------
@@ -292,7 +306,12 @@
   \sa
 
   ------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+VOS_STATUS _vos_timer_stop( vos_timer_t *timer, const char* func, int line );
+#define vos_timer_stop(timer) _vos_timer_stop(timer, __func__, __LINE__)
+#else
 VOS_STATUS vos_timer_stop( vos_timer_t *timer );
+#endif
 
 
 /*--------------------------------------------------------------------------
@@ -328,5 +347,4 @@
 v_TIME_t vos_timer_get_system_time( v_VOID_t );
 
 
-
 #endif // #if !defined __VOSS_TIMER_H
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_api.c qcacld-new/CORE/VOSS/src/vos_api.c
--- qcacld-new.orig/CORE/VOSS/src/vos_api.c	2016-05-16 10:58:07.498298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_api.c	2016-05-16 10:58:08.882298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -1010,7 +1011,11 @@
   {
      VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
          "%s: Failed to stop WDA", __func__);
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+     VOS_ASSERT_VD( VOS_IS_STATUS_SUCCESS( vStatus ) );
+#else
      VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vStatus ) );
+#endif
      WDA_setNeedShutdown(vosContext);
   }
   else
@@ -1055,7 +1060,11 @@
   {
      VOS_TRACE( VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
          "%s: Failed to stop WDA", __func__);
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+     VOS_ASSERT_VD( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#else
      VOS_ASSERT( VOS_IS_STATUS_SUCCESS( vosStatus ) );
+#endif
      WDA_setNeedShutdown(vosContext);
   }
 #ifndef QCA_WIFI_2_0
@@ -1886,7 +1895,11 @@
     return VOS_STATUS_E_FAILURE;
   }
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+  VOS_ASSERT_VD(NULL !=pTargetMq);
+#else
   VOS_ASSERT(NULL !=pTargetMq);
+#endif
   if (pTargetMq == NULL)
   {
      VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
@@ -2211,7 +2224,11 @@
      return;
   }
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+  VOS_ASSERT_VD( NULL !=pMsgWrapper );
+#else
   VOS_ASSERT( NULL !=pMsgWrapper );
+#endif
 
   if (pMsgWrapper == NULL)
   {
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_memory.c qcacld-new/CORE/VOSS/src/vos_memory.c
--- qcacld-new.orig/CORE/VOSS/src/vos_memory.c	2016-05-16 10:58:07.498298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_memory.c	2016-05-16 10:58:08.882298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
   @file vos_memory.c
@@ -62,6 +63,11 @@
 #endif
 #endif
 
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+#include <vos_getBin.h>
+#include <epping_main.h>
+#endif
+
 
 #ifdef MEMORY_DEBUG
 #include "wlan_hdd_dp_utils.h"
@@ -85,6 +91,33 @@
 /*---------------------------------------------------------------------------
  * Preprocessor Definitions and Constants
  * ------------------------------------------------------------------------*/
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+static DEFINE_MUTEX(alloc_lock);
+
+/* pre-alloced at load time
+ * following three definition must fit
+ * to avoid memory corruption */
+#define TOTOTAL_PRELOCATE (32*10 + 64*2 + 128*1 + 256*1)*1024
+static struct vos_prealloc vos_allocs[] = {
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 32 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 64 * 1024, NULL},
+	{0, 128 * 1024, NULL},
+	{0, 256 * 1024, NULL},
+};
+
+v_BYTE_t pre_alloc_pool[TOTOTAL_PRELOCATE];
+
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
 
 /*---------------------------------------------------------------------------
  * Type Declarations
@@ -97,6 +130,74 @@
 /*---------------------------------------------------------------------------
  * External Function implementation
  * ------------------------------------------------------------------------*/
+
+#ifdef CONFIG_VOS_MEM_PRE_ALLOC
+
+/* pre-alloced at load time*/
+v_UINT_t vos_prealloc_init(v_VOID_t)
+{
+	v_UINT_t i;
+	v_UINT_t alloc_pos = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		vos_allocs[i].occupied = 0;
+		vos_allocs[i].ptr = &pre_alloc_pool[alloc_pos];
+		alloc_pos += vos_allocs[i].size;
+		if (alloc_pos > TOTOTAL_PRELOCATE)
+			return -ENOMEM;
+	}
+	return 0;
+}
+v_VOID_t vos_prealloc_deinit(v_VOID_t)
+{
+	v_UINT_t i;
+
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++)
+		vos_allocs[i].occupied = 0;
+}
+v_VOID_t *vos_prealloc_get(v_UINT_t size)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return NULL;
+
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].occupied)
+			continue;
+		if (vos_allocs[i].size > size) {
+			/* we found the slot */
+			vos_allocs[i].occupied = 1;
+			mutex_unlock(&alloc_lock);
+			return vos_allocs[i].ptr;
+		}
+	}
+	VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_FATAL,
+		"vos_pre: %s: prealloc not available at size %d\n", __func__, size);
+	mutex_unlock(&alloc_lock);
+	return NULL;
+}
+
+v_SINT_t vos_prealloc_put(v_VOID_t *ptr)
+{
+	v_UINT_t i = 0;
+
+	if (WLAN_IS_EPPING_ENABLED(vos_get_conparam()))
+		return 0;
+	mutex_lock(&alloc_lock);
+	for (i = 0; i < ARRAY_SIZE(vos_allocs); i++) {
+		if (vos_allocs[i].ptr == ptr) {
+			vos_allocs[i].occupied = 0;
+			mutex_unlock(&alloc_lock);
+			return 1;
+		}
+	}
+	mutex_unlock(&alloc_lock);
+	return 0;
+}
+#endif /* CONFIG_VOS_MEM_PRE_ALLOC */
+
 #ifdef MEMORY_DEBUG
 void vos_mem_init()
 {
@@ -206,7 +307,7 @@
 
    if (!memory_dbug_flag)
    {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
       if (size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
       {
           v_VOID_t *pmem;
@@ -214,6 +315,14 @@
           if (NULL != pmem)
               return pmem;
       }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if (size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		v_VOID_t *pmem;
+		pmem = vos_prealloc_get(size);
+		if (NULL != pmem)
+			return pmem;
+	}
 #endif
       return kmalloc(size, flags);
    }
@@ -256,9 +365,12 @@
 
     if (!memory_dbug_flag)
     {
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
         if (wcnss_prealloc_put(ptr))
            return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+		if (vos_prealloc_put(ptr))
+   			return;
 #endif
         kfree(ptr);
     }
@@ -301,7 +413,7 @@
 v_VOID_t * vos_mem_malloc( v_SIZE_t size )
 {
    int flags = GFP_KERNEL;
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC) || defined(CONFIG_VOS_MEM_PRE_ALLOC)
     v_VOID_t* pmem;
 #endif
    if (size > (1024*1024))
@@ -313,13 +425,20 @@
    {
       flags = GFP_ATOMIC;
    }
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
    if(size > WCNSS_PRE_ALLOC_GET_THRESHOLD)
    {
        pmem = wcnss_prealloc_get(size);
        if(NULL != pmem)
            return pmem;
    }
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(size > VOS_PRE_ALLOC_GET_THRESHOLD)
+	{
+		pmem = vos_prealloc_get(size);
+		if(NULL != pmem)
+			return pmem;
+	}
 #endif
    return kmalloc(size, flags);
 }
@@ -329,9 +448,12 @@
     if (ptr == NULL)
       return;
 
-#ifdef CONFIG_WCNSS_MEM_PRE_ALLOC
+#if defined(CONFIG_WCNSS_MEM_PRE_ALLOC)
     if(wcnss_prealloc_put(ptr))
         return;
+#elif defined(CONFIG_VOS_MEM_PRE_ALLOC)
+	if(vos_prealloc_put(ptr))
+		return;
 #endif
 
     kfree(ptr);
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_nvitem.c qcacld-new/CORE/VOSS/src/vos_nvitem.c
--- qcacld-new.orig/CORE/VOSS/src/vos_nvitem.c	2016-05-16 10:58:07.506298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_nvitem.c	2016-05-16 10:58:08.882298648 +0800
@@ -18,7 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
-
+/*Gerbera - WiFi*/
 /*
  * Copyright (c) 2012-2014 Qualcomm Atheros, Inc.
  * All Rights Reserved.
@@ -2609,7 +2609,7 @@
    v_CONTEXT_t pVosContext = NULL;
    hdd_context_t *pHddCtx = NULL;
    struct wiphy *wiphy = NULL;
-   int status;
+   unsigned long rc;
 
    // sanity checks
    if (NULL == pRegDomain)
@@ -2678,11 +2678,10 @@
 
            INIT_COMPLETION(pHddCtx->driver_crda_req);
            regulatory_hint(wiphy, countryCode);
-           status = wait_for_completion_interruptible_timeout(
+           rc = wait_for_completion_timeout(
                    &pHddCtx->driver_crda_req,
                    msecs_to_jiffies(CRDA_WAIT_TIME));
-           if (!status)
-           {
+           if (!rc) {
                VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
                        "%s: Timeout waiting for CRDA REQ", __func__);
            }
@@ -2786,6 +2785,7 @@
     if (request->initiator == NL80211_REGDOM_SET_BY_USER)
     {
        int status;
+       unsigned long rc;
        wiphy_dbg(wiphy, "info: set by user\n");
        memset(ccode, 0, WNI_CFG_COUNTRY_CODE_LEN);
        memcpy(ccode, request->alpha2, 2);
@@ -2811,11 +2811,10 @@
                                    eSIR_FALSE);
        if (eHAL_STATUS_SUCCESS == status)
        {
-          status = wait_for_completion_interruptible_timeout(
-                                       &change_country_code,
-                                       msecs_to_jiffies(WLAN_WAIT_TIME_COUNTRY));
-          if(status <= 0)
-          {
+          rc = wait_for_completion_timeout(
+                           &change_country_code,
+                           msecs_to_jiffies(WLAN_WAIT_TIME_COUNTRY));
+          if (!rc) {
              wiphy_dbg(wiphy, "info: set country timed out\n");
           }
        }
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_sched.c qcacld-new/CORE/VOSS/src/vos_sched.c
--- qcacld-new.orig/CORE/VOSS/src/vos_sched.c	2016-05-16 10:58:07.498298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_sched.c	2016-05-16 10:58:08.882298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /*===========================================================================
   @file vos_sched.c
@@ -104,8 +105,8 @@
 void vos_sched_flush_rx_mqs(pVosSchedContext SchedContext);
 extern v_VOID_t vos_core_return_msg(v_PVOID_t pVContext, pVosMsgWrapper pMsgWrapper);
 
-
 #ifdef QCA_CONFIG_SMP
+#ifndef CONFIG_CUST_PLATFORM
 static int vos_set_cpus_allowed_ptr(struct task_struct *task,
                                     unsigned long cpu)
 {
@@ -117,6 +118,7 @@
    return 0;
 #endif
 }
+#endif /* #ifndef CONFIG_CUST_PLATFORM */
 
 static int vos_cpu_hotplug_notify(struct notifier_block *block,
                                   unsigned long state, void *hcpu)
@@ -166,7 +168,7 @@
        affine_cpu = pref_cpu;
 
    return NOTIFY_OK;
-}
+
 
 static struct notifier_block vos_cpu_hotplug_notifier = {
    .notifier_call = vos_cpu_hotplug_notify,
@@ -1549,28 +1551,28 @@
    unsigned long pref_cpu = 0;
    bool shutdown = false;
    int status, i;
-
    set_user_nice(current, -1);
 #ifdef MSM_PLATFORM
    set_wake_up_idle(true);
 #endif
 
-   /* Find the available cpu core other than cpu 0 and
-    * bind the thread */
-   for_each_online_cpu(i) {
-       if (i == 0)
-           continue;
-       pref_cpu = i;
-       break;
-   }
-   if (pref_cpu != 0 && (!vos_set_cpus_allowed_ptr(current, pref_cpu)))
-       affine_cpu = pref_cpu;
 
-   if (!arg) {
-       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
-       "%s: Bad Args passed", __func__);
-       return 0;
-   }
+	/* Find the available cpu core other than cpu 0 and
+	 * bind the thread */
+	for_each_online_cpu(i) {
+		if (i == 0)
+			continue;
+		pref_cpu = i;
+		break;
+	}
+	if (pref_cpu != 0 && (!vos_set_cpus_allowed_ptr(current, pref_cpu)))
+		affine_cpu = pref_cpu;
+
+	if (!arg) {
+		VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+		"%s: Bad Args passed", __func__);
+		return 0;
+	}
 
    complete(&pSchedContext->TlshimRxStartEvent);
 
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_sched.h qcacld-new/CORE/VOSS/src/vos_sched.h
--- qcacld-new.orig/CORE/VOSS/src/vos_sched.h	2016-05-16 10:58:07.490298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_sched.h	2016-05-16 10:58:08.882298648 +0800
@@ -18,6 +18,7 @@
  * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  * PERFORMANCE OF THIS SOFTWARE.
  */
+/*Gerbera - WiFi*/
 
 /*
  * This file was originally distributed by Qualcomm Atheros, Inc.
diff -urN qcacld-new.orig/CORE/VOSS/src/vos_timer.c qcacld-new/CORE/VOSS/src/vos_timer.c
--- qcacld-new.orig/CORE/VOSS/src/vos_timer.c	2016-05-16 10:58:07.490298648 +0800
+++ qcacld-new/CORE/VOSS/src/vos_timer.c	2016-05-16 10:58:08.874298648 +0800
@@ -24,6 +24,7 @@
  * under proprietary terms before Copyright ownership was assigned
  * to the Linux Foundation.
  */
+/*Gerbera - WiFi*/
 
 /**=========================================================================
 
@@ -68,6 +69,341 @@
 /*-------------------------------------------------------------------------
   Function declarations and documenation
   ------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+void vos_timer_print(void);
+void vos_timer_check_list(void);
+
+typedef struct {
+    vos_timer_callback_t callback;
+    v_PVOID_t data;
+} vos_timer_callback_data_t;
+
+void vos_timer_callback(void* data)
+{
+    vos_timer_callback_data_t* userdata = (vos_timer_callback_data_t*)data;
+
+    if (userdata && userdata->callback) {
+       (*userdata->callback)(userdata->data);
+    }
+    vos_timer_check_list();
+    if (data) {
+        vos_mem_free(data);
+    }
+}
+
+#ifdef VOS_TIMER_SPINLOCK_DEBUG
+#include <queue.h>
+
+struct vos_timer_spinlock_debug_item{
+    TAILQ_ENTRY(vos_timer_spinlock_debug_item) list;
+    const char* funcName;
+    unsigned int lineNum;
+    vos_timer_t *t;
+    enum {
+        SPINLOCK_FREE = 0,
+        SPINLOCK_LOCK = 1,
+        SPINLOCK_UNLOCK = 2 } state;
+};
+
+#define VOS_TIMER_SPINLOCK_DEBUG_MAX 256
+#define VOS_TIMER_SPINLOCK_DEBUG_HASH_MAX 257
+struct {
+	struct vos_timer_spinlock_debug_item array[VOS_TIMER_SPINLOCK_DEBUG_MAX];
+        TAILQ_HEAD(, vos_timer_spinlock_debug_item) hash[VOS_TIMER_SPINLOCK_DEBUG_HASH_MAX];
+	TAILQ_HEAD(free_list_t, vos_timer_spinlock_debug_item) free_list;
+} spinlock_debug;
+
+void vos_timer_spinlock_debug_init(void)
+{
+    int i;
+    vos_mem_zero(&spinlock_debug, sizeof(spinlock_debug));
+    for (i = 0; i < VOS_TIMER_SPINLOCK_DEBUG_HASH_MAX; i++) {
+        TAILQ_INIT(&spinlock_debug.hash[i]);
+    }
+    TAILQ_INIT(&spinlock_debug.free_list);
+    for (i = 0; i < VOS_TIMER_SPINLOCK_DEBUG_MAX; i++) {
+        TAILQ_INSERT_TAIL(&spinlock_debug.free_list, &spinlock_debug.array[i], list);
+    }
+}
+
+int vos_timer_spinlock_debug_get_index(vos_timer_t *t)
+{
+    unsigned long idx;
+
+    idx = ((unsigned long)t & 0x000000ff) +
+          (((unsigned long)t & 0x0000ff00) >> 8) +
+          (((unsigned long)t & 0x00ff0000) >> 16) +
+          (((unsigned long)t & 0xff000000) >> 24);
+    return ((int)idx)%VOS_TIMER_SPINLOCK_DEBUG_HASH_MAX;
+}
+
+void vos_timer_spinlock_debug_add(vos_timer_t *t)
+{
+    int idx;
+    struct vos_timer_spinlock_debug_item* item;
+
+    if ((t->ptimerNode == NULL) || ((unsigned int)(t->ptimerNode) & 0xffff0000) == 0x6b6b0000) {
+        printk(KERN_EMERG "%s: t:%p is corrupt\n", __func__, t);
+        return;
+    }
+    if (TAILQ_EMPTY(&spinlock_debug.free_list)) {
+        printk(KERN_EMERG "%s: no free debug item\n", __func__);
+        return;
+    }
+
+    item = TAILQ_FIRST(&spinlock_debug.free_list);
+    TAILQ_REMOVE(&spinlock_debug.free_list, item, list);
+    idx = vos_timer_spinlock_debug_get_index(t);
+//    printk(KERN_EMERG "%s: t:%p idx:%d %s:%d\n", __func__, t, idx, t->ptimerNode->funcName, t->ptimerNode->lineNum);
+
+    item->t = t;
+    item->lineNum = t->ptimerNode->lineNum;
+    item->funcName = t->ptimerNode->funcName;
+    item->state = SPINLOCK_UNLOCK;
+
+    TAILQ_INSERT_HEAD(&spinlock_debug.hash[idx], item, list);
+}
+
+static inline void vos_timer_spinlock_debug_print(struct vos_timer_spinlock_debug_item* item)
+{
+    printk(KERN_EMERG "item:%p:%d:%s:%d\n",
+           item->t,
+           item->state,
+           (item->lineNum != 0) ? item->funcName: "",
+           item->lineNum);
+}
+
+void vos_timer_spinlock_debug_destroy(vos_timer_t *t, const char* func, int line)
+{
+    int idx;
+    struct vos_timer_spinlock_debug_item* item, *tmp;
+
+    if (t == NULL) {
+        return;
+    } else {
+        idx = vos_timer_spinlock_debug_get_index(t);
+    }
+
+    if ((t->ptimerNode == NULL) || ((unsigned int)(t->ptimerNode) & 0xffff0000) == 0x6b6b0000) {
+        printk(KERN_EMERG "%s:%d: t:%p is corrupt\n", func, line, t);
+        goto error;
+    }
+
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        if (item->t == t) {
+            item->state = SPINLOCK_FREE;
+            TAILQ_REMOVE(&spinlock_debug.hash[idx], item, list);
+            TAILQ_INSERT_TAIL(&spinlock_debug.free_list, item, list);
+            return;
+        }
+    }
+
+    TAILQ_FOREACH_REVERSE_SAFE(item, &spinlock_debug.free_list, free_list_t, list, tmp) {
+        if (item->t == t) {
+            printk(KERN_EMERG "%s:%d: t:%p idx:%d already freed\n", func, line, t, idx);
+            vos_timer_spinlock_debug_print(item);
+            VOS_BUG(0);
+            return;
+        }
+    }
+    printk(KERN_EMERG "%s:%d: t:%p idx:%d not found\n", func, line, t, idx);
+error:
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        vos_timer_spinlock_debug_print(item);
+    }
+    VOS_BUG(0);
+}
+
+void vos_timer_spinlock_debug_lock(vos_timer_t *t, const char* func, int line)
+{
+    int idx;
+    struct vos_timer_spinlock_debug_item* item, *tmp;
+
+    if (t == NULL) {
+        return;
+    } else {
+        idx = vos_timer_spinlock_debug_get_index(t);
+    }
+
+    if ((t->ptimerNode == NULL) || ((unsigned int)(t->ptimerNode) & 0xffff0000) == 0x6b6b0000) {
+        printk(KERN_EMERG "%s:%d: t:%p is corrupt\n", func, line, t);
+        goto error;
+    }
+
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        if (item->t == t) {
+            if (item->state != SPINLOCK_UNLOCK) {
+                printk(KERN_EMERG "%s:%d: t:%p incorrect state\n", func, line, t);
+                vos_timer_spinlock_debug_print(item);
+                VOS_BUG(0);
+            } else {
+                item->state = SPINLOCK_LOCK;
+            }
+            return;
+        }
+    }
+
+    TAILQ_FOREACH_REVERSE_SAFE(item, &spinlock_debug.free_list, free_list_t, list, tmp) {
+        if (item->t == t) {
+            printk(KERN_EMERG "%s:%d: t:%p idx:%d already freed\n", func, line, t, idx);
+            vos_timer_spinlock_debug_print(item);
+            VOS_BUG(0);
+            return;
+        }
+    }
+    printk(KERN_EMERG "%s:%d: t:%p idx:%d not found\n", func, line, t, idx);
+error:
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        vos_timer_spinlock_debug_print(item);
+    }
+    VOS_BUG(0);
+
+}
+
+void vos_timer_spinlock_debug_unlock(vos_timer_t *t, const char* func, int line)
+{
+    int idx;
+    struct vos_timer_spinlock_debug_item* item, *tmp;
+
+    if (t == NULL) {
+        return;
+    } else {
+        idx = vos_timer_spinlock_debug_get_index(t);
+    }
+
+    if ((t->ptimerNode == NULL) || ((unsigned int)(t->ptimerNode) & 0xffff0000) == 0x6b6b0000) {
+        printk(KERN_EMERG "%s:%d: t:%p is corrupt\n", func, line, t);
+        goto error;
+    }
+
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        if (item->t == t) {
+            if (item->state != SPINLOCK_LOCK) {
+                printk(KERN_EMERG "%s:%d: t:%p incorrect state\n", func, line, t);
+                vos_timer_spinlock_debug_print(item);
+                VOS_BUG(0);
+            } else {
+                item->state = SPINLOCK_UNLOCK;
+            }
+            return;
+        }
+    }
+
+    TAILQ_FOREACH_REVERSE_SAFE(item, &spinlock_debug.free_list, free_list_t, list, tmp) {
+        if (item->t == t) {
+            printk(KERN_EMERG "%s:%d: t:%p idx:%d already freed\n", func, line, t, idx);
+            vos_timer_spinlock_debug_print(item);
+            VOS_BUG(0);
+            return;
+        }
+    }
+    printk(KERN_EMERG "%s:%d: t:%p idx:%d not found\n", func, line, t, idx);
+error:
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        vos_timer_spinlock_debug_print(item);
+    }
+    VOS_BUG(0);
+}
+
+
+int vos_timer_spinlock_check_if_not_unlock(vos_timer_t *t, const char* func, int line)
+{
+    int idx;
+    struct vos_timer_spinlock_debug_item* item, *tmp;
+
+    if (t == NULL) {
+        return true;
+    } else {
+        idx = vos_timer_spinlock_debug_get_index(t);
+    }
+
+    if ((t->ptimerNode == NULL) || ((unsigned int)(t->ptimerNode) & 0xffff0000) == 0x6b6b0000) {
+        printk(KERN_EMERG "%s:%d: t:%p is corrupt\n", func, line, t);
+        goto error;
+    }
+
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        if (item->t == t) {
+            if (item->state != SPINLOCK_UNLOCK) {
+                printk(KERN_EMERG "%s:%d: t:%p incorrect state\n", func, line, t);
+                vos_timer_spinlock_debug_print(item);
+                VOS_BUG(0);
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    TAILQ_FOREACH_REVERSE_SAFE(item, &spinlock_debug.free_list, free_list_t, list, tmp) {
+        if (item->t == t) {
+            printk(KERN_EMERG "%s:%d: t:%p idx:%d already freed\n", func, line, t, idx);
+            vos_timer_spinlock_debug_print(item);
+            VOS_BUG(0);
+            return true;
+        }
+    }
+    printk(KERN_EMERG "%s:%d: t:%p idx:%d not found\n", func, line, t, idx);
+error:
+    TAILQ_FOREACH_SAFE(item, &spinlock_debug.hash[idx], list, tmp) {
+        vos_timer_spinlock_debug_print(item);
+    }
+    VOS_BUG(0);
+    return true;
+}
+#endif
+#endif
+
+#ifdef VOS_TIMER_SPINLOCK_DEBUG
+#define VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line)        \
+    do {                                                                       \
+        vos_timer_spinlock_debug_lock(timer, func, line);                      \
+        spin_lock_irqsave( &timer->platformInfo.spinlock,flags );              \
+    } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line)   \
+    do {                                                                       \
+        vos_timer_spinlock_debug_unlock(timer, func, line);                    \
+        spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );         \
+    } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_INIT(timer, func, line)                       \
+   do {                                                                        \
+       vos_timer_spinlock_debug_add(timer);                                    \
+       spin_lock_init(&timer->platformInfo.spinlock);                          \
+   } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_DESTROY(timer, func, line)                    \
+   do {                                                                        \
+      vos_timer_spinlock_debug_destroy(timer, func, line);                     \
+   } while (0)
+
+
+#define VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, func, line)              \
+   vos_timer_spinlock_check_if_not_unlock(timer, func, line)
+
+#else
+
+#define VOS_TIMER_SPINLOCK_DEBUG_INIT(timer, func, line)                       \
+    do {                                                                       \
+        spin_lock_init(&timer->platformInfo.spinlock);                         \
+    } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line)        \
+    do {                                                                       \
+        spin_lock_irqsave( &timer->platformInfo.spinlock,flags );              \
+    } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line)   \
+    do {                                                                       \
+        spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );         \
+    } while (0)
+
+#define VOS_TIMER_SPINLOCK_DEBUG_DESTROY(timer, func, line)
+
+#define VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, func, line) (false)
+
+#endif
 // TBD: Need to add code for deferred timers implementation
 
 // clean up timer states after it has been deactivated
@@ -121,8 +457,15 @@
    v_PVOID_t userData=NULL;
    int threadId;
    VOS_TIMER_TYPE type=VOS_TIMER_TYPE_SW;
+#ifdef TIMER_MANAGER
+   vos_timer_callback_data_t* cbdata = NULL;
+#endif
 
+#ifdef CONFIG_VD_PREVENT_DEADCODE
+   VOS_ASSERT_VD (timer);
+#else
    VOS_ASSERT(timer);
+#endif
 
    if (timer == NULL)
    {
@@ -130,8 +473,42 @@
      return;
    }
 
+#ifdef TIMER_MANAGER
+   if ((((unsigned int)(timer->ptimerNode) & 0xffff0000) == 0x6b6b0000) ||
+       (timer->ptimerNode == NULL) ||
+       (timer->platformInfo.cookie != LINUX_TIMER_COOKIE) ||
+       (timer->type > VOS_TIMER_TYPE_WAKE_APPS) ||
+       (timer->state > VOS_TIMER_STATE_RUNNING) ||
+       (timer->state == 0) ||
+#ifdef CONFIG_DEBUG_SPINLOCK
+       || (timer->platformInfo.spinlock.rlock.magic != SPINLOCK_MAGIC)
+#endif
+      ){
+       vos_timer_print();
+       VOS_BUG(0);
+       return;
+   }
+#else
+   if ((timer->platformInfo.cookie != LINUX_TIMER_COOKIE)
+       || (timer->type > VOS_TIMER_TYPE_WAKE_APPS)
+       || (timer->state > VOS_TIMER_STATE_RUNNING)
+       || (timer->state == 0)
+#ifdef CONFIG_DEBUG_SPINLOCK
+       || (timer->platformInfo.spinlock.rlock.magic != SPINLOCK_MAGIC)
+#endif
+      ){
+       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_WARN, "%s incorrect timer!",__func__);
+       return;
+   }
+#endif
+   if (VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, __func__, __LINE__))
+   {
+     VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR, "%s incorrect spinlock!",__func__);
+     return;
+   }
+
    threadId = timer->platformInfo.threadID;
-   spin_lock_irqsave( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, __func__, __LINE__);
 
    switch ( timer->state )
    {
@@ -155,8 +532,23 @@
       // copy the relevant timer information to local variables;
       // once we exist from this critical section, the timer content may be modified
       // by other tasks
+#ifdef TIMER_MANAGER
+      cbdata = vos_mem_malloc(sizeof(vos_timer_callback_data_t));
+      if(cbdata == NULL) {
+          VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, __func__, __LINE__);
+          VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
+                    "%s: Not able to allocate memory for cbdata",__func__);
+          VOS_ASSERT(0);
+          return;
+      }
+      cbdata->callback = timer->callback;
+      cbdata->data = timer->userData;
+      callback = vos_timer_callback;
+      userData = cbdata;
+#else
       callback = timer->callback;
       userData = timer->userData;
+#endif
       threadId = timer->platformInfo.threadID;
       type = timer->type;
       vStatus = VOS_STATUS_SUCCESS;
@@ -167,12 +559,17 @@
       break;
    }
 
-   spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, __func__, __LINE__);
 
    if ( VOS_STATUS_SUCCESS != vStatus )
    {
       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
                 "TIMER callback called in a wrong state=%d", timer->state);
+#ifdef TIMER_MANAGER
+      if (cbdata) {
+          vos_mem_free(cbdata);
+      }
+#endif
       return;
    }
 
@@ -184,6 +581,11 @@
        VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
                  "%s: No TIMER callback, Could not enqueue timer to any queue",
                  __func__);
+#ifdef TIMER_MANAGER
+      if (cbdata) {
+          vos_mem_free(cbdata);
+      }
+#endif
        return;
    }
    // If timer has expired then call vos_client specific callback
@@ -198,8 +600,16 @@
       msg.bodyptr  = userData;
       msg.bodyval  = 0;
 
-      if(vos_tx_mq_serialize( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS)
+      if(vos_tx_mq_serialize( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS) {
          return;
+      }
+#ifdef TIMER_MANAGER
+      else {
+         if (cbdata) {
+             vos_mem_free(cbdata);
+         }
+      }
+#endif
    }
    else if ( vos_sched_is_rx_thread( threadId ) )
    {
@@ -212,8 +622,16 @@
       msg.bodyptr  = userData;
       msg.bodyval  = 0;
 
-      if(vos_rx_mq_serialize( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS)
+      if(vos_rx_mq_serialize( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS) {
          return;
+      }
+#ifdef TIMER_MANAGER
+      else {
+         if (cbdata) {
+             vos_mem_free(cbdata);
+         }
+      }
+#endif
    }
    else
    {
@@ -226,10 +644,21 @@
       msg.bodyptr  = userData;
       msg.bodyval  = 0;
 
-      if(vos_mq_post_message( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS)
+      if(vos_mq_post_message( VOS_MQ_ID_SYS, &msg ) == VOS_STATUS_SUCCESS) {
         return;
+      }
+#ifdef TIMER_MANAGER
+      else {
+         if (cbdata) {
+             vos_mem_free(cbdata);
+         }
+      }
+#endif
    }
 
+#ifdef TIMER_MANAGER
+   vos_timer_check_list();
+#endif
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
              "%s: Could not enqueue timer to any queue", __func__);
    VOS_ASSERT(0);
@@ -296,9 +725,83 @@
 {
    /* Initalizing the list with maximum size of 60000 */
    hdd_list_init(&vosTimerList, 1000);
+#ifdef VOS_TIMER_SPINLOCK_DEBUG
+   vos_timer_spinlock_debug_init();
+#endif
    return;
 }
 
+
+void vos_timer_print(void)
+{
+    v_SIZE_t listSize;
+    unsigned long flags;
+
+    hdd_list_size(&vosTimerList, &listSize);
+
+    if (listSize)
+    {
+        hdd_list_node_t* pNode;
+        timer_node_t *ptimerNode;
+        printk(KERN_EMERG "%s: List is not Empty. listSize %d ",
+                 __func__, (int)listSize);
+        spin_lock_irqsave(&vosTimerList.lock, flags);
+        list_for_each(pNode, &vosTimerList.anchor) {
+            ptimerNode = (timer_node_t*)pNode;
+            printk(KERN_EMERG "vos_timer:%p expire:%lu %s:%d\n",
+                    ptimerNode->vosTimer, ptimerNode->expire, ptimerNode->fileName, ptimerNode->lineNum);
+        }
+        spin_unlock_irqrestore(&vosTimerList.lock, flags);
+     }
+}
+
+void vos_timer_check_list(void)
+{
+    v_SIZE_t listSize;
+    unsigned long flags;
+    int trigger = false;
+
+    hdd_list_size(&vosTimerList, &listSize);
+
+    if (listSize)
+    {
+        hdd_list_node_t* pNode;
+        timer_node_t *ptimerNode;
+        spin_lock_irqsave(&vosTimerList.lock, flags);
+        list_for_each(pNode, &vosTimerList.anchor) {
+            ptimerNode = (timer_node_t*)pNode;
+            if ((ptimerNode->vosTimer == NULL) ||
+                (ptimerNode->vosTimer->ptimerNode == (void*)0x6b6b6b6b) ||
+                (ptimerNode->vosTimer->ptimerNode == NULL) ||
+                (ptimerNode->vosTimer->platformInfo.cookie != LINUX_TIMER_COOKIE) ||
+#ifdef CONFIG_DEBUG_SPINLOCK
+                (ptimerNode->vosTimer->platformInfo.spinlock.rlock.magic != SPINLOCK_MAGIC)
+#endif
+               )
+            {
+
+                if (ptimerNode->vosTimer) {
+                    printk(KERN_EMERG "vos_timer:%p %p 0x%x expire:%lu %s:%d\n",
+                           ptimerNode->vosTimer,
+                           ptimerNode->vosTimer->ptimerNode,
+                           ptimerNode->vosTimer->platformInfo.cookie,
+                           ptimerNode->expire, ptimerNode->funcName, ptimerNode->lineNum);
+                } else {
+                    printk(KERN_EMERG "vos_timer:%p expire:%lu %s:%d\n",
+                           ptimerNode->vosTimer,
+                           ptimerNode->expire, ptimerNode->funcName, ptimerNode->lineNum);
+
+                }
+                trigger = true;
+            }
+        }
+        if (trigger) {
+            VOS_BUG(0);
+        }
+        spin_unlock_irqrestore(&vosTimerList.lock, flags);
+     }
+}
+
 static void vos_timer_clean()
 {
     v_SIZE_t listSize;
@@ -402,7 +905,7 @@
 #ifdef TIMER_MANAGER
 VOS_STATUS vos_timer_init_debug( vos_timer_t *timer, VOS_TIMER_TYPE timerType,
                            vos_timer_callback_t callback, v_PVOID_t userData,
-                           char* fileName, v_U32_t lineNum )
+                           const char* fileName, const char* funcName, v_U32_t lineNum )
 {
    VOS_STATUS vosStatus;
     unsigned long flags;
@@ -428,8 +931,10 @@
    vos_mem_set(timer->ptimerNode, sizeof(timer_node_t), 0);
 
     timer->ptimerNode->fileName = fileName;
+    timer->ptimerNode->funcName = funcName;
     timer->ptimerNode->lineNum   = lineNum;
     timer->ptimerNode->vosTimer = timer;
+    timer->ptimerNode->expire = 0;
 
     spin_lock_irqsave(&vosTimerList.lock, flags);
     vosStatus = hdd_list_insert_front(&vosTimerList, &timer->ptimerNode->pNode);
@@ -442,7 +947,7 @@
 
    // set the various members of the timer structure
    // with arguments passed or with default values
-   spin_lock_init(&timer->platformInfo.spinlock);
+   VOS_TIMER_SPINLOCK_DEBUG_INIT(timer, funcName, lineNum);
    init_timer(&(timer->platformInfo.Timer));
    timer->platformInfo.Timer.function = vos_linux_timer_callback;
    timer->platformInfo.Timer.data = (unsigned long)timer;
@@ -519,7 +1024,7 @@
 
 ---------------------------------------------------------------------------*/
 #ifdef TIMER_MANAGER
-VOS_STATUS vos_timer_destroy ( vos_timer_t *timer )
+VOS_STATUS _vos_timer_destroy ( vos_timer_t *timer, const char* func, int line)
 {
    VOS_STATUS vStatus=VOS_STATUS_SUCCESS;
    unsigned long flags;
@@ -533,6 +1038,12 @@
       return VOS_STATUS_E_FAULT;
    }
 
+   if (VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, func, line))
+   {
+     VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR, "%s incorrect spinlock!",__func__);
+     return VOS_STATUS_E_FAULT;
+   }
+
    // Check if timer refers to an uninitialized object
    if ( LINUX_TIMER_COOKIE != timer->platformInfo.cookie )
    {
@@ -552,7 +1063,7 @@
    vos_mem_free(timer->ptimerNode);
 
 
-   spin_lock_irqsave( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line);
 
    switch ( timer->state )
    {
@@ -561,6 +1072,7 @@
          break;
       case VOS_TIMER_STATE_RUNNING:
          /* Stop the timer first */
+         timer->ptimerNode->expire = 0;
          del_timer(&(timer->platformInfo.Timer));
          vStatus = VOS_STATUS_SUCCESS;
          break;
@@ -579,12 +1091,12 @@
    {
       timer->platformInfo.cookie = LINUX_INVALID_TIMER_COOKIE;
       timer->state = VOS_TIMER_STATE_UNUSED;
-      spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+      VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
+      VOS_TIMER_SPINLOCK_DEBUG_DESTROY(timer, func, line);
       return vStatus;
    }
 
-   spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
-
+   VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
 
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
              "%s: Cannot destroy timer in state = %d",__func__, timer->state);
@@ -615,7 +1127,8 @@
                 "%s: Cannot destroy uninitialized timer",__func__);
       return VOS_STATUS_E_INVAL;
    }
-   spin_lock_irqsave( &timer->platformInfo.spinlock,flags );
+
+   VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line);
 
    switch ( timer->state )
    {
@@ -642,11 +1155,12 @@
    {
       timer->platformInfo.cookie = LINUX_INVALID_TIMER_COOKIE;
       timer->state = VOS_TIMER_STATE_UNUSED;
-      spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+      VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
+      VOS_TIMER_SPINLOCK_DEBUG_DESTROY(timer, func, line);
       return vStatus;
    }
 
-   spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
 
    VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR,
              "%s: Cannot destroy timer in state = %d",__func__, timer->state);
@@ -684,7 +1198,11 @@
   \sa
 
   -------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+VOS_STATUS _vos_timer_start( vos_timer_t *timer, v_U32_t expirationTime, const char* func, int line )
+#else
 VOS_STATUS vos_timer_start( vos_timer_t *timer, v_U32_t expirationTime )
+#endif
 {
    unsigned long flags;
 
@@ -700,6 +1218,12 @@
       return VOS_STATUS_E_INVAL;
    }
 
+   if (VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, func, line))
+   {
+     VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR, "%s incorrect spinlock!",__func__);
+     return VOS_STATUS_E_INVAL;
+   }
+
    // Check if timer refers to an uninitialized object
    if ( LINUX_TIMER_COOKIE != timer->platformInfo.cookie )
    {
@@ -723,18 +1247,21 @@
    }
 
    // make sure the remainer of the logic isn't interrupted
-   spin_lock_irqsave( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line);
 
    // Ensure if the timer can be started
    if ( VOS_TIMER_STATE_STOPPED != timer->state )
    {
-      spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+      VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
                 "%s: Cannot start timer in state = %d ",__func__, timer->state);
       return VOS_STATUS_E_ALREADY;
    }
 
    // Start the timer
+#ifdef TIMER_MANAGER
+   timer->ptimerNode->expire = jiffies + msecs_to_jiffies(expirationTime);
+#endif
    mod_timer( &(timer->platformInfo.Timer),
               jiffies + msecs_to_jiffies(expirationTime));
 
@@ -753,7 +1280,7 @@
       }
    }
 
-   spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
 
    return VOS_STATUS_SUCCESS;
 }
@@ -779,7 +1306,11 @@
   \sa
 
   ------------------------------------------------------------------------*/
+#ifdef TIMER_MANAGER
+VOS_STATUS _vos_timer_stop ( vos_timer_t *timer, const char* func,  int line )
+#else
 VOS_STATUS vos_timer_stop ( vos_timer_t *timer )
+#endif
 {
    unsigned long flags;
 
@@ -795,6 +1326,12 @@
       return VOS_STATUS_E_INVAL;
    }
 
+   if (VOS_TIMER_SPINLOCK_CHECK_IF_NOT_UNLOCK(timer, func, line))
+   {
+     VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_ERROR, "%s incorrect spinlock!",__func__);
+     return VOS_STATUS_E_INVAL;
+   }
+
    // Check if timer refers to an uninitialized object
    if ( LINUX_TIMER_COOKIE != timer->platformInfo.cookie )
    {
@@ -808,11 +1345,11 @@
    }
 
    // Ensure the timer state is correct
-   spin_lock_irqsave( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_LOCK_IRQSAVE(timer, flags, func, line);
 
    if ( VOS_TIMER_STATE_RUNNING != timer->state )
    {
-      spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+      VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
       VOS_TRACE(VOS_MODULE_ID_VOSS, VOS_TRACE_LEVEL_INFO_HIGH,
                 "%s: Cannot stop timer in state = %d",
                 __func__, timer->state);
@@ -821,9 +1358,12 @@
 
    timer->state = VOS_TIMER_STATE_STOPPED;
 
+#ifdef TIMER_MANAGER
+   timer->ptimerNode->expire = 0;
+#endif
    del_timer(&(timer->platformInfo.Timer));
 
-   spin_unlock_irqrestore( &timer->platformInfo.spinlock,flags );
+   VOS_TIMER_SPINLOCK_DEBUG_UNLOCK_IRQRESTORE(timer, flags, func, line);
 
    tryAllowingSleep( timer->type );
 
diff -urN qcacld-new.orig/CORE/WDA/inc/wlan_qct_wda.h qcacld-new/CORE/WDA/inc/wlan_qct_wda.h
--- qcacld-new.orig/CORE/WDA/inc/wlan_qct_wda.h	2016-05-16 10:58:06.466298648 +0800
+++ qcacld-new/CORE/WDA/inc/wlan_qct_wda.h	2016-05-16 10:58:08.738298648 +0800
@@ -1409,6 +1409,12 @@
 #define WDA_APFIND_SET_CMD                    SIR_HAL_APFIND_SET_CMD
 #endif /* WLAN_FEATURE_APFIND */
 
+#ifdef WLAN_FEATURE_EXTWOW_SUPPORT
+#define WDA_WLAN_EXT_WOW                      SIR_HAL_CONFIG_EXT_WOW
+#define WDA_WLAN_SET_APP_TYPE1_PARAMS         SIR_HAL_CONFIG_APP_TYPE1_PARAMS
+#define WDA_WLAN_SET_APP_TYPE2_PARAMS         SIR_HAL_CONFIG_APP_TYPE2_PARAMS
+#endif
+
 tSirRetStatus wdaPostCtrlMsg(tpAniSirGlobal pMac, tSirMsgQ *pMsg);
 
 #define HAL_USE_BD_RATE2_FOR_MANAGEMENT_FRAME 0x40 // Bit 6 will be used to control BD rate for Management frames
diff -urN qcacld-new.orig/firmware_bin/WCNSS_qcom_cfg.usb.ini qcacld-new/firmware_bin/WCNSS_qcom_cfg.usb.ini
--- qcacld-new.orig/firmware_bin/WCNSS_qcom_cfg.usb.ini	2016-05-16 10:58:07.642298648 +0800
+++ qcacld-new/firmware_bin/WCNSS_qcom_cfg.usb.ini	2016-05-16 10:58:08.950298648 +0800
@@ -157,7 +157,7 @@
 
 # 802.11d support
 
-g11dSupportEnabled=1
+g11dSupportEnabled=0
 
 # 802.11h support
 
@@ -335,10 +335,13 @@
 #gGoKeepAlivePeriod/gApKeepAlivePeriod is time to spend to check whether frame are succeed to send or not.
 #Hence total effective detection time is gGoLinkMonitorPeriod+ gGoKeepAlivePeriod/gApLinkMonitorPeriod+ gApKeepAlivePeriod.
 
+gApLinkMonitorPeriod = 5
 
-gGoKeepAlivePeriod = 20
+gGoLinkMonitorPeriod = 5
 
-gApKeepAlivePeriod = 20
+gGoKeepAlivePeriod = 10
+
+gApKeepAlivePeriod = 10
 
 
 #If set will start with active scan after driver load, otherwise will start with
@@ -377,7 +380,7 @@
 # Valid values are 0,1,2. If commented out, the default value is 0.
 # 0=MCS0-7, 1=MCS0-8, 2=MCS0-9
 gEnable2x2=1
-gVhtRxMCS2x2=0
+gVhtRxMCS2x2=2
 gVhtTxMCS2x2=2
 
 # Enable CRDA regulatory support by settings default country code
@@ -499,30 +502,33 @@
 gPNOScanSupport=0
 
 #Enable TDLS
-gEnableTDLSSupport=1
+gEnableTDLSSupport=0
 
 # Regulatory Setting; 0=STRICT; 1=CUSTOM
 gRegulatoryChangeCountry=1
 
+# Disable change country code from userspace (supplicant)
+gCountryCodePriority = 0
+
 # Disable FW log function by default
 gFwDebugLogType=0
 gFwDebugModuleLoglevel=0,0
 
 # Enable or Disable Rx thread
 # 1=Enable (default), 0=Disable
-gEnableRxThread=0
+gEnableRxThread=1
 
 # Enable or Disable FW self-recovery
 # Currently, It's for USB only.
 # 1=Enable, 0=Disable (default)
-gEnableFwSelfRecovery=0
+gEnableFwSelfRecovery=1
 
 # Enable or Disable SAP suspend
 # 1=Enable (default), 0=Disable
 gEnableSapSuspend=0
 
 # Enable TxBF
-gTxBFEnable=1
+#gTxBFEnable=1
 
 # Enable or Disable DHCP Server offload
 # 1=Enable, 0=Disable (default)
@@ -543,6 +549,8 @@
 # gSAPAuthOffloadKey: Passphrase of Security
 # gSAPAuthOffloadKey=12345678
 
+# Set SWOL APP1 PIN number
+extWowApp1WakeupPinNumber=12
 
 END
 
Binary files qcacld-new.orig/firmware_bin/WCNSS_qcom_wlan_nv.bin and qcacld-new/firmware_bin/WCNSS_qcom_wlan_nv.bin differ
diff -urN qcacld-new.orig/Kbuild qcacld-new/Kbuild
--- qcacld-new.orig/Kbuild	2016-05-16 10:58:07.642298648 +0800
+++ qcacld-new/Kbuild	2016-05-16 10:58:08.950298648 +0800
@@ -51,7 +51,7 @@
 		CONFIG_PRIMA_WLAN_11AC_HIGH_TP := n
 	endif
 	#Flag to enable TDLS feature
-	CONFIG_QCOM_TDLS := y
+	CONFIG_QCOM_TDLS := n
 
 	#Flag to enable Fast Transition (11r) feature
 	CONFIG_QCOM_VOWIFI_11R := y
@@ -105,7 +105,7 @@
 BUILD_DIAG_VERSION := 1
 
 #Do we panic on bug?  default is to warn
-PANIC_ON_BUG := 1
+PANIC_ON_BUG := 0
 
 #Re-enable wifi on WDI timeout
 RE_ENABLE_WIFI_ON_WDI_TIMEOUT := 0
@@ -118,7 +118,7 @@
 CONFIG_ATH_PERF_PWR_OFFLOAD := 1
 
 #Disable packet log
-CONFIG_REMOVE_PKT_LOG := 0
+CONFIG_REMOVE_PKT_LOG := 1
 
 #Enable 11AC TX
 ifeq ($(CONFIG_ROME_IF),pci)
@@ -211,6 +211,9 @@
 #Enable GTK offload
 CONFIG_GTK_OFFLOAD := 1
 
+ifeq ($(CONFIG_ROME_IF),usb)
+	CONFIG_EXT_WOW := 1
+endif
 #Set this to 1 to catch erroneous Target accesses during debug.
 CONFIG_ATH_PCIE_ACCESS_DEBUG := 0
 endif
@@ -263,6 +266,7 @@
 endif
 
 ############ BAP ############
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
 BAP_DIR :=	CORE/BAP
 BAP_INC_DIR :=	$(BAP_DIR)/inc
 BAP_SRC_DIR :=	$(BAP_DIR)/src
@@ -290,6 +294,7 @@
 		$(BAP_SRC_DIR)/bapRsnTxRx.o \
 		$(BAP_SRC_DIR)/btampFsm.o \
 		$(BAP_SRC_DIR)/btampHCI.o
+endif
 
 ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
 ############ HIF ############
@@ -411,6 +416,11 @@
 HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_tdls.o
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+HDD_OBJS +=	$(HDD_SRC_DIR)/wlan_hdd_direct_audio.o
+endif
+
+
 ############ EPPING ############
 EPPING_DIR :=	CORE/EPPING
 EPPING_INC_DIR :=	$(EPPING_DIR)/inc
@@ -933,6 +943,10 @@
 		$(WDI_INC) \
 		$(DFS_INC)
 
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
+INCS +=		$(BAP_INC)
+endif
+
 ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
 INCS +=		$(DXE_INC)
 else
@@ -962,8 +976,7 @@
 
 endif
 
-OBJS :=		$(BAP_OBJS) \
-		$(HDD_OBJS) \
+OBJS :=	$(HDD_OBJS) \
 		$(EPPING_OBJS) \
 		$(MAC_OBJS) \
 		$(SAP_OBJS) \
@@ -975,6 +988,10 @@
 		$(WDI_OBJS) \
 		$(DFS_OBJS)
 
+ifeq ($(CONFIG_PRIMA_WLAN_BTAMP),y)
+OBJS +=		$(BAP_OBJS)
+endif
+
 ifeq ($(CONFIG_QCA_WIFI_2_0), 0)
 OBJS +=		$(DXE_OBJS) \
 		$(TL_OBJS)
@@ -1017,7 +1034,6 @@
 		-DWLAN_PERF \
 		-DPTT_SOCK_SVC_ENABLE \
 		-Wall\
-		-Werror\
 		-D__linux__ \
 		-DHAL_SELF_STA_PER_BSS=1 \
 		-DWLAN_FEATURE_VOWIFI_11R \
@@ -1057,6 +1073,10 @@
 		-DFEATURE_WLAN_EXTSCAN \
 		-DQCA_LL_TX_FLOW_CT
 
+ifneq ($(CONFIG_REMOVE_WERR),y)
+CDEFINES += -Werror
+endif
+
 ifeq ($(CONFIG_QCA_WIFI_SDIO), 1)
 CDEFINES +=     -DCONFIG_HL_SUPPORT \
                 -DCONFIG_AR6320_SUPPORT \
@@ -1112,10 +1132,11 @@
 		-DDEBUG
 endif
 
-ifeq ($(CONFIG_SLUB_DEBUG_ON),y)
-CDEFINES += -DTIMER_MANAGER
-CDEFINES += -DMEMORY_DEBUG
-endif
+# only for debug but seemed having issues. disable it for now
+#ifeq ($(CONFIG_SLUB_DEBUG_ON),y)
+#CDEFINES += -DTIMER_MANAGER
+#CDEFINES += -DMEMORY_DEBUG
+#endif
 
 ifeq ($(HAVE_CFG80211),1)
 CDEFINES += -DWLAN_FEATURE_P2P
@@ -1356,6 +1377,11 @@
 CDEFINES += -DIGTK_OFFLOAD
 endif
 
+#Enable GTK Offload
+ifeq ($(CONFIG_EXT_WOW), 1)
+CDEFINES += -DWLAN_FEATURE_EXTWOW_SUPPORT
+endif
+
 #Mark it as SMP Kernel
 ifeq ($(CONFIG_SMP),y)
 CDEFINES += -DQCA_CONFIG_SMP
@@ -1449,6 +1475,39 @@
 endif
 endif
 
+ifeq ($(CONFIG_DIRECT_AUDIO),y)
+CDEFINES += -DDIRECT_AUDIO_SUPPORT
+CDEFINES += -DCONFIG_CONTX_USB_DEBUG
+endif
+
+ifeq ($(CONFIG_VOS_MEM_PRE_ALLOC),y)
+CDEFINES += -DCONFIG_VOS_MEM_PRE_ALLOC
+endif
+
+ifeq ($(CONFIG_USB_PRELOAD),y)
+CDEFINES += -DCONFIG_USB_PRELOAD
+endif
+
+ifeq ($(CONFIG_SS_REGULATORY),y)
+CDEFINES += -DSS_REGULATORY
+endif
+
+ifeq ($(CONFIG_CUST_PLATFORM),y)
+CDEFINES += -DCONFIG_CUST_PLATFORM
+ifeq ($(CONFIG_FWCRASH_DUMP),y)
+CDEFINES += -DCONFIG_CRASH_DUMP_CLD
+CDEFINES += -DCONFIG_CRASH_DUMP_STACK
+CDEFINES += -DCONFIG_WLAN_FWLOG_FILE
+endif
+
+ifeq ($(CONFIG_VD_PREVENT),y)
+CDEFINES += -DCONFIG_VD_PREVENT_DEADCODE
+CDEFINES += -DCONFIG_VD_PREVENT_NO_EFFECT
+CDEFINES += -DCONFIG_VD_PREVENT_MISSING_BREAK
+endif
+
+endif
+
 KBUILD_CPPFLAGS += $(CDEFINES)
 
 # Currently, for versions of gcc which support it, the kernel Makefile
@@ -1462,3 +1521,5 @@
 # Module information used by KBuild framework
 obj-$(CONFIG_QCA_CLD_WLAN) += $(MODNAME).o
 $(MODNAME)-y := $(OBJS)
+
+CDEFINES += -DNO_DYNAMIC_MEM_ALLOC
diff -urN qcacld-new.orig/tmp.head qcacld-new/tmp.head
--- qcacld-new.orig/tmp.head	1970-01-01 08:00:00.000000000 +0800
+++ qcacld-new/tmp.head	2016-05-16 10:58:08.654298648 +0800
@@ -0,0 +1 @@
+b47ff2aa43140e61e69c2e4644a7ee6e95c1b6df
