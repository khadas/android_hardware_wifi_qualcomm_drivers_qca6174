diff -Nuar a/frameworks/base/cmds/svc/src/com/android/commands/svc/WifiCommand.java b/frameworks/base/cmds/svc/src/com/android/commands/svc/WifiCommand.java
--- a/frameworks/base/cmds/svc/src/com/android/commands/svc/WifiCommand.java
+++ b/frameworks/base/cmds/svc/src/com/android/commands/svc/WifiCommand.java
@@ -35,12 +35,13 @@
     public String longHelp() {
         return shortHelp() + "\n"
                 + "\n"
-                + "usage: svc wifi [enable|disable]\n"
+                + "usage: svc wifi [enable|disable][sapon][sapoff]\n"
                 + "         Turn Wi-Fi on or off.\n\n";
     }
 
     public void run(String[] args) {
         boolean validCommand = false;
+        boolean apcommand = false;
         if (args.length >= 2) {
             boolean flag = false;
             if ("enable".equals(args[1])) {
@@ -49,8 +50,16 @@
             } else if ("disable".equals(args[1])) {
                 flag = false;
                 validCommand = true;
+            } else if ("sapon".equals(args[1])) {
+                flag = true;
+                validCommand = true;
+                apcommand = true;
+            } else if ("sapoff".equals(args[1])) {
+                flag = false;
+                validCommand = true;
+                apcommand = true;
             }
-            if (validCommand) {
+            if (validCommand && (apcommand == false)) {
                 IWifiManager wifiMgr
                         = IWifiManager.Stub.asInterface(ServiceManager.getService(Context.WIFI_SERVICE));
                 try {
@@ -61,6 +70,17 @@
                 }
                 return;
             }
+            if (validCommand && (apcommand == true)) {
+                IWifiManager wifiMgr
+                        = IWifiManager.Stub.asInterface(ServiceManager.getService(Context.WAP_SERVICE));
+                try {
+                    wifiMgr.setWifiApEnabled(null, flag);
+                }
+                catch (RemoteException e) {
+                    System.err.println("Wi-Fi sap operation failed: " + e);
+                }
+                return;
+            }
         }
         System.err.println(longHelp());
     }
diff -Nuar a/frameworks/base/core/java/android/app/ContextImpl.java b/frameworks/base/core/java/android/app/ContextImpl.java
--- a/frameworks/base/core/java/android/app/ContextImpl.java
+++ b/frameworks/base/core/java/android/app/ContextImpl.java
@@ -92,6 +92,7 @@
 import android.net.nsd.NsdManager;
 import android.net.wifi.IWifiManager;
 import android.net.wifi.WifiManager;
+import android.net.wifi.WifiManagerWAP;
 import android.net.wifi.p2p.IWifiP2pManager;
 import android.net.wifi.p2p.WifiP2pManager;
 import android.net.wifi.IWifiScanner;
@@ -597,6 +598,13 @@
                     return new WifiManager(ctx.getOuterContext(), service);
                 }});
 
+	registerService(WAP_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService(WAP_SERVICE);
+                    IWifiManager service = IWifiManager.Stub.asInterface(b);
+                    return new WifiManagerWAP(ctx.getOuterContext(), service);
+                }});
+
         registerService(WIFI_P2P_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(WIFI_P2P_SERVICE);
diff -Nuar a/frameworks/base/core/java/android/content/Context.java b/frameworks/base/core/java/android/content/Context.java
--- a/frameworks/base/core/java/android/content/Context.java
+++ b/frameworks/base/core/java/android/content/Context.java
@@ -2106,6 +2106,7 @@
             //@hide: NETWORK_STATS_SERVICE,
             //@hide: NETWORK_POLICY_SERVICE,
             WIFI_SERVICE,
+            WAP_SERVICE,
             WIFI_PASSPOINT_SERVICE,
             WIFI_P2P_SERVICE,
             WIFI_SCANNING_SERVICE,
@@ -2470,6 +2471,7 @@
      * @see android.net.wifi.WifiManager
      */
     public static final String WIFI_SERVICE = "wifi";
+    public static final String WAP_SERVICE = "qcomsoftap";
 
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
diff -Nuar a/frameworks/base/core/java/android/net/ConnectivityManager.java b/frameworks/base/core/java/android/net/ConnectivityManager.java
--- a/frameworks/base/core/java/android/net/ConnectivityManager.java
+++ b/frameworks/base/core/java/android/net/ConnectivityManager.java
@@ -419,11 +419,12 @@
      */
     public static final int TYPE_VPN = 17;
 
+    public static final int TYPE_WIFI_WAP = 18;
     /** {@hide} */
-    public static final int MAX_RADIO_TYPE   = TYPE_VPN;
+    public static final int MAX_RADIO_TYPE   = TYPE_WIFI_WAP;
 
     /** {@hide} */
-    public static final int MAX_NETWORK_TYPE = TYPE_VPN;
+    public static final int MAX_NETWORK_TYPE = TYPE_WIFI_WAP;
 
     /**
      * If you want to set the default network preference,you can directly
@@ -490,6 +491,8 @@
                 return "MOBILE";
             case TYPE_WIFI:
                 return "WIFI";
+            case TYPE_WIFI_WAP:
+                return "WIFIWAP";
             case TYPE_MOBILE_MMS:
                 return "MOBILE_MMS";
             case TYPE_MOBILE_SUPL:
@@ -558,6 +561,7 @@
     public static boolean isNetworkTypeWifi(int networkType) {
         switch (networkType) {
             case TYPE_WIFI:
+            case TYPE_WIFI_WAP:
             case TYPE_WIFI_P2P:
                 return true;
             default:
diff -Nuar a/frameworks/base/core/java/android/net/NetworkKey.java b/frameworks/base/core/java/android/net/NetworkKey.java
--- a/frameworks/base/core/java/android/net/NetworkKey.java
+++ b/frameworks/base/core/java/android/net/NetworkKey.java
@@ -38,6 +38,7 @@
 
     /** A wifi network, for which {@link #wifiKey} will be populated. */
     public static final int TYPE_WIFI = 1;
+    public static final int TYPE_WIFI_WAP = 18;
 
     /**
      * The type of this network.
@@ -64,6 +65,7 @@
         type = in.readInt();
         switch (type) {
             case TYPE_WIFI:
+            case TYPE_WIFI_WAP:
                 wifiKey = WifiKey.CREATOR.createFromParcel(in);
                 break;
             default:
@@ -81,6 +83,7 @@
         out.writeInt(type);
         switch (type) {
             case TYPE_WIFI:
+            case TYPE_WIFI_WAP:
                 wifiKey.writeToParcel(out, flags);
                 break;
             default:
@@ -107,6 +110,7 @@
     public String toString() {
         switch (type) {
             case TYPE_WIFI:
+            case TYPE_WIFI_WAP:
                 return wifiKey.toString();
             default:
                 // Don't throw an exception here in case someone is logging this object in a catch
diff -Nuar a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/HotspotControllerImpl.java
@@ -23,7 +23,7 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.net.ConnectivityManager;
-import android.net.wifi.WifiManager;
+import android.net.wifi.WifiManagerWAP;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.provider.Settings;
@@ -39,12 +39,12 @@
     private final ArrayList<Callback> mCallbacks = new ArrayList<Callback>();
     private final Receiver mReceiver = new Receiver();
     private final Context mContext;
-    private final WifiManager mWifiManager;
+    private final WifiManagerWAP mWifiManager;
     private final ConnectivityManager mConnectivityManager;
 
     public HotspotControllerImpl(Context context) {
         mContext = context;
-        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        mWifiManager = (WifiManagerWAP) mContext.getSystemService(Context.WAP_SERVICE);
         mConnectivityManager = (ConnectivityManager)
                 mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
     }
@@ -65,7 +65,7 @@
 
     @Override
     public boolean isHotspotEnabled() {
-        return mWifiManager.getWifiApState() == WifiManager.WIFI_AP_STATE_ENABLED;
+        return mWifiManager.getWifiApState() == WifiManagerWAP.WIFI_AP_STATE_ENABLED;
     }
 
     @Override
@@ -94,13 +94,14 @@
         // This needs to be kept up to date with Settings (WifiApEnabler.setSoftapEnabled)
         // in case it is turned on in settings and off in qs (or vice versa).
         // Disable Wifi if enabling tethering.
+/*
         int wifiState = mWifiManager.getWifiState();
-        if (enabled && ((wifiState == WifiManager.WIFI_STATE_ENABLING) ||
-                    (wifiState == WifiManager.WIFI_STATE_ENABLED))) {
+        if (enabled && ((wifiState == WifiManagerWAP.WIFI_STATE_ENABLING) ||
+                    (wifiState == WifiManagerWAP.WIFI_STATE_ENABLED))) {
             mWifiManager.setWifiEnabled(false);
             Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 1);
         }
-
+*/
         mWifiManager.setWifiApEnabled(null, enabled);
 
         // If needed, restore Wifi on tether disable.
@@ -125,7 +126,7 @@
             if (listening && !mRegistered) {
                 if (DEBUG) Log.d(TAG, "Registering receiver");
                 final IntentFilter filter = new IntentFilter();
-                filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.WIFI_AP_STATE_CHANGED_ACTION);
                 mContext.registerReceiver(this, filter);
                 mRegistered = true;
             } else if (!listening && mRegistered) {
diff -Nuar a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/NetworkControllerImpl.java
@@ -404,12 +404,13 @@
             @Override
             protected Void doInBackground(Void... args) {
                 // Disable tethering if enabling Wifi
+/*
                 final int wifiApState = mWifiManager.getWifiApState();
                 if (enabled && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
                                (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                     mWifiManager.setWifiApEnabled(null, false);
                 }
-
+*/
                 mWifiManager.setWifiEnabled(enabled);
                 return null;
             }
diff -Nuar a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiAccessPointController.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiAccessPointController.java
--- a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiAccessPointController.java
+++ b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/WifiAccessPointController.java
@@ -23,8 +23,8 @@
 import android.net.wifi.ScanResult;
 import android.net.wifi.WifiConfiguration;
 import android.net.wifi.WifiInfo;
-import android.net.wifi.WifiManager;
-import android.net.wifi.WifiManager.ActionListener;
+import android.net.wifi.WifiManagerWAP;
+import android.net.wifi.WifiManagerWAP.ActionListener;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
@@ -53,14 +53,14 @@
 
     private final Context mContext;
     private final ArrayList<AccessPointCallback> mCallbacks = new ArrayList<AccessPointCallback>();
-    private final WifiManager mWifiManager;
+    private final WifiManagerWAP mWifiManager;
     private final Receiver mReceiver = new Receiver();
 
     private boolean mScanning;
 
     public WifiAccessPointController(Context context) {
         mContext = context;
-        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
+        mWifiManager = (WifiManagerWAP) mContext.getSystemService(Context.WAP_SERVICE);
     }
 
     public void addCallback(AccessPointCallback callback) {
@@ -142,7 +142,7 @@
             if (!configured.containsKey(ssid)) continue;
             ssids.add(ssid);
             final WifiConfiguration config = configured.get(ssid);
-            final int level = WifiManager.calculateSignalLevel(scanResult.level, ICONS.length);
+            final int level = WifiManagerWAP.calculateSignalLevel(scanResult.level, ICONS.length);
             final AccessPoint ap = new AccessPoint();
             ap.networkId = config != null ? config.networkId : AccessPoint.NO_NETWORK;
             ap.ssid = ssid;
@@ -174,14 +174,14 @@
             if (listening && !mRegistered) {
                 if (DEBUG) Log.d(TAG, "Registering receiver");
                 final IntentFilter filter = new IntentFilter();
-                filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
-                filter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
-                filter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
-                filter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
-                filter.addAction(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION);
-                filter.addAction(WifiManager.LINK_CONFIGURATION_CHANGED_ACTION);
-                filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
-                filter.addAction(WifiManager.RSSI_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.WIFI_STATE_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.SCAN_RESULTS_AVAILABLE_ACTION);
+                filter.addAction(WifiManagerWAP.NETWORK_IDS_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.SUPPLICANT_STATE_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.CONFIGURED_NETWORKS_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.LINK_CONFIGURATION_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION);
+                filter.addAction(WifiManagerWAP.RSSI_CHANGED_ACTION);
                 mContext.registerReceiver(this, filter);
                 mRegistered = true;
             } else if (!listening && mRegistered) {
@@ -194,7 +194,7 @@
         @Override
         public void onReceive(Context context, Intent intent) {
             if (DEBUG) Log.d(TAG, "onReceive " + intent.getAction());
-            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
+            if (WifiManagerWAP.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                 updateAccessPoints();
                 mScanning = false;
             }
diff -Nuar a/frameworks/base/services/core/java/com/android/server/connectivity/Tethering.java b/frameworks/base/services/core/java/com/android/server/connectivity/Tethering.java
--- a/frameworks/base/services/core/java/com/android/server/connectivity/Tethering.java
+++ b/frameworks/base/services/core/java/com/android/server/connectivity/Tethering.java
@@ -48,6 +48,9 @@
 import android.os.UserHandle;
 import android.provider.Settings;
 import android.util.Log;
+import android.net.wifi.WifiManagerWAP;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiConfiguration.KeyMgmt;
 
 import com.android.internal.telephony.Phone;
 import com.android.internal.telephony.PhoneConstants;
@@ -77,6 +80,7 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
+import java.io.LineNumberReader;
 
 import static android.net.wifi.WifiManager.WIFI_AP_STATE_DISABLED;
 import static android.net.wifi.WifiManager.WIFI_AP_STATE_ENABLED;
@@ -117,6 +121,7 @@
 
     // Default Value for Extra Infomration
     public static final int EXTRA_UPSTREAM_INFO_DEFAULT = -1;
+    private WifiManagerWAP mWifiManager;
 
     private enum UpstreamInfoUpdateType {
         UPSTREAM_IFACE_REMOVED,
@@ -159,7 +164,7 @@
 
     private String[] mDhcpRange;
     private static final String[] DHCP_DEFAULT_RANGE = {
-        "192.168.42.2", "192.168.42.254", "192.168.43.2", "192.168.43.254",
+        "192.168.42.2", "192.168.42.254", "10.9.8.1", "10.9.8.100",
         "192.168.44.2", "192.168.44.254", "192.168.45.2", "192.168.45.254",
         "192.168.46.2", "192.168.46.254", "192.168.47.2", "192.168.47.254",
         "192.168.48.2", "192.168.48.254", "192.168.49.2", "192.168.49.254",
@@ -203,6 +208,7 @@
         mLooper = IoThread.get().getLooper();
         mTetherMasterSM = new TetherMasterSM("TetherMaster", mLooper);
         mTetherMasterSM.start();
+    mWifiManager = (WifiManagerWAP) context.getSystemService(Context.WAP_SERVICE);
 
         mStateReceiver = new StateReceiver();
         IntentFilter filter = new IntentFilter();
@@ -783,6 +789,31 @@
                 updateConfiguration();
             } else if(action.equals(WIFI_AP_STATE_CHANGED_ACTION)){
                 int wifiApState = intent.getIntExtra("wifi_state", WIFI_AP_STATE_DISABLED);
+                if(wifiApState == WIFI_AP_STATE_ENABLED) {
+                    WifiConfiguration wifiConfig = mWifiManager.getWifiApConfiguration();
+                    if(wifiConfig.SSID.equals("AndroidAP")) {
+                        String mac = "";
+                        String submac = "";
+                        try{
+                            Process p1= Runtime.getRuntime().exec("cat /sys/class/net/wap0/address");
+                            InputStreamReader ir = new InputStreamReader(p1.getInputStream());
+                            LineNumberReader input = new LineNumberReader(ir);
+                            mac = input.readLine();
+                        }catch (IOException e) {
+                            e.printStackTrace();
+                        }
+                        if(mac != null) {
+                            submac = mac.substring(12, 17);
+                            String ar[] = submac.split(":");
+                            wifiConfig.SSID = "ministation_" + ar[0] + ar[1];
+                            wifiConfig.preSharedKey = "12345678";
+                            wifiConfig.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
+                            mWifiManager.setWifiApConfiguration(wifiConfig);
+                            mWifiManager.setWifiApEnabled(null, false);
+                            mWifiManager.setWifiApEnabled(wifiConfig, true);
+                        }
+                    }
+                }
                 if (DBG) Log.d(TAG, "WIFI_AP_STATE_CHANGED: wifiApState="  + wifiApState);
                 if(wifiApState == WIFI_AP_STATE_ENABLED ||
                     wifiApState == WIFI_AP_STATE_DISABLED) {
diff -Nuar a/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java b/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
--- a/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
+++ b/frameworks/base/services/core/java/com/android/server/NetworkManagementService.java
@@ -1408,7 +1408,7 @@
                 mConnector.execute("softap", "set", wlanIface);
             } else {
                 mConnector.execute("softap", "set", wlanIface, wifiConfig.SSID,
-                                   "broadcast", "6", getSecurityType(wifiConfig),
+                                   "broadcast", Integer.toString(wifiConfig.apchannel), getSecurityType(wifiConfig),
                                    new SensitiveArg(wifiConfig.preSharedKey));
             }
             mConnector.execute("softap", "startap");
@@ -1458,7 +1458,7 @@
                 mConnector.execute("softap", "set", wlanIface);
             } else {
                 mConnector.execute("softap", "set", wlanIface, wifiConfig.SSID,
-                                   "broadcast", "6", getSecurityType(wifiConfig),
+                                   "broadcast", Integer.toString(wifiConfig.apchannel), getSecurityType(wifiConfig),
                                    new SensitiveArg(wifiConfig.preSharedKey));
             }
         } catch (NativeDaemonConnectorException e) {
diff -Nuar a/frameworks/base/services/java/com/android/server/SystemServer.java b/frameworks/base/services/java/com/android/server/SystemServer.java
--- a/frameworks/base/services/java/com/android/server/SystemServer.java
+++ b/frameworks/base/services/java/com/android/server/SystemServer.java
@@ -139,6 +139,8 @@
             "com.android.server.usb.UsbService$Lifecycle";
     private static final String WIFI_SERVICE_CLASS =
             "com.android.server.wifi.WifiService";
+    private static final String WAP_SERVICE_CLASS =
+            "com.android.server.wifi.WifiServiceWAP";
     private static final String WIFI_P2P_SERVICE_CLASS =
             "com.android.server.wifi.p2p.WifiP2pService";
     private static final String ETHERNET_SERVICE_CLASS =
@@ -677,6 +679,7 @@
 
                 mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
                 mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
+                mSystemServiceManager.startService(WAP_SERVICE_CLASS);
                 mSystemServiceManager.startService(
                             "com.android.server.wifi.WifiScanningService");
 
diff -Nuar a/frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.java b/frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.java
--- a/frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.java
+++ b/frameworks/base/wifi/java/android/net/wifi/WifiConfiguration.java
@@ -226,6 +226,8 @@
      * (e.g., {@code 01a243f405}).
      */
     public String SSID;
+
+    public int apchannel;
     /**
      * When set, this network configuration entry should only be used when
      * associating with the AP having the specified BSSID. The value is
@@ -836,6 +838,7 @@
         noInternetAccess = false;
         mIpConfiguration = new IpConfiguration();
         duplicateNetwork = false;
+        apchannel = 6;
     }
 
     /**
@@ -1489,6 +1492,7 @@
         dest.writeInt(status);
         dest.writeInt(disableReason);
         dest.writeString(SSID);
+        dest.writeInt(apchannel);
         dest.writeString(BSSID);
         dest.writeString(autoJoinBSSID);
         dest.writeString(FQDN);
@@ -1549,6 +1553,7 @@
                 config.status = in.readInt();
                 config.disableReason = in.readInt();
                 config.SSID = in.readString();
+                config.apchannel = in.readInt();
                 config.BSSID = in.readString();
                 config.autoJoinBSSID = in.readString();
                 config.FQDN = in.readString();
diff -Nuar a/frameworks/base/wifi/java/android/net/wifi/WifiManager.java b/frameworks/base/wifi/java/android/net/wifi/WifiManager.java
--- a/frameworks/base/wifi/java/android/net/wifi/WifiManager.java
+++ b/frameworks/base/wifi/java/android/net/wifi/WifiManager.java
@@ -563,6 +563,7 @@
     private static int sThreadRefCount;
     private static HandlerThread sHandlerThread;
     private final AppOpsManager mAppOps;
+    private boolean mIsEthUp = false;
 
     /**
      * Create a new WifiManager instance.
@@ -581,6 +582,14 @@
         mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
     }
 
+    public boolean isEthUp() {
+        return mIsEthUp;
+    }
+
+    public void setEthUp(boolean up) {
+        mIsEthUp = up;
+    }
+
     /**
      * Return a list of all the networks configured in the supplicant.
      * Not all fields of WifiConfiguration are returned. Only the following
diff -Nuar a/frameworks/base/wifi/java/android/net/wifi/WifiManagerWAP.java b/frameworks/base/wifi/java/android/net/wifi/WifiManagerWAP.java
--- a/frameworks/base/wifi/java/android/net/wifi/WifiManagerWAP.java
+++ b/frameworks/base/wifi/java/android/net/wifi/WifiManagerWAP.java
@@ -0,0 +1,2546 @@
+/*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.wifi;
+
+import android.annotation.SdkConstant;
+import android.annotation.SdkConstant.SdkConstantType;
+import android.annotation.SystemApi;
+import android.app.AppOpsManager;
+import android.content.Context;
+import android.net.DhcpInfo;
+import android.net.wifi.ScanSettings;
+import android.net.wifi.WifiChannel;
+import android.os.Binder;
+import android.os.IBinder;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.WorkSource;
+import android.os.Messenger;
+import android.util.Log;
+import android.util.SparseArray;
+
+import java.net.InetAddress;
+import java.util.concurrent.CountDownLatch;
+
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+
+import java.util.List;
+
+/**
+ * This class provides the primary API for managing all aspects of Wi-Fi
+ * connectivity. Get an instance of this class by calling
+ * {@link android.content.Context#getSystemService(String) Context.getSystemService(Context.WIFI_SERVICE)}.
+
+ * It deals with several categories of items:
+ * <ul>
+ * <li>The list of configured networks. The list can be viewed and updated,
+ * and attributes of individual entries can be modified.</li>
+ * <li>The currently active Wi-Fi network, if any. Connectivity can be
+ * established or torn down, and dynamic information about the state of
+ * the network can be queried.</li>
+ * <li>Results of access point scans, containing enough information to
+ * make decisions about what access point to connect to.</li>
+ * <li>It defines the names of various Intent actions that are broadcast
+ * upon any sort of change in Wi-Fi state.
+ * </ul>
+ * This is the API to use when performing Wi-Fi specific operations. To
+ * perform operations that pertain to network connectivity at an abstract
+ * level, use {@link android.net.ConnectivityManager}.
+ */
+public class WifiManagerWAP {
+
+    private static final String TAG = "WifiManagerWAP";
+    // Supplicant error codes:
+    /**
+     * The error code if there was a problem authenticating.
+     */
+    public static final int ERROR_AUTHENTICATING = 1;
+
+    /**
+     * Broadcast intent action indicating whether Wi-Fi scanning is allowed currently
+     * @hide
+     */
+    public static final String WIFI_SCAN_AVAILABLE = "wifi_scan_available";
+
+    /**
+     * Extra int indicating scan availability, WIFI_STATE_ENABLED and WIFI_STATE_DISABLED
+     * @hide
+     */
+    public static final String EXTRA_SCAN_AVAILABLE = "scan_enabled";
+
+    /**
+     * Broadcast intent action indicating that Wi-Fi has been enabled, disabled,
+     * enabling, disabling, or unknown. One extra provides this state as an int.
+     * Another extra provides the previous state, if available.
+     *
+     * @see #EXTRA_WIFI_STATE
+     * @see #EXTRA_PREVIOUS_WIFI_STATE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String WIFI_STATE_CHANGED_ACTION =
+        "android.net.wifi.WIFI_STATE_CHANGED";
+    /**
+     * The lookup key for an int that indicates whether Wi-Fi is enabled,
+     * disabled, enabling, disabling, or unknown.  Retrieve it with
+     * {@link android.content.Intent#getIntExtra(String,int)}.
+     *
+     * @see #WIFI_STATE_DISABLED
+     * @see #WIFI_STATE_DISABLING
+     * @see #WIFI_STATE_ENABLED
+     * @see #WIFI_STATE_ENABLING
+     * @see #WIFI_STATE_UNKNOWN
+     */
+    public static final String EXTRA_WIFI_STATE = "wifi_state";
+    /**
+     * The previous Wi-Fi state.
+     *
+     * @see #EXTRA_WIFI_STATE
+     */
+    public static final String EXTRA_PREVIOUS_WIFI_STATE = "previous_wifi_state";
+
+    /**
+     * Wi-Fi is currently being disabled. The state will change to {@link #WIFI_STATE_DISABLED} if
+     * it finishes successfully.
+     *
+     * @see #WIFI_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     */
+    public static final int WIFI_STATE_DISABLING = 0;
+    /**
+     * Wi-Fi is disabled.
+     *
+     * @see #WIFI_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     */
+    public static final int WIFI_STATE_DISABLED = 1;
+    /**
+     * Wi-Fi is currently being enabled. The state will change to {@link #WIFI_STATE_ENABLED} if
+     * it finishes successfully.
+     *
+     * @see #WIFI_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     */
+    public static final int WIFI_STATE_ENABLING = 2;
+    /**
+     * Wi-Fi is enabled.
+     *
+     * @see #WIFI_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     */
+    public static final int WIFI_STATE_ENABLED = 3;
+    /**
+     * Wi-Fi is in an unknown state. This state will occur when an error happens while enabling
+     * or disabling.
+     *
+     * @see #WIFI_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     */
+    public static final int WIFI_STATE_UNKNOWN = 4;
+
+    /**
+     * Broadcast intent action indicating that Wi-Fi AP has been enabled, disabled,
+     * enabling, disabling, or failed.
+     *
+     * @hide
+     */
+    public static final String WIFI_AP_STATE_CHANGED_ACTION =
+        "android.net.wifi.WIFI_AP_STATE_CHANGED";
+
+    /**
+     * The lookup key for an int that indicates whether Wi-Fi AP is enabled,
+     * disabled, enabling, disabling, or failed.  Retrieve it with
+     * {@link android.content.Intent#getIntExtra(String,int)}.
+     *
+     * @see #WIFI_AP_STATE_DISABLED
+     * @see #WIFI_AP_STATE_DISABLING
+     * @see #WIFI_AP_STATE_ENABLED
+     * @see #WIFI_AP_STATE_ENABLING
+     * @see #WIFI_AP_STATE_FAILED
+     *
+     * @hide
+     */
+    public static final String EXTRA_WIFI_AP_STATE = "wifi_state";
+    /**
+     * The previous Wi-Fi state.
+     *
+     * @see #EXTRA_WIFI_AP_STATE
+     *
+     * @hide
+     */
+    public static final String EXTRA_PREVIOUS_WIFI_AP_STATE = "previous_wifi_state";
+    /**
+     * Wi-Fi AP is currently being disabled. The state will change to
+     * {@link #WIFI_AP_STATE_DISABLED} if it finishes successfully.
+     *
+     * @see #WIFI_AP_STATE_CHANGED_ACTION
+     * @see #getWifiApState()
+     *
+     * @hide
+     */
+    public static final int WIFI_AP_STATE_DISABLING = 10;
+    /**
+     * Wi-Fi AP is disabled.
+     *
+     * @see #WIFI_AP_STATE_CHANGED_ACTION
+     * @see #getWifiState()
+     *
+     * @hide
+     */
+    public static final int WIFI_AP_STATE_DISABLED = 11;
+    /**
+     * Wi-Fi AP is currently being enabled. The state will change to
+     * {@link #WIFI_AP_STATE_ENABLED} if it finishes successfully.
+     *
+     * @see #WIFI_AP_STATE_CHANGED_ACTION
+     * @see #getWifiApState()
+     *
+     * @hide
+     */
+    public static final int WIFI_AP_STATE_ENABLING = 12;
+    /**
+     * Wi-Fi AP is enabled.
+     *
+     * @see #WIFI_AP_STATE_CHANGED_ACTION
+     * @see #getWifiApState()
+     *
+     * @hide
+     */
+    public static final int WIFI_AP_STATE_ENABLED = 13;
+    /**
+     * Wi-Fi AP is in a failed state. This state will occur when an error occurs during
+     * enabling or disabling
+     *
+     * @see #WIFI_AP_STATE_CHANGED_ACTION
+     * @see #getWifiApState()
+     *
+     * @hide
+     */
+    public static final int WIFI_AP_STATE_FAILED = 14;
+
+    /**
+     * Broadcast intent action indicating that a connection to the supplicant has
+     * been established (and it is now possible
+     * to perform Wi-Fi operations) or the connection to the supplicant has been
+     * lost. One extra provides the connection state as a boolean, where {@code true}
+     * means CONNECTED.
+     * @see #EXTRA_SUPPLICANT_CONNECTED
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String SUPPLICANT_CONNECTION_CHANGE_ACTION =
+        "android.net.wifi.supplicant.CONNECTION_CHANGE";
+    /**
+     * The lookup key for a boolean that indicates whether a connection to
+     * the supplicant daemon has been gained or lost. {@code true} means
+     * a connection now exists.
+     * Retrieve it with {@link android.content.Intent#getBooleanExtra(String,boolean)}.
+     */
+    public static final String EXTRA_SUPPLICANT_CONNECTED = "connected";
+    /**
+     * Broadcast intent action indicating that the state of Wi-Fi connectivity
+     * has changed. One extra provides the new state
+     * in the form of a {@link android.net.NetworkInfo} object. If the new
+     * state is CONNECTED, additional extras may provide the BSSID and WifiInfo of
+     * the access point.
+     * as a {@code String}.
+     * @see #EXTRA_NETWORK_INFO
+     * @see #EXTRA_BSSID
+     * @see #EXTRA_WIFI_INFO
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String NETWORK_STATE_CHANGED_ACTION = "android.net.wifi.STATE_CHANGE";
+    /**
+     * The lookup key for a {@link android.net.NetworkInfo} object associated with the
+     * Wi-Fi network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_NETWORK_INFO = "networkInfo";
+    /**
+     * The lookup key for a String giving the BSSID of the access point to which
+     * we are connected. Only present when the new state is CONNECTED.
+     * Retrieve with
+     * {@link android.content.Intent#getStringExtra(String)}.
+     */
+    public static final String EXTRA_BSSID = "bssid";
+    /**
+     * The lookup key for a {@link android.net.wifi.WifiInfo} object giving the
+     * information about the access point to which we are connected. Only present
+     * when the new state is CONNECTED.  Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_WIFI_INFO = "wifiInfo";
+    /**
+     * Broadcast intent action indicating that the state of establishing a connection to
+     * an access point has changed.One extra provides the new
+     * {@link SupplicantState}. Note that the supplicant state is Wi-Fi specific, and
+     * is not generally the most useful thing to look at if you are just interested in
+     * the overall state of connectivity.
+     * @see #EXTRA_NEW_STATE
+     * @see #EXTRA_SUPPLICANT_ERROR
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String SUPPLICANT_STATE_CHANGED_ACTION =
+        "android.net.wifi.supplicant.STATE_CHANGE";
+    /**
+     * The lookup key for a {@link SupplicantState} describing the new state
+     * Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     */
+    public static final String EXTRA_NEW_STATE = "newState";
+
+    /**
+     * The lookup key for a {@link SupplicantState} describing the supplicant
+     * error code if any
+     * Retrieve with
+     * {@link android.content.Intent#getIntExtra(String, int)}.
+     * @see #ERROR_AUTHENTICATING
+     */
+    public static final String EXTRA_SUPPLICANT_ERROR = "supplicantError";
+
+    /**
+     * Broadcast intent action indicating that the configured networks changed.
+     * This can be as a result of adding/updating/deleting a network. If
+     * {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is set to true the new configuration
+     * can be retreived with the {@link #EXTRA_WIFI_CONFIGURATION} extra. If multiple
+     * Wi-Fi configurations changed, {@link #EXTRA_WIFI_CONFIGURATION} will not be present.
+     * @hide
+     */
+    @SystemApi
+    public static final String CONFIGURED_NETWORKS_CHANGED_ACTION =
+        "android.net.wifi.CONFIGURED_NETWORKS_CHANGE";
+    /**
+     * The lookup key for a (@link android.net.wifi.WifiConfiguration} object representing
+     * the changed Wi-Fi configuration when the {@link #CONFIGURED_NETWORKS_CHANGED_ACTION}
+     * broadcast is sent.
+     * @hide
+     */
+    @SystemApi
+    public static final String EXTRA_WIFI_CONFIGURATION = "wifiConfiguration";
+    /**
+     * Multiple network configurations have changed.
+     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
+     *
+     * @hide
+     */
+    @SystemApi
+    public static final String EXTRA_MULTIPLE_NETWORKS_CHANGED = "multipleChanges";
+    /**
+     * The lookup key for an integer indicating the reason a Wi-Fi network configuration
+     * has changed. Only present if {@link #EXTRA_MULTIPLE_NETWORKS_CHANGED} is {@code false}
+     * @see #CONFIGURED_NETWORKS_CHANGED_ACTION
+     * @hide
+     */
+    @SystemApi
+    public static final String EXTRA_CHANGE_REASON = "changeReason";
+    /**
+     * The configuration is new and was added.
+     * @hide
+     */
+    @SystemApi
+    public static final int CHANGE_REASON_ADDED = 0;
+    /**
+     * The configuration was removed and is no longer present in the system's list of
+     * configured networks.
+     * @hide
+     */
+    @SystemApi
+    public static final int CHANGE_REASON_REMOVED = 1;
+    /**
+     * The configuration has changed as a result of explicit action or because the system
+     * took an automated action such as disabling a malfunctioning configuration.
+     * @hide
+     */
+    @SystemApi
+    public static final int CHANGE_REASON_CONFIG_CHANGE = 2;
+    /**
+     * An access point scan has completed, and results are available from the supplicant.
+     * Call {@link #getScanResults()} to obtain the results.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String SCAN_RESULTS_AVAILABLE_ACTION = "android.net.wifi.SCAN_RESULTS";
+    /**
+     * A batch of access point scans has been completed and the results areavailable.
+     * Call {@link #getBatchedScanResults()} to obtain the results.
+     * @hide pending review
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String BATCHED_SCAN_RESULTS_AVAILABLE_ACTION =
+            "android.net.wifi.BATCHED_RESULTS";
+    /**
+     * The RSSI (signal strength) has changed.
+     * @see #EXTRA_NEW_RSSI
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String RSSI_CHANGED_ACTION = "android.net.wifi.RSSI_CHANGED";
+    /**
+     * The lookup key for an {@code int} giving the new RSSI in dBm.
+     */
+    public static final String EXTRA_NEW_RSSI = "newRssi";
+
+    /**
+     * Broadcast intent action indicating that the link configuration
+     * changed on wifi.
+     * @hide
+     */
+    public static final String LINK_CONFIGURATION_CHANGED_ACTION =
+        "android.net.wifi.LINK_CONFIGURATION_CHANGED";
+
+    /**
+     * The lookup key for a {@link android.net.LinkProperties} object associated with the
+     * Wi-Fi network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     * @hide
+     */
+    public static final String EXTRA_LINK_PROPERTIES = "linkProperties";
+
+    /**
+     * The lookup key for a {@link android.net.NetworkCapabilities} object associated with the
+     * Wi-Fi network. Retrieve with
+     * {@link android.content.Intent#getParcelableExtra(String)}.
+     * @hide
+     */
+    public static final String EXTRA_NETWORK_CAPABILITIES = "networkCapabilities";
+
+    /**
+     * The network IDs of the configured networks could have changed.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String NETWORK_IDS_CHANGED_ACTION = "android.net.wifi.NETWORK_IDS_CHANGED";
+
+    /**
+     * Activity Action: Show a system activity that allows the user to enable
+     * scans to be available even with Wi-Fi turned off.
+     *
+     * <p>Notification of the result of this activity is posted using the
+     * {@link android.app.Activity#onActivityResult} callback. The
+     * <code>resultCode</code>
+     * will be {@link android.app.Activity#RESULT_OK} if scan always mode has
+     * been turned on or {@link android.app.Activity#RESULT_CANCELED} if the user
+     * has rejected the request or an error has occurred.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE =
+            "android.net.wifi.action.REQUEST_SCAN_ALWAYS_AVAILABLE";
+
+    /**
+     * Activity Action: Pick a Wi-Fi network to connect to.
+     * <p>Input: Nothing.
+     * <p>Output: Nothing.
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    public static final String ACTION_PICK_WIFI_NETWORK = "android.net.wifi.PICK_WIFI_NETWORK";
+
+    /**
+     * In this Wi-Fi lock mode, Wi-Fi will be kept active,
+     * and will behave normally, i.e., it will attempt to automatically
+     * establish a connection to a remembered access point that is
+     * within range, and will do periodic scans if there are remembered
+     * access points but none are in range.
+     */
+    public static final int WIFI_MODE_FULL = 1;
+    /**
+     * In this Wi-Fi lock mode, Wi-Fi will be kept active,
+     * but the only operation that will be supported is initiation of
+     * scans, and the subsequent reporting of scan results. No attempts
+     * will be made to automatically connect to remembered access points,
+     * nor will periodic scans be automatically performed looking for
+     * remembered access points. Scans must be explicitly requested by
+     * an application in this mode.
+     */
+    public static final int WIFI_MODE_SCAN_ONLY = 2;
+    /**
+     * In this Wi-Fi lock mode, Wi-Fi will be kept active as in mode
+     * {@link #WIFI_MODE_FULL} but it operates at high performance
+     * with minimum packet loss and low packet latency even when
+     * the device screen is off. This mode will consume more power
+     * and hence should be used only when there is a need for such
+     * an active connection.
+     * <p>
+     * An example use case is when a voice connection needs to be
+     * kept active even after the device screen goes off. Holding the
+     * regular {@link #WIFI_MODE_FULL} lock will keep the wifi
+     * connection active, but the connection can be lossy.
+     * Holding a {@link #WIFI_MODE_FULL_HIGH_PERF} lock for the
+     * duration of the voice call will improve the call quality.
+     * <p>
+     * When there is no support from the hardware, this lock mode
+     * will have the same behavior as {@link #WIFI_MODE_FULL}
+     */
+    public static final int WIFI_MODE_FULL_HIGH_PERF = 3;
+
+    /** Anything worse than or equal to this will show 0 bars. */
+    private static final int MIN_RSSI = -100;
+
+    /** Anything better than or equal to this will show the max bars. */
+    private static final int MAX_RSSI = -55;
+
+    /**
+     * Number of RSSI levels used in the framework to initiate
+     * {@link #RSSI_CHANGED_ACTION} broadcast
+     * @hide
+     */
+    public static final int RSSI_LEVELS = 5;
+
+    /**
+     * Auto settings in the driver. The driver could choose to operate on both
+     * 2.4 GHz and 5 GHz or make a dynamic decision on selecting the band.
+     * @hide
+     */
+    public static final int WIFI_FREQUENCY_BAND_AUTO = 0;
+
+    /**
+     * Operation on 5 GHz alone
+     * @hide
+     */
+    public static final int WIFI_FREQUENCY_BAND_5GHZ = 1;
+
+    /**
+     * Operation on 2.4 GHz alone
+     * @hide
+     */
+    public static final int WIFI_FREQUENCY_BAND_2GHZ = 2;
+
+    /** List of asyncronous notifications
+     * @hide
+     */
+    public static final int DATA_ACTIVITY_NOTIFICATION = 1;
+
+    //Lowest bit indicates data reception and the second lowest
+    //bit indicates data transmitted
+    /** @hide */
+    public static final int DATA_ACTIVITY_NONE         = 0x00;
+    /** @hide */
+    public static final int DATA_ACTIVITY_IN           = 0x01;
+    /** @hide */
+    public static final int DATA_ACTIVITY_OUT          = 0x02;
+    /** @hide */
+    public static final int DATA_ACTIVITY_INOUT        = 0x03;
+
+    /** @hide */
+    public static final boolean DEFAULT_POOR_NETWORK_AVOIDANCE_ENABLED = false;
+
+    /* Maximum number of active locks we allow.
+     * This limit was added to prevent apps from creating a ridiculous number
+     * of locks and crashing the system by overflowing the global ref table.
+     */
+    private static final int MAX_ACTIVE_LOCKS = 50;
+
+    /* Number of currently active WifiLocks and MulticastLocks */
+    private int mActiveLockCount;
+
+    private Context mContext;
+    IWifiManager mService;
+
+    private static final int INVALID_KEY = 0;
+    private static int sListenerKey = 1;
+    private static final SparseArray sListenerMap = new SparseArray();
+    private static final Object sListenerMapLock = new Object();
+
+    private static AsyncChannel sAsyncChannel;
+    private static CountDownLatch sConnected;
+
+    private static final Object sThreadRefLock = new Object();
+    private static int sThreadRefCount;
+    private static HandlerThread sHandlerThread;
+    private final AppOpsManager mAppOps;
+
+    /**
+     * Create a new WifiManager instance.
+     * Applications will almost always want to use
+     * {@link android.content.Context#getSystemService Context.getSystemService()} to retrieve
+     * the standard {@link android.content.Context#WIFI_SERVICE Context.WIFI_SERVICE}.
+     * @param context the application context
+     * @param service the Binder interface
+     * @hide - hide this because it takes in a parameter of type IWifiManager, which
+     * is a system private class.
+     */
+    public WifiManagerWAP(Context context, IWifiManager service) {
+        mContext = context;
+        mService = service;
+        init();
+        mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
+    }
+
+    /**
+     * Return a list of all the networks configured in the supplicant.
+     * Not all fields of WifiConfiguration are returned. Only the following
+     * fields are filled in:
+     * <ul>
+     * <li>networkId</li>
+     * <li>SSID</li>
+     * <li>BSSID</li>
+     * <li>priority</li>
+     * <li>allowedProtocols</li>
+     * <li>allowedKeyManagement</li>
+     * <li>allowedAuthAlgorithms</li>
+     * <li>allowedPairwiseCiphers</li>
+     * <li>allowedGroupCiphers</li>
+     * </ul>
+     * @return a list of network configurations in the form of a list
+     * of {@link WifiConfiguration} objects. Upon failure to fetch or
+     * when when Wi-Fi is turned off, it can be null.
+     */
+    public List<WifiConfiguration> getConfiguredNetworks() {
+        try {
+            return mService.getConfiguredNetworks();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** @hide */
+    @SystemApi
+    public List<WifiConfiguration> getPrivilegedConfiguredNetworks() {
+        try {
+            return mService.getPrivilegedConfiguredNetworks();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** @hide */
+    @SystemApi
+    public WifiConnectionStatistics getConnectionStatistics() {
+        try {
+            return mService.getConnectionStatistics();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Add a new network description to the set of configured networks.
+     * The {@code networkId} field of the supplied configuration object
+     * is ignored.
+     * <p/>
+     * The new network will be marked DISABLED by default. To enable it,
+     * called {@link #enableNetwork}.
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link WifiConfiguration} object.
+     * @return the ID of the newly created network description. This is used in
+     *         other operations to specified the network to be acted upon.
+     *         Returns {@code -1} on failure.
+     */
+    public int addNetwork(WifiConfiguration config) {
+        if (config == null) {
+            return -1;
+        }
+        config.networkId = -1;
+        return addOrUpdateNetwork(config);
+    }
+
+    /**
+     * Update the network description of an existing configured network.
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link WifiConfiguration} object. It may
+     *            be sparse, so that only the items that are being changed
+     *            are non-<code>null</code>. The {@code networkId} field
+     *            must be set to the ID of the existing network being updated.
+     * @return Returns the {@code networkId} of the supplied
+     *         {@code WifiConfiguration} on success.
+     *         <br/>
+     *         Returns {@code -1} on failure, including when the {@code networkId}
+     *         field of the {@code WifiConfiguration} does not refer to an
+     *         existing network.
+     */
+    public int updateNetwork(WifiConfiguration config) {
+        if (config == null || config.networkId < 0) {
+            return -1;
+        }
+        return addOrUpdateNetwork(config);
+    }
+
+    /**
+     * Internal method for doing the RPC that creates a new network description
+     * or updates an existing one.
+     *
+     * @param config The possibly sparse object containing the variables that
+     *         are to set or updated in the network description.
+     * @return the ID of the network on success, {@code -1} on failure.
+     */
+    private int addOrUpdateNetwork(WifiConfiguration config) {
+        try {
+            return mService.addOrUpdateNetwork(config);
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Remove the specified network from the list of configured networks.
+     * This may result in the asynchronous delivery of state change
+     * events.
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean removeNetwork(int netId) {
+        try {
+            return mService.removeNetwork(netId);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Allow a previously configured network to be associated with. If
+     * <code>disableOthers</code> is true, then all other configured
+     * networks are disabled, and an attempt to connect to the selected
+     * network is initiated. This may result in the asynchronous delivery
+     * of state change events.
+     * @param netId the ID of the network in the list of configured networks
+     * @param disableOthers if true, disable all other networks. The way to
+     * select a particular network to connect to is specify {@code true}
+     * for this parameter.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean enableNetwork(int netId, boolean disableOthers) {
+        try {
+            return mService.enableNetwork(netId, disableOthers);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disable a configured network. The specified network will not be
+     * a candidate for associating. This may result in the asynchronous
+     * delivery of state change events.
+     * @param netId the ID of the network as returned by {@link #addNetwork}.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disableNetwork(int netId) {
+        try {
+            return mService.disableNetwork(netId);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disassociate from the currently active access point. This may result
+     * in the asynchronous delivery of state change events.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disconnect() {
+        try {
+            mService.disconnect();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Reconnect to the currently active access point, if we are currently
+     * disconnected. This may result in the asynchronous delivery of state
+     * change events.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean reconnect() {
+        try {
+            mService.reconnect();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Reconnect to the currently active access point, even if we are already
+     * connected. This may result in the asynchronous delivery of state
+     * change events.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean reassociate() {
+        try {
+            mService.reassociate();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Check that the supplicant daemon is responding to requests.
+     * @return {@code true} if we were able to communicate with the supplicant and
+     * it returned the expected response to the PING message.
+     */
+    public boolean pingSupplicant() {
+        if (mService == null)
+            return false;
+        try {
+            return mService.pingSupplicant();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Get a list of available channels for customized scan.
+     *
+     * @see {@link WifiChannel}
+     *
+     * @return the channel list, or null if not available
+     * @hide
+     */
+    public List<WifiChannel> getChannelList() {
+        try {
+            return mService.getChannelList();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /* Keep this list in sync with wifi_hal.h */
+    /** @hide */
+    public static final int WIFI_FEATURE_INFRA            = 0x0001;  // Basic infrastructure mode
+    /** @hide */
+    public static final int WIFI_FEATURE_INFRA_5G         = 0x0002;  // Support for 5 GHz Band
+    /** @hide */
+    public static final int WIFI_FEATURE_PASSPOINT        = 0x0004;  // Support for GAS/ANQP
+    /** @hide */
+    public static final int WIFI_FEATURE_P2P              = 0x0008;  // Wifi-Direct
+    /** @hide */
+    public static final int WIFI_FEATURE_MOBILE_HOTSPOT   = 0x0010;  // Soft AP
+    /** @hide */
+    public static final int WIFI_FEATURE_SCANNER          = 0x0020;  // WifiScanner APIs
+    /** @hide */
+    public static final int WIFI_FEATURE_NAN              = 0x0040;  // Neighbor Awareness Networking
+    /** @hide */
+    public static final int WIFI_FEATURE_D2D_RTT          = 0x0080;  // Device-to-device RTT
+    /** @hide */
+    public static final int WIFI_FEATURE_D2AP_RTT         = 0x0100;  // Device-to-AP RTT
+    /** @hide */
+    public static final int WIFI_FEATURE_BATCH_SCAN       = 0x0200;  // Batched Scan (deprecated)
+    /** @hide */
+    public static final int WIFI_FEATURE_PNO              = 0x0400;  // Preferred network offload
+    /** @hide */
+    public static final int WIFI_FEATURE_ADDITIONAL_STA   = 0x0800;  // Support for two STAs
+    /** @hide */
+    public static final int WIFI_FEATURE_TDLS             = 0x1000;  // Tunnel directed link setup
+    /** @hide */
+    public static final int WIFI_FEATURE_TDLS_OFFCHANNEL  = 0x2000;  // Support for TDLS off channel
+    /** @hide */
+    public static final int WIFI_FEATURE_EPR              = 0x4000;  // Enhanced power reporting
+
+    private int getSupportedFeatures() {
+        try {
+            return mService.getSupportedFeatures();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    private boolean isFeatureSupported(int feature) {
+        return (getSupportedFeatures() & feature) == feature;
+    }
+    /**
+     * @return true if this adapter supports 5 GHz band
+     */
+    public boolean is5GHzBandSupported() {
+        return isFeatureSupported(WIFI_FEATURE_INFRA_5G);
+    }
+
+    /**
+     * @return true if this adapter supports passpoint
+     * @hide
+     */
+    public boolean isPasspointSupported() {
+        return isFeatureSupported(WIFI_FEATURE_PASSPOINT);
+    }
+
+    /**
+     * @return true if this adapter supports WifiP2pManager (Wi-Fi Direct)
+     */
+    public boolean isP2pSupported() {
+        return isFeatureSupported(WIFI_FEATURE_P2P);
+    }
+
+    /**
+     * @return true if this adapter supports portable Wi-Fi hotspot
+     * @hide
+     */
+    @SystemApi
+    public boolean isPortableHotspotSupported() {
+        return isFeatureSupported(WIFI_FEATURE_MOBILE_HOTSPOT);
+    }
+
+    /**
+     * @return true if this adapter supports WifiScanner APIs
+     * @hide
+     */
+    @SystemApi
+    public boolean isWifiScannerSupported() {
+        return isFeatureSupported(WIFI_FEATURE_SCANNER);
+    }
+
+    /**
+     * @return true if this adapter supports Neighbour Awareness Network APIs
+     * @hide
+     */
+    public boolean isNanSupported() {
+        return isFeatureSupported(WIFI_FEATURE_NAN);
+    }
+
+    /**
+     * @return true if this adapter supports Device-to-device RTT
+     * @hide
+     */
+    @SystemApi
+    public boolean isDeviceToDeviceRttSupported() {
+        return isFeatureSupported(WIFI_FEATURE_D2D_RTT);
+    }
+
+    /**
+     * @return true if this adapter supports Device-to-AP RTT
+     */
+    @SystemApi
+    public boolean isDeviceToApRttSupported() {
+        return isFeatureSupported(WIFI_FEATURE_D2AP_RTT);
+    }
+
+    /**
+     * @return true if this adapter supports offloaded connectivity scan
+     */
+    public boolean isPreferredNetworkOffloadSupported() {
+        return isFeatureSupported(WIFI_FEATURE_PNO);
+    }
+
+    /**
+     * @return true if this adapter supports multiple simultaneous connections
+     * @hide
+     */
+    public boolean isAdditionalStaSupported() {
+        return isFeatureSupported(WIFI_FEATURE_ADDITIONAL_STA);
+    }
+
+    /**
+     * @return true if this adapter supports Tunnel Directed Link Setup
+     */
+    public boolean isTdlsSupported() {
+        return isFeatureSupported(WIFI_FEATURE_TDLS);
+    }
+
+    /**
+     * @return true if this adapter supports Off Channel Tunnel Directed Link Setup
+     * @hide
+     */
+    public boolean isOffChannelTdlsSupported() {
+        return isFeatureSupported(WIFI_FEATURE_TDLS_OFFCHANNEL);
+    }
+
+    /**
+     * @return true if this adapter supports advanced power/performance counters
+     */
+    public boolean isEnhancedPowerReportingSupported() {
+        return isFeatureSupported(WIFI_FEATURE_EPR);
+    }
+
+    /**
+     * Return the record of {@link WifiActivityEnergyInfo} object that
+     * has the activity and energy info. This can be used to ascertain what
+     * the controller has been up to, since the last sample.
+     * @param updateType Type of info, cached vs refreshed.
+     *
+     * @return a record with {@link WifiActivityEnergyInfo} or null if
+     * report is unavailable or unsupported
+     * @hide
+     */
+    public WifiActivityEnergyInfo getControllerActivityEnergyInfo(int updateType) {
+        if (mService == null) return null;
+        try {
+            WifiActivityEnergyInfo record;
+            if (!isEnhancedPowerReportingSupported()) {
+                return null;
+            }
+            synchronized(this) {
+                record = mService.reportActivityInfo();
+                if (record.isValid()) {
+                    return record;
+                } else {
+                    return null;
+                }
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "getControllerActivityEnergyInfo: " + e);
+        }
+        return null;
+    }
+
+    /**
+     * Request a scan for access points. Returns immediately. The availability
+     * of the results is made known later by means of an asynchronous event sent
+     * on completion of the scan.
+     * @return {@code true} if the operation succeeded, i.e., the scan was initiated
+     */
+    public boolean startScan() {
+        try {
+            mService.startScan(null, null);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /** @hide */
+    @SystemApi
+    public boolean startScan(WorkSource workSource) {
+        try {
+            mService.startScan(null, workSource);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Request a scan for access points in specified channel list. Each channel is specified by its
+     * frequency in MHz, e.g. "5500" (do NOT include "DFS" even though it is). The availability of
+     * the results is made known later in the same way as {@link #startScan}.
+     *
+     * Note:
+     *
+     * 1. Customized scan is for non-connection purposes, i.e. it won't trigger a wifi connection
+     *    even though it finds some known networks.
+     *
+     * 2. Customized scan result may include access points that is not specified in the channel
+     *    list. An app will need to do frequency filtering if it wants to get pure results for the
+     *    channel list it specified.
+     *
+     * @hide
+     */
+    public boolean startCustomizedScan(ScanSettings requested) {
+        try {
+            mService.startScan(requested, null);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /** @hide */
+    public boolean startCustomizedScan(ScanSettings requested, WorkSource workSource) {
+        try {
+            mService.startScan(requested, workSource);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Request a batched scan for access points.  To end your requested batched scan,
+     * call stopBatchedScan with the same Settings.
+     *
+     * If there are mulitple requests for batched scans, the more demanding settings will
+     * take precidence.
+     *
+     * @param requested {@link BatchedScanSettings} the scan settings requested.
+     * @return false on known error
+     * @hide
+     */
+    public boolean requestBatchedScan(BatchedScanSettings requested) {
+        try {
+            return mService.requestBatchedScan(requested, new Binder(), null);
+        } catch (RemoteException e) { return false; }
+    }
+    /** @hide */
+    public boolean requestBatchedScan(BatchedScanSettings requested, WorkSource workSource) {
+        try {
+            return mService.requestBatchedScan(requested, new Binder(), workSource);
+        } catch (RemoteException e) { return false; }
+    }
+
+    /**
+     * Check if the Batched Scan feature is supported.
+     *
+     * @return false if not supported.
+     * @hide
+     */
+    @SystemApi
+    public boolean isBatchedScanSupported() {
+        try {
+            return mService.isBatchedScanSupported();
+        } catch (RemoteException e) { return false; }
+    }
+
+    /**
+     * End a requested batch scan for this applicaiton.  Note that batched scan may
+     * still occur if other apps are using them.
+     *
+     * @param requested {@link BatchedScanSettings} the scan settings you previously requested
+     *        and now wish to stop.  A value of null here will stop all scans requested by the
+     *        calling App.
+     * @hide
+     */
+    public void stopBatchedScan(BatchedScanSettings requested) {
+        try {
+            mService.stopBatchedScan(requested);
+        } catch (RemoteException e) {}
+    }
+
+    /**
+     * Retrieve the latest batched scan result.  This should be called immediately after
+     * {@link BATCHED_SCAN_RESULTS_AVAILABLE_ACTION} is received.
+     * @hide
+     */
+    @SystemApi
+    public List<BatchedScanResult> getBatchedScanResults() {
+        try {
+            return mService.getBatchedScanResults(mContext.getOpPackageName());
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Force a re-reading of batched scan results.  This will attempt
+     * to read more information from the chip, but will do so at the expense
+     * of previous data.  Rate limited to the current scan frequency.
+     *
+     * pollBatchedScan will always wait 1 period from the start of the batch
+     * before trying to read from the chip, so if your #scans/batch == 1 this will
+     * have no effect.
+     *
+     * If you had already waited 1 period before calling, this should have
+     * immediate (though async) effect.
+     *
+     * If you call before that 1 period is up this will set up a timer and fetch
+     * results when the 1 period is up.
+     *
+     * Servicing a pollBatchedScan request (immediate or after timed delay) starts a
+     * new batch, so if you were doing 10 scans/batch and called in the 4th scan, you
+     * would get data in the 4th and then again 10 scans later.
+     * @hide
+     */
+    public void pollBatchedScan() {
+        try {
+            mService.pollBatchedScan();
+        } catch (RemoteException e) { }
+    }
+
+    /**
+     * Creates a configuration token describing the network referenced by {@code netId}
+     * of MIME type application/vnd.wfa.wsc. Can be used to configure WiFi networks via NFC.
+     *
+     * @return hex-string encoded configuration token
+     * @hide
+     */
+    public String getWpsNfcConfigurationToken(int netId) {
+        try {
+            return mService.getWpsNfcConfigurationToken(netId);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Return dynamic information about the current Wi-Fi connection, if any is active.
+     * @return the Wi-Fi information, contained in {@link WifiInfo}.
+     */
+    public WifiInfo getConnectionInfo() {
+        try {
+            return mService.getConnectionInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Return the results of the latest access point scan.
+     * @return the list of access points found in the most recent scan.
+     */
+    public List<ScanResult> getScanResults() {
+        try {
+            return mService.getScanResults(mContext.getOpPackageName());
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Check if scanning is always available.
+     *
+     * If this return {@code true}, apps can issue {@link #startScan} and fetch scan results
+     * even when Wi-Fi is turned off.
+     *
+     * To change this setting, see {@link #ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE}.
+     */
+    public boolean isScanAlwaysAvailable() {
+        try {
+            return mService.isScanAlwaysAvailable();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Tell the supplicant to persist the current list of configured networks.
+     * <p>
+     * Note: It is possible for this method to change the network IDs of
+     * existing networks. You should assume the network IDs can be different
+     * after calling this method.
+     *
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean saveConfiguration() {
+        try {
+            return mService.saveConfiguration();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Set the country code.
+     * @param countryCode country code in ISO 3166 format.
+     * @param persist {@code true} if this needs to be remembered
+     *
+     * @hide
+     */
+    public void setCountryCode(String country, boolean persist) {
+        try {
+            mService.setCountryCode(country, persist);
+        } catch (RemoteException e) { }
+    }
+
+    /**
+     * Set the operational frequency band.
+     * @param band  One of
+     *     {@link #WIFI_FREQUENCY_BAND_AUTO},
+     *     {@link #WIFI_FREQUENCY_BAND_5GHZ},
+     *     {@link #WIFI_FREQUENCY_BAND_2GHZ},
+     * @param persist {@code true} if this needs to be remembered
+     * @hide
+     */
+    public void setFrequencyBand(int band, boolean persist) {
+        try {
+            mService.setFrequencyBand(band, persist);
+        } catch (RemoteException e) { }
+    }
+
+    /**
+     * Get the operational frequency band.
+     * @return One of
+     *     {@link #WIFI_FREQUENCY_BAND_AUTO},
+     *     {@link #WIFI_FREQUENCY_BAND_5GHZ},
+     *     {@link #WIFI_FREQUENCY_BAND_2GHZ} or
+     *     {@code -1} on failure.
+     * @hide
+     */
+    public int getFrequencyBand() {
+        try {
+            return mService.getFrequencyBand();
+        } catch (RemoteException e) {
+            return -1;
+        }
+    }
+
+    /**
+     * Check if the chipset supports dual frequency band (2.4 GHz and 5 GHz)
+     * @return {@code true} if supported, {@code false} otherwise.
+     * @hide
+     */
+    public boolean isDualBandSupported() {
+        try {
+            return mService.isDualBandSupported();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Return the DHCP-assigned addresses from the last successful DHCP request,
+     * if any.
+     * @return the DHCP information
+     */
+    public DhcpInfo getDhcpInfo() {
+        try {
+            return mService.getDhcpInfo();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Enable or disable Wi-Fi.
+     * @param enabled {@code true} to enable, {@code false} to disable.
+     * @return {@code true} if the operation succeeds (or if the existing state
+     *         is the same as the requested state).
+     */
+    public boolean setWifiEnabled(boolean enabled) {
+        if (mAppOps.noteOp(AppOpsManager.OP_WIFI_CHANGE) !=
+                AppOpsManager.MODE_ALLOWED)
+            return false;
+        try {
+            return mService.setWifiEnabled(enabled);
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the Wi-Fi enabled state.
+     * @return One of {@link #WIFI_STATE_DISABLED},
+     *         {@link #WIFI_STATE_DISABLING}, {@link #WIFI_STATE_ENABLED},
+     *         {@link #WIFI_STATE_ENABLING}, {@link #WIFI_STATE_UNKNOWN}
+     * @see #isWifiEnabled()
+     */
+    public int getWifiState() {
+        try {
+            return mService.getWifiEnabledState();
+        } catch (RemoteException e) {
+            return WIFI_STATE_UNKNOWN;
+        }
+    }
+
+    /**
+     * Return whether Wi-Fi is enabled or disabled.
+     * @return {@code true} if Wi-Fi is enabled
+     * @see #getWifiState()
+     */
+    public boolean isWifiEnabled() {
+        return getWifiState() == WIFI_STATE_ENABLED;
+    }
+
+    /**
+     * Return TX packet counter, for CTS test of WiFi watchdog.
+     * @param listener is the interface to receive result
+     *
+     * @hide for CTS test only
+     */
+    public void getTxPacketCount(TxPacketCountListener listener) {
+        validateChannel();
+        sAsyncChannel.sendMessage(RSSI_PKTCNT_FETCH, 0, putListener(listener));
+    }
+
+    /**
+     * Calculates the level of the signal. This should be used any time a signal
+     * is being shown.
+     *
+     * @param rssi The power of the signal measured in RSSI.
+     * @param numLevels The number of levels to consider in the calculated
+     *            level.
+     * @return A level of the signal, given in the range of 0 to numLevels-1
+     *         (both inclusive).
+     */
+    public static int calculateSignalLevel(int rssi, int numLevels) {
+        if (rssi <= MIN_RSSI) {
+            return 0;
+        } else if (rssi >= MAX_RSSI) {
+            return numLevels - 1;
+        } else {
+            float inputRange = (MAX_RSSI - MIN_RSSI);
+            float outputRange = (numLevels - 1);
+            return (int)((float)(rssi - MIN_RSSI) * outputRange / inputRange);
+        }
+    }
+
+    /**
+     * Compares two signal strengths.
+     *
+     * @param rssiA The power of the first signal measured in RSSI.
+     * @param rssiB The power of the second signal measured in RSSI.
+     * @return Returns <0 if the first signal is weaker than the second signal,
+     *         0 if the two signals have the same strength, and >0 if the first
+     *         signal is stronger than the second signal.
+     */
+    public static int compareSignalLevel(int rssiA, int rssiB) {
+        return rssiA - rssiB;
+    }
+
+    /**
+     * Start AccessPoint mode with the specified
+     * configuration. If the radio is already running in
+     * AP mode, update the new configuration
+     * Note that starting in access point mode disables station
+     * mode operation
+     * @param wifiConfig SSID, security and channel details as
+     *        part of WifiConfiguration
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     *
+     * @hide Dont open up yet
+     */
+    public boolean setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) {
+        try {
+            mService.setWifiApEnabled(wifiConfig, enabled);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the Wi-Fi enabled state.
+     * @return One of {@link #WIFI_AP_STATE_DISABLED},
+     *         {@link #WIFI_AP_STATE_DISABLING}, {@link #WIFI_AP_STATE_ENABLED},
+     *         {@link #WIFI_AP_STATE_ENABLING}, {@link #WIFI_AP_STATE_FAILED}
+     * @see #isWifiApEnabled()
+     *
+     * @hide Dont open yet
+     */
+    public int getWifiApState() {
+        try {
+            return mService.getWifiApEnabledState();
+        } catch (RemoteException e) {
+            return WIFI_AP_STATE_FAILED;
+        }
+    }
+
+    /**
+     * Return whether Wi-Fi AP is enabled or disabled.
+     * @return {@code true} if Wi-Fi AP is enabled
+     * @see #getWifiApState()
+     *
+     * @hide Dont open yet
+     */
+    public boolean isWifiApEnabled() {
+        return getWifiApState() == WIFI_AP_STATE_ENABLED;
+    }
+
+    /**
+     * Gets the Wi-Fi AP Configuration.
+     * @return AP details in WifiConfiguration
+     *
+     * @hide Dont open yet
+     */
+    public WifiConfiguration getWifiApConfiguration() {
+        try {
+            return mService.getWifiApConfiguration();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Sets the Wi-Fi AP Configuration.
+     * @return {@code true} if the operation succeeded, {@code false} otherwise
+     *
+     * @hide Dont open yet
+     */
+    public boolean setWifiApConfiguration(WifiConfiguration wifiConfig) {
+        try {
+            mService.setWifiApConfiguration(wifiConfig);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+   /**
+     * Start the driver and connect to network.
+     *
+     * This function will over-ride WifiLock and device idle status. For example,
+     * even if the device is idle or there is only a scan-only lock held,
+     * a start wifi would mean that wifi connection is kept active until
+     * a stopWifi() is sent.
+     *
+     * This API is used by WifiStateTracker
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean startWifi() {
+        try {
+            mService.startWifi();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Disconnect from a network (if any) and stop the driver.
+     *
+     * This function will over-ride WifiLock and device idle status. Wi-Fi
+     * stays inactive until a startWifi() is issued.
+     *
+     * This API is used by WifiStateTracker
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean stopWifi() {
+        try {
+            mService.stopWifi();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Add a bssid to the supplicant blacklist
+     *
+     * This API is used by WifiWatchdogService
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean addToBlacklist(String bssid) {
+        try {
+            mService.addToBlacklist(bssid);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Clear the supplicant blacklist
+     *
+     * This API is used by WifiWatchdogService
+     *
+     * @return {@code true} if the operation succeeds else {@code false}
+     * @hide
+     */
+    public boolean clearBlacklist() {
+        try {
+            mService.clearBlacklist();
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+
+    /**
+     * Enable/Disable TDLS on a specific local route.
+     *
+     * <p>
+     * TDLS enables two wireless endpoints to talk to each other directly
+     * without going through the access point that is managing the local
+     * network. It saves bandwidth and improves quality of the link.
+     * </p>
+     * <p>
+     * This API enables/disables the option of using TDLS. If enabled, the
+     * underlying hardware is free to use TDLS or a hop through the access
+     * point. If disabled, existing TDLS session is torn down and
+     * hardware is restricted to use access point for transferring wireless
+     * packets. Default value for all routes is 'disabled', meaning restricted
+     * to use access point for transferring packets.
+     * </p>
+     *
+     * @param remoteIPAddress IP address of the endpoint to setup TDLS with
+     * @param enable true = setup and false = tear down TDLS
+     */
+    public void setTdlsEnabled(InetAddress remoteIPAddress, boolean enable) {
+        try {
+            mService.enableTdls(remoteIPAddress.getHostAddress(), enable);
+        } catch (RemoteException e) {
+            // Just ignore the exception
+        }
+    }
+
+    /**
+     * Similar to {@link #setTdlsEnabled(InetAddress, boolean) }, except
+     * this version allows you to specify remote endpoint with a MAC address.
+     * @param remoteMacAddress MAC address of the remote endpoint such as 00:00:0c:9f:f2:ab
+     * @param enable true = setup and false = tear down TDLS
+     */
+    public void setTdlsEnabledWithMacAddress(String remoteMacAddress, boolean enable) {
+        try {
+            mService.enableTdlsWithMacAddress(remoteMacAddress, enable);
+        } catch (RemoteException e) {
+            // Just ignore the exception
+        }
+    }
+
+    /* TODO: deprecate synchronous API and open up the following API */
+
+    private static final int BASE = Protocol.BASE_WIFI_MANAGER;
+
+    /* Commands to WifiService */
+    /** @hide */
+    public static final int CONNECT_NETWORK                 = BASE + 1;
+    /** @hide */
+    public static final int CONNECT_NETWORK_FAILED          = BASE + 2;
+    /** @hide */
+    public static final int CONNECT_NETWORK_SUCCEEDED       = BASE + 3;
+
+    /** @hide */
+    public static final int FORGET_NETWORK                  = BASE + 4;
+    /** @hide */
+    public static final int FORGET_NETWORK_FAILED           = BASE + 5;
+    /** @hide */
+    public static final int FORGET_NETWORK_SUCCEEDED        = BASE + 6;
+
+    /** @hide */
+    public static final int SAVE_NETWORK                    = BASE + 7;
+    /** @hide */
+    public static final int SAVE_NETWORK_FAILED             = BASE + 8;
+    /** @hide */
+    public static final int SAVE_NETWORK_SUCCEEDED          = BASE + 9;
+
+    /** @hide */
+    public static final int START_WPS                       = BASE + 10;
+    /** @hide */
+    public static final int START_WPS_SUCCEEDED             = BASE + 11;
+    /** @hide */
+    public static final int WPS_FAILED                      = BASE + 12;
+    /** @hide */
+    public static final int WPS_COMPLETED                   = BASE + 13;
+
+    /** @hide */
+    public static final int CANCEL_WPS                      = BASE + 14;
+    /** @hide */
+    public static final int CANCEL_WPS_FAILED               = BASE + 15;
+    /** @hide */
+    public static final int CANCEL_WPS_SUCCEDED             = BASE + 16;
+
+    /** @hide */
+    public static final int DISABLE_NETWORK                 = BASE + 17;
+    /** @hide */
+    public static final int DISABLE_NETWORK_FAILED          = BASE + 18;
+    /** @hide */
+    public static final int DISABLE_NETWORK_SUCCEEDED       = BASE + 19;
+
+    /** @hide */
+    public static final int RSSI_PKTCNT_FETCH               = BASE + 20;
+    /** @hide */
+    public static final int RSSI_PKTCNT_FETCH_SUCCEEDED     = BASE + 21;
+    /** @hide */
+    public static final int RSSI_PKTCNT_FETCH_FAILED        = BASE + 22;
+
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed due to an internal error.
+     * @hide
+     */
+    public static final int ERROR                       = 0;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation is already in progress
+     * @hide
+     */
+    public static final int IN_PROGRESS                 = 1;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed because the framework is busy and
+     * unable to service the request
+     * @hide
+     */
+    public static final int BUSY                        = 2;
+
+    /* WPS specific errors */
+    /** WPS overlap detected */
+    public static final int WPS_OVERLAP_ERROR           = 3;
+    /** WEP on WPS is prohibited */
+    public static final int WPS_WEP_PROHIBITED          = 4;
+    /** TKIP only prohibited */
+    public static final int WPS_TKIP_ONLY_PROHIBITED    = 5;
+    /** Authentication failure on WPS */
+    public static final int WPS_AUTH_FAILURE            = 6;
+    /** WPS timed out */
+    public static final int WPS_TIMED_OUT               = 7;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed due to invalid inputs
+     * @hide
+     */
+    public static final int INVALID_ARGS                = 8;
+
+    /**
+     * Passed with {@link ActionListener#onFailure}.
+     * Indicates that the operation failed due to user permissions.
+     * @hide
+     */
+    public static final int NOT_AUTHORIZED              = 9;
+
+    /**
+     * Interface for callback invocation on an application action
+     * @hide
+     */
+    public interface ActionListener {
+        /** The operation succeeded */
+        public void onSuccess();
+        /**
+         * The operation failed
+         * @param reason The reason for failure could be one of
+         * {@link #ERROR}, {@link #IN_PROGRESS} or {@link #BUSY}
+         */
+        public void onFailure(int reason);
+    }
+
+    /** Interface for callback invocation on a start WPS action */
+    public static abstract class WpsCallback {
+        /** WPS start succeeded */
+        public abstract void onStarted(String pin);
+
+        /** WPS operation completed succesfully */
+        public abstract void onSucceeded();
+
+        /**
+         * WPS operation failed
+         * @param reason The reason for failure could be one of
+         * {@link #WPS_TKIP_ONLY_PROHIBITED}, {@link #WPS_OVERLAP_ERROR},
+         * {@link #WPS_WEP_PROHIBITED}, {@link #WPS_TIMED_OUT} or {@link #WPS_AUTH_FAILURE}
+         * and some generic errors.
+         */
+        public abstract void onFailed(int reason);
+    }
+
+    /** Interface for callback invocation on a TX packet count poll action {@hide} */
+    public interface TxPacketCountListener {
+        /**
+         * The operation succeeded
+         * @param count TX packet counter
+         */
+        public void onSuccess(int count);
+        /**
+         * The operation failed
+         * @param reason The reason for failure could be one of
+         * {@link #ERROR}, {@link #IN_PROGRESS} or {@link #BUSY}
+         */
+        public void onFailure(int reason);
+    }
+
+    private static class ServiceHandler extends Handler {
+        ServiceHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message message) {
+            Object listener = removeListener(message.arg2);
+            switch (message.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
+                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        sAsyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
+                    } else {
+                        Log.e(TAG, "Failed to set up channel connection");
+                        // This will cause all further async API calls on the WifiManager
+                        // to fail and throw an exception
+                        sAsyncChannel = null;
+                    }
+                    sConnected.countDown();
+                    break;
+                case AsyncChannel.CMD_CHANNEL_FULLY_CONNECTED:
+                    // Ignore
+                    break;
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
+                    Log.e(TAG, "Channel connection lost");
+                    // This will cause all further async API calls on the WifiManager
+                    // to fail and throw an exception
+                    sAsyncChannel = null;
+                    getLooper().quit();
+                    break;
+                    /* ActionListeners grouped together */
+                case WifiManagerWAP.CONNECT_NETWORK_FAILED:
+                case WifiManagerWAP.FORGET_NETWORK_FAILED:
+                case WifiManagerWAP.SAVE_NETWORK_FAILED:
+                case WifiManagerWAP.DISABLE_NETWORK_FAILED:
+                    if (listener != null) {
+                        ((ActionListener) listener).onFailure(message.arg1);
+                    }
+                    break;
+                    /* ActionListeners grouped together */
+                case WifiManagerWAP.CONNECT_NETWORK_SUCCEEDED:
+                case WifiManagerWAP.FORGET_NETWORK_SUCCEEDED:
+                case WifiManagerWAP.SAVE_NETWORK_SUCCEEDED:
+                case WifiManagerWAP.DISABLE_NETWORK_SUCCEEDED:
+                    if (listener != null) {
+                        ((ActionListener) listener).onSuccess();
+                    }
+                    break;
+                case WifiManagerWAP.START_WPS_SUCCEEDED:
+                    if (listener != null) {
+                        WpsResult result = (WpsResult) message.obj;
+                        ((WpsCallback) listener).onStarted(result.pin);
+                        //Listener needs to stay until completion or failure
+                        synchronized(sListenerMapLock) {
+                            sListenerMap.put(message.arg2, listener);
+                        }
+                    }
+                    break;
+                case WifiManagerWAP.WPS_COMPLETED:
+                    if (listener != null) {
+                        ((WpsCallback) listener).onSucceeded();
+                    }
+                    break;
+                case WifiManagerWAP.WPS_FAILED:
+                    if (listener != null) {
+                        ((WpsCallback) listener).onFailed(message.arg1);
+                    }
+                    break;
+                case WifiManagerWAP.CANCEL_WPS_SUCCEDED:
+                    if (listener != null) {
+                        ((WpsCallback) listener).onSucceeded();
+                    }
+                    break;
+                case WifiManagerWAP.CANCEL_WPS_FAILED:
+                    if (listener != null) {
+                        ((WpsCallback) listener).onFailed(message.arg1);
+                    }
+                    break;
+                case WifiManagerWAP.RSSI_PKTCNT_FETCH_SUCCEEDED:
+                    if (listener != null) {
+                        RssiPacketCountInfo info = (RssiPacketCountInfo) message.obj;
+                        if (info != null)
+                            ((TxPacketCountListener) listener).onSuccess(info.txgood + info.txbad);
+                        else
+                            ((TxPacketCountListener) listener).onFailure(ERROR);
+                    }
+                    break;
+                case WifiManagerWAP.RSSI_PKTCNT_FETCH_FAILED:
+                    if (listener != null) {
+                        ((TxPacketCountListener) listener).onFailure(message.arg1);
+                    }
+                    break;
+                default:
+                    //ignore
+                    break;
+            }
+        }
+    }
+
+    private static int putListener(Object listener) {
+        if (listener == null) return INVALID_KEY;
+        int key;
+        synchronized (sListenerMapLock) {
+            do {
+                key = sListenerKey++;
+            } while (key == INVALID_KEY);
+            sListenerMap.put(key, listener);
+        }
+        return key;
+    }
+
+    private static Object removeListener(int key) {
+        if (key == INVALID_KEY) return null;
+        synchronized (sListenerMapLock) {
+            Object listener = sListenerMap.get(key);
+            sListenerMap.remove(key);
+            return listener;
+        }
+    }
+
+    private void init() {
+        synchronized (sThreadRefLock) {
+            if (++sThreadRefCount == 1) {
+                Messenger messenger = getWifiServiceMessenger();
+                if (messenger == null) {
+                    sAsyncChannel = null;
+                    return;
+                }
+
+                sHandlerThread = new HandlerThread("WifiManagerWAP");
+                sAsyncChannel = new AsyncChannel();
+                sConnected = new CountDownLatch(1);
+
+                sHandlerThread.start();
+                Handler handler = new ServiceHandler(sHandlerThread.getLooper());
+                sAsyncChannel.connect(mContext, handler, messenger);
+                try {
+                    sConnected.await();
+                } catch (InterruptedException e) {
+                    Log.e(TAG, "interrupted wait at init");
+                }
+            }
+        }
+    }
+
+    private void validateChannel() {
+        if (sAsyncChannel == null) throw new IllegalStateException(
+                "No permission to access and change wifi or a bad initialization");
+    }
+
+    /**
+     * Connect to a network with the given configuration. The network also
+     * gets added to the supplicant configuration.
+     *
+     * For a new network, this function is used instead of a
+     * sequence of addNetwork(), enableNetwork(), saveConfiguration() and
+     * reconnect()
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link WifiConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     *
+     * @hide
+     */
+    public void connect(WifiConfiguration config, ActionListener listener) {
+        if (config == null) throw new IllegalArgumentException("config cannot be null");
+        validateChannel();
+        // Use INVALID_NETWORK_ID for arg1 when passing a config object
+        // arg1 is used to pass network id when the network already exists
+        sAsyncChannel.sendMessage(CONNECT_NETWORK, WifiConfiguration.INVALID_NETWORK_ID,
+                putListener(listener), config);
+    }
+
+    /**
+     * Connect to a network with the given networkId.
+     *
+     * This function is used instead of a enableNetwork(), saveConfiguration() and
+     * reconnect()
+     *
+     * @param networkId the network id identifiying the network in the
+     *                supplicant configuration list
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void connect(int networkId, ActionListener listener) {
+        if (networkId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        sAsyncChannel.sendMessage(CONNECT_NETWORK, networkId, putListener(listener));
+    }
+
+    /**
+     * Save the given network in the supplicant config. If the network already
+     * exists, the configuration is updated. A new network is enabled
+     * by default.
+     *
+     * For a new network, this function is used instead of a
+     * sequence of addNetwork(), enableNetwork() and saveConfiguration().
+     *
+     * For an existing network, it accomplishes the task of updateNetwork()
+     * and saveConfiguration()
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link WifiConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void save(WifiConfiguration config, ActionListener listener) {
+        if (config == null) throw new IllegalArgumentException("config cannot be null");
+        validateChannel();
+        sAsyncChannel.sendMessage(SAVE_NETWORK, 0, putListener(listener), config);
+    }
+
+    /**
+     * Delete the network in the supplicant config.
+     *
+     * This function is used instead of a sequence of removeNetwork()
+     * and saveConfiguration().
+     *
+     * @param config the set of variables that describe the configuration,
+     *            contained in a {@link WifiConfiguration} object.
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void forget(int netId, ActionListener listener) {
+        if (netId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        sAsyncChannel.sendMessage(FORGET_NETWORK, netId, putListener(listener));
+    }
+
+    /**
+     * Disable network
+     *
+     * @param netId is the network Id
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     * @hide
+     */
+    public void disable(int netId, ActionListener listener) {
+        if (netId < 0) throw new IllegalArgumentException("Network id cannot be negative");
+        validateChannel();
+        sAsyncChannel.sendMessage(DISABLE_NETWORK, netId, putListener(listener));
+    }
+
+    /**
+     * Start Wi-fi Protected Setup
+     *
+     * @param config WPS configuration
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     */
+    public void startWps(WpsInfo config, WpsCallback listener) {
+        if (config == null) throw new IllegalArgumentException("config cannot be null");
+        validateChannel();
+        sAsyncChannel.sendMessage(START_WPS, 0, putListener(listener), config);
+    }
+
+    /**
+     * Cancel any ongoing Wi-fi Protected Setup
+     *
+     * @param listener for callbacks on success or failure. Can be null.
+     * @throws IllegalStateException if the WifiManager instance needs to be
+     * initialized again
+     */
+    public void cancelWps(WpsCallback listener) {
+        validateChannel();
+        sAsyncChannel.sendMessage(CANCEL_WPS, 0, putListener(listener));
+    }
+
+    /**
+     * Get a reference to WifiService handler. This is used by a client to establish
+     * an AsyncChannel communication with WifiService
+     *
+     * @return Messenger pointing to the WifiService handler
+     * @hide
+     */
+    public Messenger getWifiServiceMessenger() {
+        try {
+            return mService.getWifiServiceMessenger();
+        } catch (RemoteException e) {
+            return null;
+        } catch (SecurityException e) {
+            return null;
+        }
+    }
+
+
+    /**
+     * Returns the file in which IP and proxy configuration data is stored
+     * @hide
+     */
+    public String getConfigFile() {
+        try {
+            return mService.getConfigFile();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Allows an application to keep the Wi-Fi radio awake.
+     * Normally the Wi-Fi radio may turn off when the user has not used the device in a while.
+     * Acquiring a WifiLock will keep the radio on until the lock is released.  Multiple
+     * applications may hold WifiLocks, and the radio will only be allowed to turn off when no
+     * WifiLocks are held in any application.
+     * <p>
+     * Before using a WifiLock, consider carefully if your application requires Wi-Fi access, or
+     * could function over a mobile network, if available.  A program that needs to download large
+     * files should hold a WifiLock to ensure that the download will complete, but a program whose
+     * network usage is occasional or low-bandwidth should not hold a WifiLock to avoid adversely
+     * affecting battery life.
+     * <p>
+     * Note that WifiLocks cannot override the user-level "Wi-Fi Enabled" setting, nor Airplane
+     * Mode.  They simply keep the radio from turning off when Wi-Fi is already on but the device
+     * is idle.
+     * <p>
+     * Any application using a WifiLock must request the {@code android.permission.WAKE_LOCK}
+     * permission in an {@code &lt;uses-permission&gt;} element of the application's manifest.
+     */
+    public class WifiLock {
+        private String mTag;
+        private final IBinder mBinder;
+        private int mRefCount;
+        int mLockType;
+        private boolean mRefCounted;
+        private boolean mHeld;
+        private WorkSource mWorkSource;
+
+        private WifiLock(int lockType, String tag) {
+            mTag = tag;
+            mLockType = lockType;
+            mBinder = new Binder();
+            mRefCount = 0;
+            mRefCounted = true;
+            mHeld = false;
+        }
+
+        /**
+         * Locks the Wi-Fi radio on until {@link #release} is called.
+         *
+         * If this WifiLock is reference-counted, each call to {@code acquire} will increment the
+         * reference count, and the radio will remain locked as long as the reference count is
+         * above zero.
+         *
+         * If this WifiLock is not reference-counted, the first call to {@code acquire} will lock
+         * the radio, but subsequent calls will be ignored.  Only one call to {@link #release}
+         * will be required, regardless of the number of times that {@code acquire} is called.
+         */
+        public void acquire() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
+                    try {
+                        mService.acquireWifiLock(mBinder, mLockType, mTag, mWorkSource);
+                        synchronized (WifiManagerWAP.this) {
+                            if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
+                                mService.releaseWifiLock(mBinder);
+                                throw new UnsupportedOperationException(
+                                            "Exceeded maximum number of wifi locks");
+                            }
+                            mActiveLockCount++;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = true;
+                }
+            }
+        }
+
+        /**
+         * Unlocks the Wi-Fi radio, allowing it to turn off when the device is idle.
+         *
+         * If this WifiLock is reference-counted, each call to {@code release} will decrement the
+         * reference count, and the radio will be unlocked only when the reference count reaches
+         * zero.  If the reference count goes below zero (that is, if {@code release} is called
+         * a greater number of times than {@link #acquire}), an exception is thrown.
+         *
+         * If this WifiLock is not reference-counted, the first call to {@code release} (after
+         * the radio was locked using {@link #acquire}) will unlock the radio, and subsequent
+         * calls will be ignored.
+         */
+        public void release() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
+                    try {
+                        mService.releaseWifiLock(mBinder);
+                        synchronized (WifiManagerWAP.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = false;
+                }
+                if (mRefCount < 0) {
+                    throw new RuntimeException("WifiLock under-locked " + mTag);
+                }
+            }
+        }
+
+        /**
+         * Controls whether this is a reference-counted or non-reference-counted WifiLock.
+         *
+         * Reference-counted WifiLocks keep track of the number of calls to {@link #acquire} and
+         * {@link #release}, and only allow the radio to sleep when every call to {@link #acquire}
+         * has been balanced with a call to {@link #release}.  Non-reference-counted WifiLocks
+         * lock the radio whenever {@link #acquire} is called and it is unlocked, and unlock the
+         * radio whenever {@link #release} is called and it is locked.
+         *
+         * @param refCounted true if this WifiLock should keep a reference count
+         */
+        public void setReferenceCounted(boolean refCounted) {
+            mRefCounted = refCounted;
+        }
+
+        /**
+         * Checks whether this WifiLock is currently held.
+         *
+         * @return true if this WifiLock is held, false otherwise
+         */
+        public boolean isHeld() {
+            synchronized (mBinder) {
+                return mHeld;
+            }
+        }
+
+        public void setWorkSource(WorkSource ws) {
+            synchronized (mBinder) {
+                if (ws != null && ws.size() == 0) {
+                    ws = null;
+                }
+                boolean changed = true;
+                if (ws == null) {
+                    mWorkSource = null;
+                } else {
+                    ws.clearNames();
+                    if (mWorkSource == null) {
+                        changed = mWorkSource != null;
+                        mWorkSource = new WorkSource(ws);
+                    } else {
+                        changed = mWorkSource.diff(ws);
+                        if (changed) {
+                            mWorkSource.set(ws);
+                        }
+                    }
+                }
+                if (changed && mHeld) {
+                    try {
+                        mService.updateWifiLockWorkSource(mBinder, mWorkSource);
+                    } catch (RemoteException e) {
+                    }
+                }
+            }
+        }
+
+        public String toString() {
+            String s1, s2, s3;
+            synchronized (mBinder) {
+                s1 = Integer.toHexString(System.identityHashCode(this));
+                s2 = mHeld ? "held; " : "";
+                if (mRefCounted) {
+                    s3 = "refcounted: refcount = " + mRefCount;
+                } else {
+                    s3 = "not refcounted";
+                }
+                return "WifiLock{ " + s1 + "; " + s2 + s3 + " }";
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            super.finalize();
+            synchronized (mBinder) {
+                if (mHeld) {
+                    try {
+                        mService.releaseWifiLock(mBinder);
+                        synchronized (WifiManagerWAP.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Creates a new WifiLock.
+     *
+     * @param lockType the type of lock to create. See {@link #WIFI_MODE_FULL},
+     * {@link #WIFI_MODE_FULL_HIGH_PERF} and {@link #WIFI_MODE_SCAN_ONLY} for
+     * descriptions of the types of Wi-Fi locks.
+     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is
+     *            never shown to the user under normal conditions, but should be descriptive
+     *            enough to identify your application and the specific WifiLock within it, if it
+     *            holds multiple WifiLocks.
+     *
+     * @return a new, unacquired WifiLock with the given tag.
+     *
+     * @see WifiLock
+     */
+    public WifiLock createWifiLock(int lockType, String tag) {
+        return new WifiLock(lockType, tag);
+    }
+
+    /**
+     * Creates a new WifiLock.
+     *
+     * @param tag a tag for the WifiLock to identify it in debugging messages.  This string is
+     *            never shown to the user under normal conditions, but should be descriptive
+     *            enough to identify your application and the specific WifiLock within it, if it
+     *            holds multiple WifiLocks.
+     *
+     * @return a new, unacquired WifiLock with the given tag.
+     *
+     * @see WifiLock
+     */
+    public WifiLock createWifiLock(String tag) {
+        return new WifiLock(WIFI_MODE_FULL, tag);
+    }
+
+
+    /**
+     * Create a new MulticastLock
+     *
+     * @param tag a tag for the MulticastLock to identify it in debugging
+     *            messages.  This string is never shown to the user under
+     *            normal conditions, but should be descriptive enough to
+     *            identify your application and the specific MulticastLock
+     *            within it, if it holds multiple MulticastLocks.
+     *
+     * @return a new, unacquired MulticastLock with the given tag.
+     *
+     * @see MulticastLock
+     */
+    public MulticastLock createMulticastLock(String tag) {
+        return new MulticastLock(tag);
+    }
+
+    /**
+     * Allows an application to receive Wifi Multicast packets.
+     * Normally the Wifi stack filters out packets not explicitly
+     * addressed to this device.  Acquring a MulticastLock will
+     * cause the stack to receive packets addressed to multicast
+     * addresses.  Processing these extra packets can cause a noticable
+     * battery drain and should be disabled when not needed.
+     */
+    public class MulticastLock {
+        private String mTag;
+        private final IBinder mBinder;
+        private int mRefCount;
+        private boolean mRefCounted;
+        private boolean mHeld;
+
+        private MulticastLock(String tag) {
+            mTag = tag;
+            mBinder = new Binder();
+            mRefCount = 0;
+            mRefCounted = true;
+            mHeld = false;
+        }
+
+        /**
+         * Locks Wifi Multicast on until {@link #release} is called.
+         *
+         * If this MulticastLock is reference-counted each call to
+         * {@code acquire} will increment the reference count, and the
+         * wifi interface will receive multicast packets as long as the
+         * reference count is above zero.
+         *
+         * If this MulticastLock is not reference-counted, the first call to
+         * {@code acquire} will turn on the multicast packets, but subsequent
+         * calls will be ignored.  Only one call to {@link #release} will
+         * be required, regardless of the number of times that {@code acquire}
+         * is called.
+         *
+         * Note that other applications may also lock Wifi Multicast on.
+         * Only they can relinquish their lock.
+         *
+         * Also note that applications cannot leave Multicast locked on.
+         * When an app exits or crashes, any Multicast locks will be released.
+         */
+        public void acquire() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
+                    try {
+                        mService.acquireMulticastLock(mBinder, mTag);
+                        synchronized (WifiManagerWAP.this) {
+                            if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
+                                mService.releaseMulticastLock();
+                                throw new UnsupportedOperationException(
+                                        "Exceeded maximum number of wifi locks");
+                            }
+                            mActiveLockCount++;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = true;
+                }
+            }
+        }
+
+        /**
+         * Unlocks Wifi Multicast, restoring the filter of packets
+         * not addressed specifically to this device and saving power.
+         *
+         * If this MulticastLock is reference-counted, each call to
+         * {@code release} will decrement the reference count, and the
+         * multicast packets will only stop being received when the reference
+         * count reaches zero.  If the reference count goes below zero (that
+         * is, if {@code release} is called a greater number of times than
+         * {@link #acquire}), an exception is thrown.
+         *
+         * If this MulticastLock is not reference-counted, the first call to
+         * {@code release} (after the radio was multicast locked using
+         * {@link #acquire}) will unlock the multicast, and subsequent calls
+         * will be ignored.
+         *
+         * Note that if any other Wifi Multicast Locks are still outstanding
+         * this {@code release} call will not have an immediate effect.  Only
+         * when all applications have released all their Multicast Locks will
+         * the Multicast filter be turned back on.
+         *
+         * Also note that when an app exits or crashes all of its Multicast
+         * Locks will be automatically released.
+         */
+        public void release() {
+            synchronized (mBinder) {
+                if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
+                    try {
+                        mService.releaseMulticastLock();
+                        synchronized (WifiManagerWAP.this) {
+                            mActiveLockCount--;
+                        }
+                    } catch (RemoteException ignore) {
+                    }
+                    mHeld = false;
+                }
+                if (mRefCount < 0) {
+                    throw new RuntimeException("MulticastLock under-locked "
+                            + mTag);
+                }
+            }
+        }
+
+        /**
+         * Controls whether this is a reference-counted or non-reference-
+         * counted MulticastLock.
+         *
+         * Reference-counted MulticastLocks keep track of the number of calls
+         * to {@link #acquire} and {@link #release}, and only stop the
+         * reception of multicast packets when every call to {@link #acquire}
+         * has been balanced with a call to {@link #release}.  Non-reference-
+         * counted MulticastLocks allow the reception of multicast packets
+         * whenever {@link #acquire} is called and stop accepting multicast
+         * packets whenever {@link #release} is called.
+         *
+         * @param refCounted true if this MulticastLock should keep a reference
+         * count
+         */
+        public void setReferenceCounted(boolean refCounted) {
+            mRefCounted = refCounted;
+        }
+
+        /**
+         * Checks whether this MulticastLock is currently held.
+         *
+         * @return true if this MulticastLock is held, false otherwise
+         */
+        public boolean isHeld() {
+            synchronized (mBinder) {
+                return mHeld;
+            }
+        }
+
+        public String toString() {
+            String s1, s2, s3;
+            synchronized (mBinder) {
+                s1 = Integer.toHexString(System.identityHashCode(this));
+                s2 = mHeld ? "held; " : "";
+                if (mRefCounted) {
+                    s3 = "refcounted: refcount = " + mRefCount;
+                } else {
+                    s3 = "not refcounted";
+                }
+                return "MulticastLock{ " + s1 + "; " + s2 + s3 + " }";
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            super.finalize();
+            setReferenceCounted(false);
+            release();
+        }
+    }
+
+    /**
+     * Check multicast filter status.
+     *
+     * @return true if multicast packets are allowed.
+     *
+     * @hide pending API council approval
+     */
+    public boolean isMulticastEnabled() {
+        try {
+            return mService.isMulticastEnabled();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Initialize the multicast filtering to 'on'
+     * @hide no intent to publish
+     */
+    public boolean initializeMulticastFiltering() {
+        try {
+            mService.initializeMulticastFiltering();
+            return true;
+        } catch (RemoteException e) {
+             return false;
+        }
+    }
+
+    protected void finalize() throws Throwable {
+        try {
+            synchronized (sThreadRefLock) {
+                if (--sThreadRefCount == 0 && sAsyncChannel != null) {
+                    sAsyncChannel.disconnect();
+                }
+            }
+        } finally {
+            super.finalize();
+        }
+    }
+
+    /**
+     * Set wifi verbose log. Called from developer settings.
+     * @hide
+     */
+    public void enableVerboseLogging (int verbose) {
+        try {
+            mService.enableVerboseLogging(verbose);
+        } catch (Exception e) {
+            //ignore any failure here
+            Log.e(TAG, "enableVerboseLogging " + e.toString());
+        }
+    }
+
+    /**
+     * Get the WiFi verbose logging level.This is used by settings
+     * to decide what to show within the picker.
+     * @hide
+     */
+    public int getVerboseLoggingLevel() {
+        try {
+            return mService.getVerboseLoggingLevel();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Set wifi Aggressive Handover. Called from developer settings.
+     * @hide
+     */
+    public void enableAggressiveHandover(int enabled) {
+        try {
+            mService.enableAggressiveHandover(enabled);
+        } catch (RemoteException e) {
+
+        }
+    }
+
+    /**
+     * Get the WiFi Handover aggressiveness.This is used by settings
+     * to decide what to show within the picker.
+     * @hide
+     */
+    public int getAggressiveHandover() {
+        try {
+            return mService.getAggressiveHandover();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Set setting for allowing Scans when traffic is ongoing.
+     * @hide
+     */
+    public void setAllowScansWithTraffic(int enabled) {
+        try {
+            mService.setAllowScansWithTraffic(enabled);
+        } catch (RemoteException e) {
+
+        }
+    }
+
+    /**
+     * Get setting for allowing Scans when traffic is ongoing.
+     * @hide
+     */
+    public int getAllowScansWithTraffic() {
+        try {
+            return mService.getAllowScansWithTraffic();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+
+
+}
diff -Nuar a/frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java b/frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
--- a/frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
+++ b/frameworks/opt/net/ethernet/java/com/android/server/ethernet/EthernetNetworkFactory.java
@@ -44,6 +44,9 @@
 import android.os.ServiceManager;
 import android.text.TextUtils;
 import android.util.Log;
+import android.net.wifi.WifiManager;
+import android.content.ContentResolver;
+import android.provider.Settings;
 
 import com.android.internal.util.IndentingPrintWriter;
 import com.android.server.net.BaseNetworkObserver;
@@ -77,6 +80,7 @@
     private static final String TAG = "EthernetNetworkFactory";
     private static final int NETWORK_SCORE = 70;
     private static final boolean DBG = true;
+    private WifiManager mWifiManager;
 
     /** Tracks interface changes. Called from NetworkManagementService. */
     private InterfaceObserver mInterfaceObserver;
@@ -133,7 +137,18 @@
         Log.d(TAG, "updateInterface: " + iface + " link " + (up ? "up" : "down"));
 
         synchronized(this) {
+            int wifiState = mWifiManager.getWifiState();
+            ContentResolver cr = mContext.getContentResolver();
+            if (up && ((wifiState == WifiManager.WIFI_STATE_ENABLING) ||
+                (wifiState == WifiManager.WIFI_STATE_ENABLED))) {
+                    mWifiManager.setWifiEnabled(false);
+                    Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 1);
+            }
+            else if((!up) && (wifiState == WifiManager.WIFI_STATE_DISABLED)){
+                mWifiManager.setWifiEnabled(true);
+            }
             mLinkUp = up;
+            mWifiManager.setEthUp(up);
             mNetworkInfo.setIsAvailable(up);
             if (!up) {
                 // Tell the agent we're disconnected. It will call disconnect().
@@ -358,6 +373,7 @@
         mIfaceMatch = context.getResources().getString(
                 com.android.internal.R.string.config_ethernet_iface_regex);
 
+	mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
         // Create and register our NetworkFactory.
         mFactory = new LocalNetworkFactory(NETWORK_TYPE, context, target.getLooper());
         mFactory.setCapabilityFilter(mNetworkCapabilities);
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTrackerWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTrackerWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTrackerWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/SupplicantStateTrackerWAP.java
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.os.BatteryStats;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Slog;
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+
+import android.content.Context;
+import android.content.Intent;
+import android.net.wifi.SupplicantState;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManagerWAP;
+import android.os.Handler;
+import android.os.Message;
+import android.os.Parcelable;
+import android.os.UserHandle;
+import android.util.Log;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+/**
+ * Tracks the state changes in supplicant and provides functionality
+ * that is based on these state changes:
+ * - detect a failed WPA handshake that loops indefinitely
+ * - authentication failure handling
+ */
+class SupplicantStateTrackerWAP extends StateMachine {
+
+    private static final String TAG = "SupplicantStateTrackerWAP";
+    private static boolean DBG = false;
+
+    private final WifiStateMachineWAP mWifiStateMachine;
+    private final WifiConfigStore mWifiConfigStore;
+    private final IBatteryStats mBatteryStats;
+    private int mAuthenticationFailuresCount = 0;
+    private int mAssociationRejectCount = 0;
+    /* Indicates authentication failure in supplicant broadcast.
+     * TODO: enhance auth failure reporting to include notification
+     * for all type of failures: EAP, WPS & WPA networks */
+    private boolean mAuthFailureInSupplicantBroadcast = false;
+
+    /* Maximum retries on a authentication failure notification */
+    private static final int MAX_RETRIES_ON_AUTHENTICATION_FAILURE = 2;
+
+    /* Maximum retries on assoc rejection events */
+    private static final int MAX_RETRIES_ON_ASSOCIATION_REJECT = 16;
+
+    /* Tracks if networks have been disabled during a connection */
+    private boolean mNetworksDisabledDuringConnect = false;
+
+    private final Context mContext;
+
+    private final State mUninitializedState = new UninitializedState();
+    private final State mDefaultState = new DefaultState();
+    private final State mInactiveState = new InactiveState();
+    private final State mDisconnectState = new DisconnectedState();
+    private final State mScanState = new ScanState();
+    private final State mHandshakeState = new HandshakeState();
+    private final State mCompletedState = new CompletedState();
+    private final State mDormantState = new DormantState();
+
+    void enableVerboseLogging(int verbose) {
+        if (verbose > 0) {
+            DBG = true;
+        } else {
+            DBG = false;
+        }
+    }
+
+    public String getSupplicantStateName() {
+        return getCurrentState().getName();
+    }
+
+    public SupplicantStateTrackerWAP(Context c, WifiStateMachineWAP wsm, WifiConfigStore wcs, Handler t) {
+        super(TAG, t.getLooper());
+
+        mContext = c;
+        mWifiStateMachine = wsm;
+        mWifiConfigStore = wcs;
+        mBatteryStats = (IBatteryStats)ServiceManager.getService(BatteryStats.SERVICE_NAME);
+        addState(mDefaultState);
+            addState(mUninitializedState, mDefaultState);
+            addState(mInactiveState, mDefaultState);
+            addState(mDisconnectState, mDefaultState);
+            addState(mScanState, mDefaultState);
+            addState(mHandshakeState, mDefaultState);
+            addState(mCompletedState, mDefaultState);
+            addState(mDormantState, mDefaultState);
+
+        setInitialState(mUninitializedState);
+        setLogRecSize(50);
+        setLogOnlyTransitions(true);
+        //start the state machine
+        start();
+    }
+
+    private void handleNetworkConnectionFailure(int netId, int disableReason) {
+        if (DBG) {
+            Log.d(TAG, "handleNetworkConnectionFailure netId=" + Integer.toString(netId)
+                    + " reason " + Integer.toString(disableReason)
+                    + " mNetworksDisabledDuringConnect=" + mNetworksDisabledDuringConnect);
+        }
+
+        /* If other networks disabled during connection, enable them */
+        if (mNetworksDisabledDuringConnect) {
+            mWifiConfigStore.enableAllNetworks();
+            mNetworksDisabledDuringConnect = false;
+        }
+        /* Disable failed network */
+        mWifiConfigStore.disableNetwork(netId, disableReason);
+    }
+
+    private void transitionOnSupplicantStateChange(StateChangeResult stateChangeResult) {
+        SupplicantState supState = (SupplicantState) stateChangeResult.state;
+
+        if (DBG) Log.d(TAG, "Supplicant state: " + supState.toString() + "\n");
+
+        switch (supState) {
+           case DISCONNECTED:
+                transitionTo(mDisconnectState);
+                break;
+            case INTERFACE_DISABLED:
+                //we should have received a disconnection already, do nothing
+                break;
+            case SCANNING:
+                transitionTo(mScanState);
+                break;
+            case AUTHENTICATING:
+            case ASSOCIATING:
+            case ASSOCIATED:
+            case FOUR_WAY_HANDSHAKE:
+            case GROUP_HANDSHAKE:
+                transitionTo(mHandshakeState);
+                break;
+            case COMPLETED:
+                transitionTo(mCompletedState);
+                break;
+            case DORMANT:
+                transitionTo(mDormantState);
+                break;
+            case INACTIVE:
+                transitionTo(mInactiveState);
+                break;
+            case UNINITIALIZED:
+            case INVALID:
+                transitionTo(mUninitializedState);
+                break;
+            default:
+                Log.e(TAG, "Unknown supplicant state " + supState);
+                break;
+        }
+    }
+
+    private void sendSupplicantStateChangedBroadcast(SupplicantState state, boolean failedAuth) {
+        int supplState;
+        switch (state) {
+            case DISCONNECTED: supplState = BatteryStats.WIFI_SUPPL_STATE_DISCONNECTED; break;
+            case INTERFACE_DISABLED:
+                supplState = BatteryStats.WIFI_SUPPL_STATE_INTERFACE_DISABLED; break;
+            case INACTIVE: supplState = BatteryStats.WIFI_SUPPL_STATE_INACTIVE; break;
+            case SCANNING: supplState = BatteryStats.WIFI_SUPPL_STATE_SCANNING; break;
+            case AUTHENTICATING: supplState = BatteryStats.WIFI_SUPPL_STATE_AUTHENTICATING; break;
+            case ASSOCIATING: supplState = BatteryStats.WIFI_SUPPL_STATE_ASSOCIATING; break;
+            case ASSOCIATED: supplState = BatteryStats.WIFI_SUPPL_STATE_ASSOCIATED; break;
+            case FOUR_WAY_HANDSHAKE:
+                supplState = BatteryStats.WIFI_SUPPL_STATE_FOUR_WAY_HANDSHAKE; break;
+            case GROUP_HANDSHAKE: supplState = BatteryStats.WIFI_SUPPL_STATE_GROUP_HANDSHAKE; break;
+            case COMPLETED: supplState = BatteryStats.WIFI_SUPPL_STATE_COMPLETED; break;
+            case DORMANT: supplState = BatteryStats.WIFI_SUPPL_STATE_DORMANT; break;
+            case UNINITIALIZED: supplState = BatteryStats.WIFI_SUPPL_STATE_UNINITIALIZED; break;
+            case INVALID: supplState = BatteryStats.WIFI_SUPPL_STATE_INVALID; break;
+            default:
+                Slog.w(TAG, "Unknown supplicant state " + state);
+                supplState = BatteryStats.WIFI_SUPPL_STATE_INVALID;
+                break;
+        }
+        try {
+            mBatteryStats.noteWifiSupplicantStateChanged(supplState, failedAuth);
+        } catch (RemoteException e) {
+            // Won't happen.
+        }
+        Intent intent = new Intent(WifiManagerWAP.SUPPLICANT_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT
+                | Intent.FLAG_RECEIVER_REPLACE_PENDING);
+        intent.putExtra(WifiManagerWAP.EXTRA_NEW_STATE, (Parcelable) state);
+        if (failedAuth) {
+            intent.putExtra(
+                WifiManagerWAP.EXTRA_SUPPLICANT_ERROR,
+                WifiManagerWAP.ERROR_AUTHENTICATING);
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    /********************************************************
+     * HSM states
+     *******************************************************/
+
+    class DefaultState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+         }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Log.d(TAG, getName() + message.toString() + "\n");
+            switch (message.what) {
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                    mAuthenticationFailuresCount++;
+                    mAuthFailureInSupplicantBroadcast = true;
+                    break;
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    SupplicantState state = stateChangeResult.state;
+                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast);
+                    mAuthFailureInSupplicantBroadcast = false;
+                    transitionOnSupplicantStateChange(stateChangeResult);
+                    break;
+                case WifiStateMachineWAP.CMD_RESET_SUPPLICANT_STATE:
+                    transitionTo(mUninitializedState);
+                    break;
+                case WifiManagerWAP.CONNECT_NETWORK:
+                    mNetworksDisabledDuringConnect = true;
+                    mAssociationRejectCount = 0;
+                    break;
+                case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                    mAssociationRejectCount++;
+                    break;
+                default:
+                    Log.e(TAG, "Ignoring " + message);
+                    break;
+            }
+            return HANDLED;
+        }
+    }
+
+    /*
+     * This indicates that the supplicant state as seen
+     * by the framework is not initialized yet. We are
+     * in this state right after establishing a control
+     * channel connection before any supplicant events
+     * or after we have lost the control channel
+     * connection to the supplicant
+     */
+    class UninitializedState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+         }
+    }
+
+    class InactiveState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+         }
+    }
+
+    class DisconnectedState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+             /* If a disconnect event happens after authentication failure
+              * exceeds maximum retries, disable the network
+              */
+             Message message = getCurrentMessage();
+             StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+
+             if (mAuthenticationFailuresCount >= MAX_RETRIES_ON_AUTHENTICATION_FAILURE) {
+                 Log.d(TAG, "Failed to authenticate, disabling network " +
+                         stateChangeResult.networkId);
+                 handleNetworkConnectionFailure(stateChangeResult.networkId,
+                         WifiConfiguration.DISABLED_AUTH_FAILURE);
+                 mAuthenticationFailuresCount = 0;
+             }
+             else if (mAssociationRejectCount >= MAX_RETRIES_ON_ASSOCIATION_REJECT) {
+                 Log.d(TAG, "Association getting rejected, disabling network " +
+                         stateChangeResult.networkId);
+                 handleNetworkConnectionFailure(stateChangeResult.networkId,
+                         WifiConfiguration.DISABLED_ASSOCIATION_REJECT);
+                 mAssociationRejectCount = 0;
+            }
+         }
+    }
+
+    class ScanState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+         }
+    }
+
+    class HandshakeState extends State {
+        /**
+         * The max number of the WPA supplicant loop iterations before we
+         * decide that the loop should be terminated:
+         */
+        private static final int MAX_SUPPLICANT_LOOP_ITERATIONS = 4;
+        private int mLoopDetectIndex;
+        private int mLoopDetectCount;
+
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+             mLoopDetectIndex = 0;
+             mLoopDetectCount = 0;
+         }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Log.d(TAG, getName() + message.toString() + "\n");
+            switch (message.what) {
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    SupplicantState state = stateChangeResult.state;
+                    if (SupplicantState.isHandshakeState(state)) {
+                        if (mLoopDetectIndex > state.ordinal()) {
+                            mLoopDetectCount++;
+                        }
+                        if (mLoopDetectCount > MAX_SUPPLICANT_LOOP_ITERATIONS) {
+                            Log.d(TAG, "Supplicant loop detected, disabling network " +
+                                    stateChangeResult.networkId);
+                            handleNetworkConnectionFailure(stateChangeResult.networkId,
+                                    WifiConfiguration.DISABLED_AUTH_FAILURE);
+                        }
+                        mLoopDetectIndex = state.ordinal();
+                        sendSupplicantStateChangedBroadcast(state,
+                                mAuthFailureInSupplicantBroadcast);
+                    } else {
+                        //Have the DefaultState handle the transition
+                        return NOT_HANDLED;
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class CompletedState extends State {
+        @Override
+         public void enter() {
+             if (DBG) Log.d(TAG, getName() + "\n");
+             /* Reset authentication failure count */
+             mAuthenticationFailuresCount = 0;
+             mAssociationRejectCount = 0;
+             if (mNetworksDisabledDuringConnect) {
+                 mWifiConfigStore.enableAllNetworks();
+                 mNetworksDisabledDuringConnect = false;
+             }
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            if (DBG) Log.d(TAG, getName() + message.toString() + "\n");
+            switch(message.what) {
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    SupplicantState state = stateChangeResult.state;
+                    sendSupplicantStateChangedBroadcast(state, mAuthFailureInSupplicantBroadcast);
+                    /* Ignore any connecting state in completed state. Group re-keying
+                     * events and other auth events that do not affect connectivity are
+                     * ignored
+                     */
+                    if (SupplicantState.isConnecting(state)) {
+                        break;
+                    }
+                    transitionOnSupplicantStateChange(stateChangeResult);
+                    break;
+                case WifiStateMachineWAP.CMD_RESET_SUPPLICANT_STATE:
+                    sendSupplicantStateChangedBroadcast(SupplicantState.DISCONNECTED, false);
+                    transitionTo(mUninitializedState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    //TODO: remove after getting rid of the state in supplicant
+    class DormantState extends State {
+        @Override
+        public void enter() {
+            if (DBG) Log.d(TAG, getName() + "\n");
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        super.dump(fd, pw, args);
+        pw.println("mAuthenticationFailuresCount " + mAuthenticationFailuresCount);
+        pw.println("mAuthFailureInSupplicantBroadcast " + mAuthFailureInSupplicantBroadcast);
+        pw.println("mNetworksDisabledDuringConnect " + mNetworksDisabledDuringConnect);
+        pw.println();
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiAutoJoinControllerWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiAutoJoinControllerWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiAutoJoinControllerWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiAutoJoinControllerWAP.java
@@ -0,0 +1,1688 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.content.Context;
+
+import android.net.NetworkKey;
+import android.net.NetworkScoreManager;
+import android.net.WifiKey;
+import android.net.wifi.*;
+
+import android.os.SystemClock;
+import android.os.Process;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * AutoJoin controller is responsible for WiFi Connect decision
+ *
+ * It runs in the thread context of WifiStateMachine
+ *
+ */
+public class WifiAutoJoinControllerWAP {
+
+    private Context mContext;
+    private WifiStateMachineWAP mWifiStateMachine;
+    private WifiConfigStore mWifiConfigStore;
+    private WifiNative mWifiNative;
+
+    private NetworkScoreManager scoreManager;
+    private WifiNetworkScoreCache mNetworkScoreCache;
+
+    private static final String TAG = "WifiAutoJoinControllerWAP ";
+    private static boolean DBG = false;
+    private static boolean VDBG = false;
+    private static final boolean mStaStaSupported = false;
+    private static final int SCAN_RESULT_CACHE_SIZE = 80;
+
+    public static int mScanResultMaximumAge = 40000; /* milliseconds unit */
+
+    private String mCurrentConfigurationKey = null; //used by autojoin
+
+    private HashMap<String, ScanResult> scanResultCache =
+            new HashMap<String, ScanResult>();
+
+    private ArrayList<String> mBlacklistedBssids;
+
+    private WifiConnectionStatistics mWifiConnectionStatistics;
+
+    /* for debug purpose only : the untrusted SSID we would be connected to if we had VPN */
+    String lastUntrustedBSSID = null;
+
+    /* For debug purpose only: if the scored override a score */
+    boolean didOverride = false;
+
+    // Lose the non-auth failure blacklisting after 8 hours
+    private final static long loseBlackListHardMilli = 1000 * 60 * 60 * 8;
+    // Lose some temporary blacklisting after 30 minutes
+    private final static long loseBlackListSoftMilli = 1000 * 60 * 30;
+
+    public static final int AUTO_JOIN_IDLE = 0;
+    public static final int AUTO_JOIN_ROAMING = 1;
+    public static final int AUTO_JOIN_EXTENDED_ROAMING = 2;
+    public static final int AUTO_JOIN_OUT_OF_NETWORK_ROAMING = 3;
+
+    public static final int HIGH_THRESHOLD_MODIFIER = 5;
+
+    // Below are AutoJoin wide parameters indicating if we should be aggressive before joining
+    // weak network. Note that we cannot join weak network that are going to be marked as unanted by
+    // ConnectivityService because this will trigger link flapping.
+    /**
+     * There was a non-blacklisted configuration that we bailed from because of a weak signal
+     */
+    boolean didBailDueToWeakRssi = false;
+    /**
+     * number of time we consecutively bailed out of an eligible network because its signal
+     * was too weak
+     */
+    int weakRssiBailCount = 0;
+
+    WifiAutoJoinControllerWAP(Context c, WifiStateMachineWAP w, WifiConfigStore s,
+                           WifiConnectionStatistics st, WifiNative n) {
+        mContext = c;
+        mWifiStateMachine = w;
+        mWifiConfigStore = s;
+        mWifiNative = n;
+        mNetworkScoreCache = null;
+        mWifiConnectionStatistics = st;
+        scoreManager =
+                (NetworkScoreManager) mContext.getSystemService(Context.NETWORK_SCORE_SERVICE);
+        if (scoreManager == null)
+            logDbg("Registered scoreManager NULL " + " service " + Context.NETWORK_SCORE_SERVICE);
+
+        if (scoreManager != null) {
+            mNetworkScoreCache = new WifiNetworkScoreCache(mContext);
+            scoreManager.registerNetworkScoreCache(NetworkKey.TYPE_WIFI_WAP, mNetworkScoreCache);
+        } else {
+            logDbg("No network score service: Couldnt register as a WiFi score Manager, type="
+                    + Integer.toString(NetworkKey.TYPE_WIFI_WAP)
+                    + " service " + Context.NETWORK_SCORE_SERVICE);
+            mNetworkScoreCache = null;
+        }
+        mBlacklistedBssids = new ArrayList<String>();
+    }
+
+    void enableVerboseLogging(int verbose) {
+        if (verbose > 0 ) {
+            DBG = true;
+            VDBG = true;
+        } else {
+            DBG = false;
+            VDBG = false;
+        }
+    }
+
+    /**
+     * Flush out scan results older than mScanResultMaximumAge
+     *
+     */
+    private void ageScanResultsOut(int delay) {
+        if (delay <= 0) {
+            delay = mScanResultMaximumAge; // Something sane
+        }
+        long milli = System.currentTimeMillis();
+        if (VDBG) {
+            logDbg("ageScanResultsOut delay " + Integer.valueOf(delay) + " size "
+                    + Integer.valueOf(scanResultCache.size()) + " now " + Long.valueOf(milli));
+        }
+
+        Iterator<HashMap.Entry<String,ScanResult>> iter = scanResultCache.entrySet().iterator();
+        while (iter.hasNext()) {
+            HashMap.Entry<String,ScanResult> entry = iter.next();
+            ScanResult result = entry.getValue();
+
+            if ((result.seen + delay) < milli) {
+                iter.remove();
+            }
+        }
+    }
+
+    int addToScanCache(List<ScanResult> scanList) {
+        int numScanResultsKnown = 0; // Record number of scan results we knew about
+        WifiConfiguration associatedConfig = null;
+        boolean didAssociate = false;
+
+        ArrayList<NetworkKey> unknownScanResults = new ArrayList<NetworkKey>();
+
+        long nowMs = System.currentTimeMillis();
+        for(ScanResult result: scanList) {
+            if (result.SSID == null) continue;
+
+            // Make sure we record the last time we saw this result
+            result.seen = System.currentTimeMillis();
+
+            // Fetch the previous instance for this result
+            ScanResult sr = scanResultCache.get(result.BSSID);
+            if (sr != null) {
+                // If there was a previous cache result for this BSSID, average the RSSI values
+                result.averageRssi(sr.level, sr.seen, mScanResultMaximumAge);
+
+                // Remove the previous Scan Result - this is not necessary
+                scanResultCache.remove(result.BSSID);
+            }
+
+            if (!mNetworkScoreCache.isScoredNetwork(result)) {
+                WifiKey wkey;
+                // Quoted SSIDs are the only one valid at this stage
+                try {
+                    wkey = new WifiKey("\"" + result.SSID + "\"", result.BSSID);
+                } catch (IllegalArgumentException e) {
+                    logDbg("AutoJoinController: received badly encoded SSID=[" + result.SSID +
+                            "] ->skipping this network");
+                    wkey = null;
+                }
+                if (wkey != null) {
+                    NetworkKey nkey = new NetworkKey(wkey);
+                    //if we don't know this scan result then request a score from the scorer
+                    unknownScanResults.add(nkey);
+                }
+                if (VDBG) {
+                    String cap = "";
+                    if (result.capabilities != null)
+                        cap = result.capabilities;
+                    logDbg(result.SSID + " " + result.BSSID + " rssi="
+                            + result.level + " cap " + cap + " is not scored");
+                }
+            } else {
+                if (VDBG) {
+                    String cap = "";
+                    if (result.capabilities != null)
+                        cap = result.capabilities;
+                    int score = mNetworkScoreCache.getNetworkScore(result);
+                    logDbg(result.SSID + " " + result.BSSID + " rssi="
+                            + result.level + " cap " + cap + " is scored : " + score);
+                }
+            }
+
+            // scanResultCache.put(result.BSSID, new ScanResult(result));
+            scanResultCache.put(result.BSSID, result);
+            // Add this BSSID to the scanResultCache of a Saved WifiConfiguration
+            didAssociate = mWifiConfigStore.updateSavedNetworkHistory(result);
+
+            // If not successful, try to associate this BSSID to an existing Saved WifiConfiguration
+            if (!didAssociate) {
+                // We couldn't associate the scan result to a Saved WifiConfiguration
+                // Hence it is untrusted
+                result.untrusted = true;
+                associatedConfig = mWifiConfigStore.associateWithConfiguration(result);
+                if (associatedConfig != null && associatedConfig.SSID != null) {
+                    if (VDBG) {
+                        logDbg("addToScanCache save associated config "
+                                + associatedConfig.SSID + " with " + result.SSID);
+                    }
+                    mWifiStateMachine.sendMessage(
+                            WifiStateMachineWAP.CMD_AUTO_SAVE_NETWORK, associatedConfig);
+                    didAssociate = true;
+                }
+            } else {
+                // If the scan result has been blacklisted fir 18 hours -> unblacklist
+                long now = System.currentTimeMillis();
+                if ((now - result.blackListTimestamp) > loseBlackListHardMilli) {
+                    result.setAutoJoinStatus(ScanResult.ENABLED);
+                }
+            }
+            if (didAssociate) {
+                numScanResultsKnown++;
+                result.isAutoJoinCandidate ++;
+            } else {
+                result.isAutoJoinCandidate = 0;
+            }
+        }
+
+        if (unknownScanResults.size() != 0) {
+            NetworkKey[] newKeys =
+                    unknownScanResults.toArray(new NetworkKey[unknownScanResults.size()]);
+            // Kick the score manager, we will get updated scores asynchronously
+            scoreManager.requestScores(newKeys);
+        }
+        return numScanResultsKnown;
+    }
+
+    void logDbg(String message) {
+        logDbg(message, false);
+    }
+
+    void logDbg(String message, boolean stackTrace) {
+        long now = SystemClock.elapsedRealtimeNanos();
+        if (stackTrace) {
+            Log.e(TAG, message + " stack:"
+                    + Thread.currentThread().getStackTrace()[2].getMethodName() + " - "
+                    + Thread.currentThread().getStackTrace()[3].getMethodName() + " - "
+                    + Thread.currentThread().getStackTrace()[4].getMethodName() + " - "
+                    + Thread.currentThread().getStackTrace()[5].getMethodName());
+        } else {
+            Log.e(TAG, message);
+        }
+    }
+
+    // Called directly from WifiStateMachine
+    int newSupplicantResults(boolean doAutoJoin) {
+        int numScanResultsKnown;
+        List<ScanResult> scanList = mWifiStateMachine.getScanResultsListNoCopyUnsync();
+        numScanResultsKnown = addToScanCache(scanList);
+        ageScanResultsOut(mScanResultMaximumAge);
+        if (DBG) {
+            logDbg("newSupplicantResults size=" + Integer.valueOf(scanResultCache.size())
+                        + " known=" + numScanResultsKnown + " "
+                        + doAutoJoin);
+        }
+        if (doAutoJoin) {
+            attemptAutoJoin();
+        }
+        mWifiConfigStore.writeKnownNetworkHistory();
+        return numScanResultsKnown;
+    }
+
+
+    /**
+     * Not used at the moment
+     * should be a call back from WifiScanner HAL ??
+     * this function is not hooked and working yet, it will receive scan results from WifiScanners
+     * with the list of IEs,then populate the capabilities by parsing the IEs and inject the scan
+     * results as normal.
+     */
+    void newHalScanResults() {
+        List<ScanResult> scanList = null;//mWifiScanner.syncGetScanResultsList();
+        String akm = WifiParser.parse_akm(null, null);
+        logDbg(akm);
+        addToScanCache(scanList);
+        ageScanResultsOut(0);
+        attemptAutoJoin();
+        mWifiConfigStore.writeKnownNetworkHistory();
+    }
+
+    /**
+     *  network link quality changed, called directly from WifiTrafficPoller,
+     * or by listening to Link Quality intent
+     */
+    void linkQualitySignificantChange() {
+        attemptAutoJoin();
+    }
+
+    /**
+     * compare a WifiConfiguration against the current network, return a delta score
+     * If not associated, and the candidate will always be better
+     * For instance if the candidate is a home network versus an unknown public wifi,
+     * the delta will be infinite, else compare Kepler scores etc
+     * Negatve return values from this functions are meaningless per se, just trying to
+     * keep them distinct for debug purpose (i.e. -1, -2 etc...)
+     */
+    private int compareNetwork(WifiConfiguration candidate,
+                               String lastSelectedConfiguration) {
+        if (candidate == null)
+            return -3;
+
+        WifiConfiguration currentNetwork = mWifiStateMachine.getCurrentWifiConfiguration();
+        if (currentNetwork == null) {
+            // Return any absurdly high score, if we are not connected there is no current
+            // network to...
+           return 1000;
+        }
+
+        if (candidate.configKey(true).equals(currentNetwork.configKey(true))) {
+            return -2;
+        }
+
+        if (DBG) {
+            logDbg("compareNetwork will compare " + candidate.configKey()
+                    + " with current " + currentNetwork.configKey());
+        }
+        int order = compareWifiConfigurationsTop(currentNetwork, candidate);
+
+        // The lastSelectedConfiguration is the configuration the user has manually selected
+        // thru WifiPicker, or that a 3rd party app asked us to connect to via the
+        // enableNetwork with disableOthers=true WifiManager API
+        // As this is a direct user choice, we strongly prefer this configuration,
+        // hence give +/-100
+        if ((lastSelectedConfiguration != null)
+                && currentNetwork.configKey().equals(lastSelectedConfiguration)) {
+            // currentNetwork is the last selected configuration,
+            // so keep it above connect choices (+/-60) and
+            // above RSSI/scorer based selection of linked configuration (+/- 50)
+            // by reducing order by -100
+            order = order - 100;
+            if (VDBG)   {
+                logDbg("     ...and prefers -100 " + currentNetwork.configKey()
+                        + " over " + candidate.configKey()
+                        + " because it is the last selected -> "
+                        + Integer.toString(order));
+            }
+        } else if ((lastSelectedConfiguration != null)
+                && candidate.configKey().equals(lastSelectedConfiguration)) {
+            // candidate is the last selected configuration,
+            // so keep it above connect choices (+/-60) and
+            // above RSSI/scorer based selection of linked configuration (+/- 50)
+            // by increasing order by +100
+            order = order + 100;
+            if (VDBG)   {
+                logDbg("     ...and prefers +100 " + candidate.configKey()
+                        + " over " + currentNetwork.configKey()
+                        + " because it is the last selected -> "
+                        + Integer.toString(order));
+            }
+        }
+
+        return order;
+    }
+
+    /**
+     * update the network history fields fo that configuration
+     * - if userTriggered, we mark the configuration as "non selfAdded" since the user has seen it
+     * and took over management
+     * - if it is a "connect", remember which network were there at the point of the connect, so
+     * as those networks get a relative lower score than the selected configuration
+     *
+     * @param netId
+     * @param userTriggered : if the update come from WiFiManager
+     * @param connect : if the update includes a connect
+     */
+    public void updateConfigurationHistory(int netId, boolean userTriggered, boolean connect) {
+        WifiConfiguration selected = mWifiConfigStore.getWifiConfiguration(netId);
+        if (selected == null) {
+            logDbg("updateConfigurationHistory nid=" + netId + " no selected configuration!");
+            return;
+        }
+
+        if (selected.SSID == null) {
+            logDbg("updateConfigurationHistory nid=" + netId +
+                    " no SSID in selected configuration!");
+            return;
+        }
+
+        if (userTriggered) {
+            // Reenable autojoin for this network,
+            // since the user want to connect to this configuration
+            selected.setAutoJoinStatus(WifiConfiguration.AUTO_JOIN_ENABLED);
+            selected.selfAdded = false;
+            selected.dirty = true;
+        }
+
+        if (DBG && userTriggered) {
+            if (selected.connectChoices != null) {
+                logDbg("updateConfigurationHistory will update "
+                        + Integer.toString(netId) + " now: "
+                        + Integer.toString(selected.connectChoices.size())
+                        + " uid=" + Integer.toString(selected.creatorUid), true);
+            } else {
+                logDbg("updateConfigurationHistory will update "
+                        + Integer.toString(netId)
+                        + " uid=" + Integer.toString(selected.creatorUid), true);
+            }
+        }
+
+        if (connect && userTriggered) {
+            boolean found = false;
+            int choice = 0;
+            int size = 0;
+
+            // Reset the triggered disabled count, because user wanted to connect to this
+            // configuration, and we were not.
+            selected.numUserTriggeredWifiDisableLowRSSI = 0;
+            selected.numUserTriggeredWifiDisableBadRSSI = 0;
+            selected.numUserTriggeredWifiDisableNotHighRSSI = 0;
+            selected.numUserTriggeredJoinAttempts++;
+
+            List<WifiConfiguration> networks =
+                    mWifiConfigStore.getRecentConfiguredNetworks(12000, false);
+            if (networks != null) size = networks.size();
+            logDbg("updateConfigurationHistory found " + size + " networks");
+            if (networks != null) {
+                for (WifiConfiguration config : networks) {
+                    if (DBG) {
+                        logDbg("updateConfigurationHistory got " + config.SSID + " nid="
+                                + Integer.toString(config.networkId));
+                    }
+
+                    if (selected.configKey(true).equals(config.configKey(true))) {
+                        found = true;
+                        continue;
+                    }
+
+                    // Compare RSSI values so as to evaluate the strength of the user preference
+                    int order = compareWifiConfigurationsRSSI(config, selected, null);
+
+                    if (order < -30) {
+                        // Selected configuration is worse than the visible configuration
+                        // hence register a strong choice so as autojoin cannot override this
+                        // for instance, the user has select a network
+                        // with 1 bar over a network with 3 bars...
+                        choice = 60;
+                    } else if (order < -20) {
+                        choice = 50;
+                    } else if (order < -10) {
+                        choice = 40;
+                    } else if (order < 20) {
+                        // Selected configuration is about same or has a slightly better RSSI
+                        // hence register a weaker choice, here a difference of at least +/-30 in
+                        // RSSI comparison triggered by autoJoin will override the choice
+                        choice = 30;
+                    } else {
+                        // Selected configuration is better than the visible configuration
+                        // hence we do not know if the user prefers this configuration strongly
+                        choice = 20;
+                    }
+
+                    // The selected configuration was preferred over a recently seen config
+                    // hence remember the user's choice:
+                    // add the recently seen config to the selected's connectChoices array
+
+                    if (selected.connectChoices == null) {
+                        selected.connectChoices = new HashMap<String, Integer>();
+                    }
+
+                    logDbg("updateConfigurationHistory add a choice " + selected.configKey(true)
+                            + " over " + config.configKey(true)
+                            + " choice " + Integer.toString(choice));
+
+                    Integer currentChoice = selected.connectChoices.get(config.configKey(true));
+                    if (currentChoice != null) {
+                        // User has made this choice multiple time in a row, so bump up a lot
+                        choice += currentChoice.intValue();
+                    }
+                    // Add the visible config to the selected's connect choice list
+                    selected.connectChoices.put(config.configKey(true), choice);
+
+                    if (config.connectChoices != null) {
+                        if (VDBG) {
+                            logDbg("updateConfigurationHistory will remove "
+                                    + selected.configKey(true) + " from " + config.configKey(true));
+                        }
+                        // Remove the selected from the recently seen config's connectChoice list
+                        config.connectChoices.remove(selected.configKey(true));
+
+                        if (selected.linkedConfigurations != null) {
+                           // Remove the selected's linked configuration from the
+                           // recently seen config's connectChoice list
+                           for (String key : selected.linkedConfigurations.keySet()) {
+                               config.connectChoices.remove(key);
+                           }
+                        }
+                    }
+                }
+                if (found == false) {
+                     // We haven't found the configuration that the user just selected in our
+                     // scan cache.
+                     // In that case we will need a new scan before attempting to connect to this
+                     // configuration anyhow and thus we can process the scan results then.
+                     logDbg("updateConfigurationHistory try to connect to an old network!! : "
+                             + selected.configKey());
+                }
+
+                if (selected.connectChoices != null) {
+                    if (VDBG)
+                        logDbg("updateConfigurationHistory " + Integer.toString(netId)
+                                + " now: " + Integer.toString(selected.connectChoices.size()));
+                }
+            }
+        }
+
+        // TODO: write only if something changed
+        if (userTriggered || connect) {
+            mWifiConfigStore.writeKnownNetworkHistory();
+        }
+    }
+
+    int getConnectChoice(WifiConfiguration source, WifiConfiguration target) {
+        Integer choice = null;
+        if (source == null || target == null) {
+            return 0;
+        }
+
+        if (source.connectChoices != null
+                && source.connectChoices.containsKey(target.configKey(true))) {
+            choice = source.connectChoices.get(target.configKey(true));
+        } else if (source.linkedConfigurations != null) {
+            for (String key : source.linkedConfigurations.keySet()) {
+                WifiConfiguration config = mWifiConfigStore.getWifiConfiguration(key);
+                if (config != null) {
+                    if (config.connectChoices != null) {
+                        choice = config.connectChoices.get(target.configKey(true));
+                    }
+                }
+            }
+        }
+
+        if (choice == null) {
+            //We didn't find the connect choice
+            return 0;
+        } else {
+            if (choice.intValue() < 0) {
+                choice = 20; // Compatibility with older files
+            }
+            return choice.intValue();
+        }
+    }
+
+
+    int getScoreFromVisibility(WifiConfiguration.Visibility visibility, int rssiBoost, String dbg) {
+        int rssiBoost5 = 0;
+        int score = 0;
+
+        /**
+         * Boost RSSI value of 5GHz bands iff the base value is better than threshold
+         * This implements band preference where we prefer 5GHz if RSSI5 is good enough, whereas
+         * we prefer 2.4GHz otherwise.
+         * Note that 2.4GHz doesn't need a boost since at equal power the RSSI is typically
+         * at least 6-10 dB higher
+         */
+        rssiBoost5 = rssiBoostFrom5GHzRssi(visibility.rssi5, dbg+"->");
+
+        // Select which band to use so as to score a
+        if (visibility.rssi5 + rssiBoost5 > visibility.rssi24) {
+            // Prefer a's 5GHz
+            score = visibility.rssi5 + rssiBoost5 + rssiBoost;
+        } else {
+            // Prefer a's 2.4GHz
+            score = visibility.rssi24 + rssiBoost;
+        }
+
+        return score;
+    }
+
+    // Compare WifiConfiguration by RSSI, and return a comparison value in the range [-50, +50]
+    // The result represents "approximately" an RSSI difference measured in dBM
+    // Adjusted with various parameters:
+    // +) current network gets a +15 boost
+    // +) 5GHz signal, if they are strong enough, get a +15 or +25 boost, representing the
+    // fact that at short range we prefer 5GHz band as it is cleaner of interference and
+    // provides for wider channels
+    int compareWifiConfigurationsRSSI(WifiConfiguration a, WifiConfiguration b,
+                                      String currentConfiguration) {
+        int order = 0;
+
+        // Boost used so as to favor current config
+        int aRssiBoost = 0;
+        int bRssiBoost = 0;
+
+        int scoreA;
+        int scoreB;
+
+        // Retrieve the visibility
+        WifiConfiguration.Visibility astatus = a.visibility;
+        WifiConfiguration.Visibility bstatus = b.visibility;
+        if (astatus == null || bstatus == null) {
+            // Error visibility wasn't set
+            logDbg("    compareWifiConfigurations NULL band status!");
+            return 0;
+        }
+
+        // Apply Hysteresis, boost RSSI of current configuration
+        if (null != currentConfiguration) {
+            if (a.configKey().equals(currentConfiguration)) {
+                aRssiBoost = +10;
+            } else if (b.configKey().equals(currentConfiguration)) {
+                bRssiBoost = +10;
+            }
+
+
+        }
+
+        if (VDBG)  {
+            logDbg("    compareWifiConfigurationsRSSI: " + a.configKey()
+                    + " " + Integer.toString(astatus.rssi24)
+                    + "," + Integer.toString(astatus.rssi5)
+                    + " boost=" + Integer.toString(aRssiBoost)
+                    + " " + b.configKey() + " "
+                    + Integer.toString(bstatus.rssi24) + ","
+                    + Integer.toString(bstatus.rssi5)
+                    + " boost=" + Integer.toString(bRssiBoost)
+            );
+        }
+
+        scoreA = getScoreFromVisibility(astatus, aRssiBoost, a.configKey());
+        scoreB = getScoreFromVisibility(bstatus, bRssiBoost, b.configKey());
+
+        // Compare a and b
+        // If a score is higher then a > b and the order is descending (negative)
+        // If b score is higher then a < b and the order is ascending (positive)
+        order = scoreB - scoreA;
+
+        // Normalize the order to [-50, +50]
+        if (order > 50) order = 50;
+        else if (order < -50) order = -50;
+
+        if (VDBG) {
+            String prefer = " = ";
+            if (order > 0) {
+                prefer = " < "; // Ascending
+            } else if (order < 0) {
+                prefer = " > "; // Descending
+            }
+            logDbg("    compareWifiConfigurationsRSSI " + a.configKey()
+                    + " rssi=(" + a.visibility.rssi24
+                    + "," + a.visibility.rssi5
+                    + ") num=(" + a.visibility.num24
+                    + "," + a.visibility.num5 + ")"
+                    + " scorea=" + scoreA
+                    + prefer + b.configKey()
+                    + " rssi=(" + b.visibility.rssi24
+                    + "," + b.visibility.rssi5
+                    + ") num=(" + b.visibility.num24
+                    + "," + b.visibility.num5 + ")"
+                    + " scoreb=" + scoreB
+                    + " -> " + order);
+        }
+
+        return order;
+    }
+
+
+    int compareWifiConfigurationsWithScorer(WifiConfiguration a, WifiConfiguration b) {
+
+        int aRssiBoost = 0;
+        int bRssiBoost = 0;
+
+        // Apply Hysteresis : boost RSSI of current configuration before
+        // looking up the score
+        if (null != mCurrentConfigurationKey) {
+            if (a.configKey().equals(mCurrentConfigurationKey)) {
+                aRssiBoost += 20;
+            } else if (b.configKey().equals(mCurrentConfigurationKey)) {
+                bRssiBoost += 20;
+            }
+        }
+        int scoreA = getConfigNetworkScore(a, 3000, aRssiBoost);
+        int scoreB = getConfigNetworkScore(b, 3000, bRssiBoost);
+
+        // Both configurations need to have a score for the scorer to be used
+        // ...and the scores need to be different:-)
+        if (scoreA == WifiNetworkScoreCache.INVALID_NETWORK_SCORE
+                || scoreB == WifiNetworkScoreCache.INVALID_NETWORK_SCORE) {
+            if (VDBG)  {
+                logDbg("    compareWifiConfigurationsWithScorer no-scores: "
+                        + a.configKey()
+                        + " "
+                        + b.configKey());
+            }
+            return 0;
+        }
+
+        if (VDBG) {
+            String prefer = " = ";
+            if (scoreA < scoreB) {
+                prefer = " < ";
+            } if (scoreA > scoreB) {
+                prefer = " > ";
+            }
+            logDbg("    compareWifiConfigurationsWithScorer " + a.configKey()
+                    + " rssi=(" + a.visibility.rssi24
+                    + "," + a.visibility.rssi5
+                    + ") num=(" + a.visibility.num24
+                    + "," + a.visibility.num5 + ")"
+                    + " sc=" + scoreA
+                    + prefer + b.configKey()
+                    + " rssi=(" + b.visibility.rssi24
+                    + "," + b.visibility.rssi5
+                    + ") num=(" + b.visibility.num24
+                    + "," + b.visibility.num5 + ")"
+                    + " sc=" + scoreB
+                    + " -> " + Integer.toString(scoreB - scoreA));
+        }
+
+        // If scoreA > scoreB, the comparison is descending hence the return value is negative
+        return scoreB - scoreA;
+    }
+
+    int compareWifiConfigurations(WifiConfiguration a, WifiConfiguration b) {
+        int order = 0;
+        String lastSelectedConfiguration = mWifiConfigStore.getLastSelectedConfiguration();
+        boolean linked = false;
+
+        if ((a.linkedConfigurations != null) && (b.linkedConfigurations != null)
+                && (a.autoJoinStatus == WifiConfiguration.AUTO_JOIN_ENABLED)
+                && (b.autoJoinStatus == WifiConfiguration.AUTO_JOIN_ENABLED)) {
+            if ((a.linkedConfigurations.get(b.configKey(true)) != null)
+                    && (b.linkedConfigurations.get(a.configKey(true)) != null)) {
+                linked = true;
+            }
+        }
+
+        if (a.ephemeral && b.ephemeral == false) {
+            if (VDBG) {
+                logDbg("    compareWifiConfigurations ephemeral and prefers " + b.configKey()
+                        + " over " + a.configKey());
+            }
+            return 1; // b is of higher priority - ascending
+        }
+        if (b.ephemeral && a.ephemeral == false) {
+            if (VDBG) {
+                logDbg("    compareWifiConfigurations ephemeral and prefers " + a.configKey()
+                        + " over " + b.configKey());
+            }
+            return -1; // a is of higher priority - descending
+        }
+
+        // Apply RSSI, in the range [-5, +5]
+        // after band adjustment, +n difference roughly corresponds to +10xn dBm
+        order = order + compareWifiConfigurationsRSSI(a, b, mCurrentConfigurationKey);
+
+        // If the configurations are not linked, compare by user's choice, only a
+        // very high RSSI difference can then override the choice
+        if (!linked) {
+            int choice;
+
+            choice = getConnectChoice(a, b);
+            if (choice > 0) {
+                // a is of higher priority - descending
+                order = order - choice;
+                if (VDBG) {
+                    logDbg("    compareWifiConfigurations prefers " + a.configKey()
+                            + " over " + b.configKey()
+                            + " due to user choice of " + choice
+                            + " order -> " + Integer.toString(order));
+                }
+            }
+
+            choice = getConnectChoice(b, a);
+            if (choice > 0) {
+                // a is of lower priority - ascending
+                order = order + choice;
+                if (VDBG) {
+                    logDbg("    compareWifiConfigurations prefers " + b.configKey() + " over "
+                            + a.configKey() + " due to user choice of " + choice
+                            + " order ->" + Integer.toString(order));
+                }
+            }
+        }
+
+        if (order == 0) {
+            // We don't know anything - pick the last seen i.e. K behavior
+            // we should do this only for recently picked configurations
+            if (a.priority > b.priority) {
+                // a is of higher priority - descending
+                if (VDBG) {
+                    logDbg("    compareWifiConfigurations prefers -1 " + a.configKey() + " over "
+                            + b.configKey() + " due to priority");
+                }
+
+                order = -1;
+            } else if (a.priority < b.priority) {
+                // a is of lower priority - ascending
+                if (VDBG) {
+                    logDbg("    compareWifiConfigurations prefers +1 " + b.configKey() + " over "
+                            + a.configKey() + " due to priority");
+                }
+                order = 1;
+            }
+        }
+
+        String sorder = " == ";
+        if (order > 0) {
+            sorder = " < ";
+        } else if (order < 0) {
+            sorder = " > ";
+        }
+
+        if (VDBG) {
+            logDbg("compareWifiConfigurations: " + a.configKey() + sorder
+                    + b.configKey() + " order " + Integer.toString(order));
+        }
+
+        return order;
+    }
+
+    boolean isBadCandidate(int rssi5, int rssi24) {
+        return (rssi5 < -80 && rssi24 < -90);
+    }
+
+    int compareWifiConfigurationsTop(WifiConfiguration a, WifiConfiguration b) {
+        int scorerOrder = compareWifiConfigurationsWithScorer(a, b);
+        int order = compareWifiConfigurations(a, b);
+
+        if (scorerOrder * order < 0) {
+            if (VDBG) {
+                logDbg("    -> compareWifiConfigurationsTop: " +
+                        "scorer override " + scorerOrder + " " + order);
+            }
+            // For debugging purpose, remember that an override happened
+            // during that autojoin Attempt
+            didOverride = true;
+            a.numScorerOverride++;
+            b.numScorerOverride++;
+        }
+
+        if (scorerOrder != 0) {
+            // If the scorer came up with a result then use the scorer's result, else use
+            // the order provided by the base comparison function
+            order = scorerOrder;
+        }
+        return order;
+    }
+
+    public int rssiBoostFrom5GHzRssi(int rssi, String dbg) {
+        if (!mWifiConfigStore.enable5GHzPreference) {
+            return 0;
+        }
+        if (rssi
+                > mWifiConfigStore.bandPreferenceBoostThreshold5) {
+            // Boost by 2 dB for each point
+            //    Start boosting at -65
+            //    Boost by 20 if above -55
+            //    Boost by 40 if abore -45
+            int boost = mWifiConfigStore.bandPreferenceBoostFactor5
+                    *(rssi - mWifiConfigStore.bandPreferenceBoostThreshold5);
+            if (boost > 50) {
+                // 50 dB boost is set so as to overcome the hysteresis of +20 plus a difference of
+                // 25 dB between 2.4 and 5GHz band. This allows jumping from 2.4 to 5GHz
+                // consistently
+                boost = 50;
+            }
+            if (VDBG && dbg != null) {
+                logDbg("        " + dbg + ":    rssi5 " + rssi + " boost " + boost);
+            }
+            return boost;
+        }
+
+        if (rssi
+                < mWifiConfigStore.bandPreferencePenaltyThreshold5) {
+            // penalize if < -75
+            int boost = mWifiConfigStore.bandPreferencePenaltyFactor5
+                    *(rssi - mWifiConfigStore.bandPreferencePenaltyThreshold5);
+            return boost;
+        }
+        return 0;
+    }
+        /**
+         * attemptRoam() function implements the core of the same SSID switching algorithm
+         *
+         * Run thru all recent scan result of a WifiConfiguration and select the
+         * best one.
+         */
+    public ScanResult attemptRoam(ScanResult a,
+                                  WifiConfiguration current, int age, String currentBSSID) {
+        if (current == null) {
+            if (VDBG)   {
+                logDbg("attemptRoam not associated");
+            }
+            return a;
+        }
+        if (current.scanResultCache == null) {
+            if (VDBG)   {
+                logDbg("attemptRoam no scan cache");
+            }
+            return a;
+        }
+        if (current.scanResultCache.size() > 6) {
+            if (VDBG)   {
+                logDbg("attemptRoam scan cache size "
+                        + current.scanResultCache.size() + " --> bail");
+            }
+            // Implement same SSID roaming only for configurations
+            // that have less than 4 BSSIDs
+            return a;
+        }
+
+        if (current.BSSID != null && !current.BSSID.equals("any")) {
+            if (DBG)   {
+                logDbg("attemptRoam() BSSID is set "
+                        + current.BSSID + " -> bail");
+            }
+            return a;
+        }
+
+        // Determine which BSSID we want to associate to, taking account
+        // relative strength of 5 and 2.4 GHz BSSIDs
+        long nowMs = System.currentTimeMillis();
+
+        for (ScanResult b : current.scanResultCache.values()) {
+            int bRssiBoost5 = 0;
+            int aRssiBoost5 = 0;
+            int bRssiBoost = 0;
+            int aRssiBoost = 0;
+            if ((b.seen == 0) || (b.BSSID == null)
+                    || ((nowMs - b.seen) > age)
+                    || b.autoJoinStatus != ScanResult.ENABLED
+                    || b.numIpConfigFailures > 8) {
+                continue;
+            }
+
+            // Pick first one
+            if (a == null) {
+                a = b;
+                continue;
+            }
+
+            if (b.numIpConfigFailures < (a.numIpConfigFailures - 1)) {
+                // Prefer a BSSID that doesn't have less number of Ip config failures
+                logDbg("attemptRoam: "
+                        + b.BSSID + " rssi=" + b.level + " ipfail=" +b.numIpConfigFailures
+                        + " freq=" + b.frequency
+                        + " > "
+                        + a.BSSID + " rssi=" + a.level + " ipfail=" +a.numIpConfigFailures
+                        + " freq=" + a.frequency);
+                a = b;
+                continue;
+            }
+
+            // Apply hysteresis: we favor the currentBSSID by giving it a boost
+            if (currentBSSID != null && currentBSSID.equals(b.BSSID)) {
+                // Reduce the benefit of hysteresis if RSSI <= -75
+                if (b.level <= mWifiConfigStore.bandPreferencePenaltyThreshold5) {
+                    bRssiBoost = mWifiConfigStore.associatedHysteresisLow;
+                } else {
+                    bRssiBoost = mWifiConfigStore.associatedHysteresisHigh;
+                }
+            }
+            if (currentBSSID != null && currentBSSID.equals(a.BSSID)) {
+                if (a.level <= mWifiConfigStore.bandPreferencePenaltyThreshold5) {
+                    // Reduce the benefit of hysteresis if RSSI <= -75
+                    aRssiBoost = mWifiConfigStore.associatedHysteresisLow;
+                } else {
+                    aRssiBoost = mWifiConfigStore.associatedHysteresisHigh;
+                }
+            }
+
+            // Favor 5GHz: give a boost to 5GHz BSSIDs, with a slightly progressive curve
+            //   Boost the BSSID if it is on 5GHz, above a threshold
+            //   But penalize it if it is on 5GHz and below threshold
+            //
+            //   With he current threshold values, 5GHz network with RSSI above -55
+            //   Are given a boost of 30DB which is enough to overcome the current BSSID
+            //   hysteresis (+14) plus 2.4/5 GHz signal strength difference on most cases
+            //
+            // The "current BSSID" Boost must be added to the BSSID's level so as to introduce\
+            // soem amount of hysteresis
+            if (b.is5GHz()) {
+                bRssiBoost5 = rssiBoostFrom5GHzRssi(b.level + bRssiBoost, b.BSSID);
+            }
+            if (a.is5GHz()) {
+                aRssiBoost5 = rssiBoostFrom5GHzRssi(a.level + aRssiBoost, a.BSSID);
+            }
+
+            if (VDBG)  {
+                String comp = " < ";
+                if (b.level + bRssiBoost + bRssiBoost5 > a.level +aRssiBoost + aRssiBoost5) {
+                    comp = " > ";
+                }
+                logDbg("attemptRoam: "
+                        + b.BSSID + " rssi=" + b.level + " boost=" + Integer.toString(bRssiBoost)
+                        + "/" + Integer.toString(bRssiBoost5) + " freq=" + b.frequency
+                        + comp
+                        + a.BSSID + " rssi=" + a.level + " boost=" + Integer.toString(aRssiBoost)
+                        + "/" + Integer.toString(aRssiBoost5) + " freq=" + a.frequency);
+            }
+
+            // Compare the RSSIs after applying the hysteresis boost and the 5GHz
+            // boost if applicable
+            if (b.level + bRssiBoost + bRssiBoost5 > a.level +aRssiBoost + aRssiBoost5) {
+                // b is the better BSSID
+                a = b;
+            }
+        }
+        if (a != null) {
+            if (VDBG)  {
+                StringBuilder sb = new StringBuilder();
+                sb.append("attemptRoam: " + current.configKey() +
+                        " Found " + a.BSSID + " rssi=" + a.level + " freq=" + a.frequency);
+                if (currentBSSID != null) {
+                    sb.append(" Current: " + currentBSSID);
+                }
+                sb.append("\n");
+                logDbg(sb.toString());
+            }
+        }
+        return a;
+    }
+
+    /**
+     * getNetworkScore()
+     *
+     * if scorer is present, get the network score of a WifiConfiguration
+     *
+     * Note: this should be merge with setVisibility
+     *
+     * @param config
+     * @return score
+     */
+    int getConfigNetworkScore(WifiConfiguration config, int age, int rssiBoost) {
+
+        if (mNetworkScoreCache == null) {
+            if (VDBG) {
+                logDbg("       getConfigNetworkScore for " + config.configKey()
+                        + "  -> no scorer, hence no scores");
+            }
+            return WifiNetworkScoreCache.INVALID_NETWORK_SCORE;
+        }
+        if (config.scanResultCache == null) {
+            if (VDBG) {
+                logDbg("       getConfigNetworkScore for " + config.configKey()
+                        + " -> no scan cache");
+            }
+            return WifiNetworkScoreCache.INVALID_NETWORK_SCORE;
+        }
+
+        // Get current date
+        long nowMs = System.currentTimeMillis();
+
+        int startScore = -10000;
+
+        // Run thru all cached scan results
+        for (ScanResult result : config.scanResultCache.values()) {
+            if ((nowMs - result.seen) < age) {
+                int sc = mNetworkScoreCache.getNetworkScore(result, rssiBoost);
+                if (sc > startScore) {
+                    startScore = sc;
+                }
+            }
+        }
+        if (startScore == -10000) {
+            startScore = WifiNetworkScoreCache.INVALID_NETWORK_SCORE;
+        }
+        if (VDBG) {
+            if (startScore == WifiNetworkScoreCache.INVALID_NETWORK_SCORE) {
+                logDbg("    getConfigNetworkScore for " + config.configKey()
+                        + " -> no available score");
+            } else {
+                logDbg("    getConfigNetworkScore for " + config.configKey()
+                        + " boost=" + Integer.toString(rssiBoost)
+                        + " score = " + Integer.toString(startScore));
+            }
+        }
+
+        return startScore;
+    }
+
+    void handleBSSIDBlackList(boolean enable, String bssid, int reason) {
+        if( 5 == reason ) // Enable Auto Join for all BSSIDs
+        {
+            mBlacklistedBssids.clear();
+            return;
+        }
+        if( !enable ) {
+            if( !mBlacklistedBssids.contains(bssid) )
+            {
+                mBlacklistedBssids.add(bssid);
+            }
+        }
+        else {
+            if( mBlacklistedBssids.contains(bssid) ) {
+                mBlacklistedBssids.remove(bssid);
+            }
+        }
+    }
+
+    boolean isBlacklistedBSSID( String bssid ) {
+        return ( mBlacklistedBssids.contains(bssid) ) ? true : false;
+    }
+
+    /**
+     * attemptAutoJoin() function implements the core of the a network switching algorithm
+     */
+    void attemptAutoJoin() {
+        didOverride = false;
+        didBailDueToWeakRssi = false;
+        int networkSwitchType = AUTO_JOIN_IDLE;
+
+        String lastSelectedConfiguration = mWifiConfigStore.getLastSelectedConfiguration();
+
+        // Reset the currentConfiguration Key, and set it only if WifiStateMachine and
+        // supplicant agree
+        mCurrentConfigurationKey = null;
+        WifiConfiguration currentConfiguration = mWifiStateMachine.getCurrentWifiConfiguration();
+
+        WifiConfiguration candidate = null;
+
+        // Obtain the subset of recently seen networks
+        List<WifiConfiguration> list = mWifiConfigStore.getRecentConfiguredNetworks(3000, false);
+        if (list == null) {
+            if (VDBG)  logDbg("attemptAutoJoin nothing known=" +
+                    mWifiConfigStore.getconfiguredNetworkSize());
+            return;
+        }
+
+        // Find the currently connected network: ask the supplicant directly
+        String val = mWifiNative.status(true);
+        String status[] = val.split("\\r?\\n");
+        if (VDBG) {
+            logDbg("attemptAutoJoin() status=" + val + " split="
+                    + Integer.toString(status.length));
+        }
+
+        int supplicantNetId = -1;
+        for (String key : status) {
+            if (key.regionMatches(0, "id=", 0, 3)) {
+                int idx = 3;
+                supplicantNetId = 0;
+                while (idx < key.length()) {
+                    char c = key.charAt(idx);
+
+                    if ((c >= 0x30) && (c <= 0x39)) {
+                        supplicantNetId *= 10;
+                        supplicantNetId += c - 0x30;
+                        idx++;
+                    } else {
+                        break;
+                    }
+                }
+            } else if (key.contains("wpa_state=ASSOCIATING")
+                    || key.contains("wpa_state=ASSOCIATED")
+                    || key.contains("wpa_state=FOUR_WAY_HANDSHAKE")
+                    || key.contains("wpa_state=GROUP_KEY_HANDSHAKE")) {
+                if (DBG) {
+                    logDbg("attemptAutoJoin: bail out due to sup state " + key);
+                }
+                // After WifiStateMachine ask the supplicant to associate or reconnect
+                // we might still obtain scan results from supplicant
+                // however the supplicant state in the mWifiInfo and supplicant state tracker
+                // are updated when we get the supplicant state change message which can be
+                // processed after the SCAN_RESULT message, so at this point the framework doesn't
+                // know that supplicant is ASSOCIATING.
+                // A good fix for this race condition would be for the WifiStateMachine to add
+                // a new transient state where it expects to get the supplicant message indicating
+                // that it started the association process and within which critical operations
+                // like autojoin should be deleted.
+
+                // This transient state would remove the need for the roam Wathchdog which
+                // basically does that.
+
+                // At the moment, we just query the supplicant state synchronously with the
+                // mWifiNative.status() command, which allow us to know that
+                // supplicant has started association process, even though we didnt yet get the
+                // SUPPLICANT_STATE_CHANGE message.
+                return;
+            }
+        }
+        if (DBG) {
+            String conf = "";
+            String last = "";
+            if (currentConfiguration != null) {
+                conf = " current=" + currentConfiguration.configKey();
+            }
+            if (lastSelectedConfiguration != null) {
+                last = " last=" + lastSelectedConfiguration;
+            }
+            logDbg("attemptAutoJoin() num recent config " + Integer.toString(list.size())
+                    + conf + last
+                    + " ---> suppNetId=" + Integer.toString(supplicantNetId));
+        }
+
+        if (currentConfiguration != null) {
+            if (supplicantNetId != currentConfiguration.networkId
+                    //https://b.corp.google.com/issue?id=16484607
+                    //mark this confition as an error only if the mismatched networkId are valid
+                    && supplicantNetId != WifiConfiguration.INVALID_NETWORK_ID
+                    && currentConfiguration.networkId != WifiConfiguration.INVALID_NETWORK_ID) {
+                logDbg("attemptAutoJoin() ERROR wpa_supplicant out of sync nid="
+                        + Integer.toString(supplicantNetId) + " WifiStateMachineWAP="
+                        + Integer.toString(currentConfiguration.networkId));
+                mWifiStateMachine.disconnectCommand();
+                return;
+            } else {
+                mCurrentConfigurationKey = currentConfiguration.configKey();
+            }
+        } else {
+            if (supplicantNetId != WifiConfiguration.INVALID_NETWORK_ID) {
+                // Maybe in the process of associating, skip this attempt
+                return;
+            }
+        }
+
+        int currentNetId = -1;
+        if (currentConfiguration != null) {
+            // If we are associated to a configuration, it will
+            // be compared thru the compareNetwork function
+            currentNetId = currentConfiguration.networkId;
+        }
+
+        /**
+         * Run thru all visible configurations without looking at the one we
+         * are currently associated to
+         * select Best Network candidate from known WifiConfigurations
+         */
+        for (WifiConfiguration config : list) {
+            if (config.SSID == null) {
+                continue;
+            }
+
+            if ( this.isBlacklistedBSSID(config.BSSID) ) {
+                logDbg("attemptAutoJoin skip candidate as AP is Blacklisted config.SSID = "
+                        + config.SSID + " config.BSSID=" + config.BSSID);
+                continue;
+            }
+
+            if (config.autoJoinStatus >=
+                    WifiConfiguration.AUTO_JOIN_DISABLED_ON_AUTH_FAILURE) {
+                // Avoid networks disabled because of AUTH failure altogether
+                if (DBG) {
+                    logDbg("attemptAutoJoin skip candidate due to auto join status "
+                            + Integer.toString(config.autoJoinStatus) + " key "
+                            + config.configKey(true)
+                    + " reason " + config.disableReason);
+                }
+                continue;
+            }
+
+            // Try to un-blacklist based on elapsed time
+            if (config.blackListTimestamp > 0) {
+                long now = System.currentTimeMillis();
+                if (now < config.blackListTimestamp) {
+                    /**
+                     * looks like there was a change in the system clock since we black listed, and
+                     * timestamp is not meaningful anymore, hence lose it.
+                     * this event should be rare enough so that we still want to lose the black list
+                     */
+                    config.setAutoJoinStatus(WifiConfiguration.AUTO_JOIN_ENABLED);
+                } else {
+                    if ((now - config.blackListTimestamp) > loseBlackListHardMilli) {
+                        // Reenable it after 18 hours, i.e. next day
+                        config.setAutoJoinStatus(WifiConfiguration.AUTO_JOIN_ENABLED);
+                    } else if ((now - config.blackListTimestamp) > loseBlackListSoftMilli) {
+                        // Lose blacklisting due to bad link
+                        config.setAutoJoinStatus(config.autoJoinStatus - 8);
+                    }
+                }
+            }
+
+            // Try to unblacklist based on good visibility
+            if (config.visibility.rssi5 < mWifiConfigStore.thresholdUnblacklistThreshold5Soft
+                    && config.visibility.rssi24
+                    < mWifiConfigStore.thresholdUnblacklistThreshold24Soft) {
+                if (DBG) {
+                    logDbg("attemptAutoJoin do not unblacklist due to low visibility "
+                            + config.autoJoinStatus
+                            + " key " + config.configKey(true)
+                            + " rssi=(" + config.visibility.rssi24
+                            + "," + config.visibility.rssi5
+                            + ") num=(" + config.visibility.num24
+                            + "," + config.visibility.num5 + ")");
+                }
+            } else if (config.visibility.rssi5 < mWifiConfigStore.thresholdUnblacklistThreshold5Hard
+                    && config.visibility.rssi24
+                    < mWifiConfigStore.thresholdUnblacklistThreshold24Hard) {
+                // If the network is simply temporary disabled, don't allow reconnect until
+                // RSSI becomes good enough
+                config.setAutoJoinStatus(config.autoJoinStatus - 1);
+                if (DBG) {
+                    logDbg("attemptAutoJoin good candidate seen, bumped soft -> status="
+                            + config.autoJoinStatus
+                            + " " + config.configKey(true) + " rssi=("
+                            + config.visibility.rssi24 + "," + config.visibility.rssi5
+                            + ") num=(" + config.visibility.num24
+                            + "," + config.visibility.num5 + ")");
+                }
+            } else {
+                config.setAutoJoinStatus(config.autoJoinStatus - 3);
+                if (DBG) {
+                    logDbg("attemptAutoJoin good candidate seen, bumped hard -> status="
+                            + config.autoJoinStatus
+                            + " " + config.configKey(true) + " rssi=("
+                            + config.visibility.rssi24 + "," + config.visibility.rssi5
+                            + ") num=(" + config.visibility.num24
+                            + "," + config.visibility.num5 + ")");
+                }
+            }
+
+            if (config.autoJoinStatus >=
+                    WifiConfiguration.AUTO_JOIN_TEMPORARY_DISABLED) {
+                // Network is blacklisted, skip
+                if (DBG) {
+                    logDbg("attemptAutoJoin skip blacklisted -> status="
+                            + config.autoJoinStatus
+                            + " " + config.configKey(true) + " rssi=("
+                            + config.visibility.rssi24 + "," + config.visibility.rssi5
+                            + ") num=(" + config.visibility.num24
+                            + "," + config.visibility.num5 + ")");
+                }
+                continue;
+            }
+            if (config.networkId == currentNetId) {
+                if (DBG) {
+                    logDbg("attemptAutoJoin skip current candidate  "
+                            + Integer.toString(currentNetId)
+                            + " key " + config.configKey(true));
+                }
+                continue;
+            }
+
+            boolean isLastSelected = false;
+            if (lastSelectedConfiguration != null &&
+                    config.configKey().equals(lastSelectedConfiguration)) {
+                isLastSelected = true;
+            }
+
+            if (config.visibility == null) {
+                continue;
+            }
+            int boost = config.autoJoinUseAggressiveJoinAttemptThreshold + weakRssiBailCount;
+            if ((config.visibility.rssi5 + boost)
+                        < mWifiConfigStore.thresholdInitialAutoJoinAttemptMin5RSSI
+                        && (config.visibility.rssi24 + boost)
+                        < mWifiConfigStore.thresholdInitialAutoJoinAttemptMin24RSSI) {
+                if (DBG) {
+                    logDbg("attemptAutoJoin skip due to low visibility -> status="
+                            + config.autoJoinStatus
+                            + " key " + config.configKey(true) + " rssi="
+                            + config.visibility.rssi24 + ", " + config.visibility.rssi5
+                            + " num=" + config.visibility.num24
+                            + ", " + config.visibility.num5);
+                }
+
+                // Don't try to autojoin a network that is too far but
+                // If that configuration is a user's choice however, try anyway
+                if (!isLastSelected) {
+                    config.autoJoinBailedDueToLowRssi = true;
+                    didBailDueToWeakRssi = true;
+                    continue;
+                } else {
+                    // Next time, try to be a bit more aggressive in auto-joining
+                    if (config.autoJoinUseAggressiveJoinAttemptThreshold
+                            < WifiConfiguration.MAX_INITIAL_AUTO_JOIN_RSSI_BOOST
+                            && config.autoJoinBailedDueToLowRssi) {
+                        config.autoJoinUseAggressiveJoinAttemptThreshold += 4;
+                    }
+                }
+            }
+            if (config.noInternetAccess && !isLastSelected) {
+                // Avoid autojoining this network because last time we used it, it didn't
+                // have internet access
+                if (DBG) {
+                    logDbg("attemptAutoJoin skip candidate due to noInternetAccess flag "
+                            + config.configKey(true));
+                }
+                continue;
+            }
+
+            if (DBG) {
+                String cur = "";
+                if (candidate != null) {
+                    cur = " current candidate " + candidate.configKey();
+                }
+                logDbg("attemptAutoJoin trying id="
+                        + Integer.toString(config.networkId) + " "
+                        + config.configKey(true)
+                        + " status=" + config.autoJoinStatus
+                        + cur);
+            }
+
+            if (candidate == null) {
+                candidate = config;
+            } else {
+                if (VDBG)  {
+                    logDbg("attemptAutoJoin will compare candidate  " + candidate.configKey()
+                            + " with " + config.configKey());
+                }
+                int order = compareWifiConfigurationsTop(candidate, config);
+
+                // The lastSelectedConfiguration is the configuration the user has manually selected
+                // thru WifiPicker, or that a 3rd party app asked us to connect to via the
+                // enableNetwork with disableOthers=true WifiManager API
+                // As this is a direct user choice, we strongly prefer this configuration,
+                // hence give +/-100
+                if ((lastSelectedConfiguration != null)
+                        && candidate.configKey().equals(lastSelectedConfiguration)) {
+                    // candidate is the last selected configuration,
+                    // so keep it above connect choices (+/-60) and
+                    // above RSSI/scorer based selection of linked configuration (+/- 50)
+                    // by reducing order by -100
+                    order = order - 100;
+                    if (VDBG)   {
+                        logDbg("     ...and prefers -100 " + candidate.configKey()
+                                + " over " + config.configKey()
+                                + " because it is the last selected -> "
+                                + Integer.toString(order));
+                    }
+                } else if ((lastSelectedConfiguration != null)
+                        && config.configKey().equals(lastSelectedConfiguration)) {
+                    // config is the last selected configuration,
+                    // so keep it above connect choices (+/-60) and
+                    // above RSSI/scorer based selection of linked configuration (+/- 50)
+                    // by increasing order by +100
+                    order = order + 100;
+                    if (VDBG)   {
+                        logDbg("     ...and prefers +100 " + config.configKey()
+                                + " over " + candidate.configKey()
+                                + " because it is the last selected -> "
+                                + Integer.toString(order));
+                    }
+                }
+
+                if (order > 0) {
+                    // Ascending : candidate < config
+                    candidate = config;
+                }
+            }
+        }
+
+        // Wait for VPN to be available on the system to make use of this code
+        // Now, go thru scan result to try finding a better untrusted network
+        if (mNetworkScoreCache != null) {
+            int rssi5 = WifiConfiguration.INVALID_RSSI;
+            int rssi24 = WifiConfiguration.INVALID_RSSI;
+            WifiConfiguration.Visibility visibility;
+            if (candidate != null) {
+                rssi5 = candidate.visibility.rssi5;
+                rssi24 = candidate.visibility.rssi24;
+            }
+
+            // Get current date
+            long nowMs = System.currentTimeMillis();
+            int currentScore = -10000;
+            // The untrusted network with highest score
+            ScanResult untrustedCandidate = null;
+            // Look for untrusted scored network only if the current candidate is bad
+            if (isBadCandidate(rssi24, rssi5)) {
+                for (ScanResult result : scanResultCache.values()) {
+                    int rssiBoost = 0;
+                    // We look only at untrusted networks with a valid SSID
+                    // A trusted result would have been looked at thru it's Wificonfiguration
+                    if (TextUtils.isEmpty(result.SSID) || !result.untrusted) {
+                        continue;
+                    }
+                    if ((nowMs - result.seen) < 3000) {
+                        // Increment usage count for the network
+                        mWifiConnectionStatistics.incrementOrAddUntrusted(result.SSID, 0, 1);
+
+                        if (lastUntrustedBSSID != null
+                                && result.BSSID.equals(lastUntrustedBSSID)) {
+                            // Apply a large hysteresis to the untrusted network we are connected to
+                            rssiBoost = 25;
+                        }
+                        int score = mNetworkScoreCache.getNetworkScore(result, rssiBoost);
+                        if (score != WifiNetworkScoreCache.INVALID_NETWORK_SCORE
+                                && score > currentScore) {
+                            // Highest score: Select this candidate
+                            currentScore = score;
+                            untrustedCandidate = result;
+                            if (VDBG) {
+                                logDbg("AutoJoinController: found untrusted candidate "
+                                        + result.SSID
+                                + " RSSI=" + result.level
+                                + " freq=" + result.frequency
+                                + " score=" + score);
+                            }
+                        }
+                    }
+                }
+            }
+            if (untrustedCandidate != null) {
+                if (lastUntrustedBSSID == null
+                        || !untrustedCandidate.SSID.equals(lastUntrustedBSSID)) {
+                    // We found a new candidate that we are going to connect to, then
+                    // increase its connection count
+                    mWifiConnectionStatistics.
+                            incrementOrAddUntrusted(untrustedCandidate.SSID, 1, 0);
+                    // Remember which SSID we are connecting to
+                    lastUntrustedBSSID = untrustedCandidate.SSID;
+                }
+            }
+            // Now we don't have VPN, and thus don't actually connect to the untrusted candidate
+            untrustedCandidate = null;
+        }
+
+        long lastUnwanted =
+                System.currentTimeMillis()
+                        - mWifiConfigStore.lastUnwantedNetworkDisconnectTimestamp;
+        if (candidate == null
+                && lastSelectedConfiguration == null
+                && currentConfiguration == null
+                && didBailDueToWeakRssi
+                && (mWifiConfigStore.lastUnwantedNetworkDisconnectTimestamp == 0
+                    || lastUnwanted > (1000 * 60 * 60 * 24 * 7))
+                ) {
+            // We are bailing out of autojoin although we are seeing a weak configuration, and
+            // - we didn't find another valid candidate
+            // - we are not connected
+            // - without a user network selection choice
+            // - ConnectivityService has not triggered an unwanted network disconnect
+            //       on this device for a week (hence most likely there is no SIM card or cellular)
+            // If all those conditions are met, then boost the RSSI of the weak networks
+            // that we are seeing so as we will eventually pick one
+            if (weakRssiBailCount < 10)
+                weakRssiBailCount += 1;
+        } else {
+            if (weakRssiBailCount > 0)
+                weakRssiBailCount -= 1;
+        }
+
+        /**
+         *  If candidate is found, check the state of the connection so as
+         *  to decide if we should be acting on this candidate and switching over
+         */
+        int networkDelta = compareNetwork(candidate, lastSelectedConfiguration);
+        if (DBG && candidate != null) {
+            String doSwitch = "";
+            String current = "";
+            if (networkDelta < 0) {
+                doSwitch = " -> not switching";
+            }
+            if (currentConfiguration != null) {
+                current = " with current " + currentConfiguration.configKey();
+            }
+            logDbg("attemptAutoJoin networkSwitching candidate "
+                    + candidate.configKey()
+                    + current
+                    + " linked=" + (currentConfiguration != null
+                            && currentConfiguration.isLinked(candidate))
+                    + " : delta="
+                    + Integer.toString(networkDelta) + " "
+                    + doSwitch);
+        }
+
+        /**
+         * Ask WifiStateMachine permission to switch :
+         * if user is currently streaming voice traffic,
+         * then we should not be allowed to switch regardless of the delta
+         */
+        if (mWifiStateMachine.shouldSwitchNetwork(networkDelta)) {
+            if (mStaStaSupported) {
+                logDbg("mStaStaSupported --> error do nothing now ");
+            } else {
+                if (currentConfiguration != null && currentConfiguration.isLinked(candidate)) {
+                    networkSwitchType = AUTO_JOIN_EXTENDED_ROAMING;
+                } else {
+                    networkSwitchType = AUTO_JOIN_OUT_OF_NETWORK_ROAMING;
+                }
+                if (DBG) {
+                    logDbg("AutoJoin auto connect with netId "
+                            + Integer.toString(candidate.networkId)
+                            + " to " + candidate.configKey());
+                }
+                if (didOverride) {
+                    candidate.numScorerOverrideAndSwitchedNetwork++;
+                }
+                candidate.numAssociation++;
+                mWifiConnectionStatistics.numAutoJoinAttempt++;
+
+                if (candidate.BSSID == null || candidate.BSSID.equals("any")) {
+                    // First step we selected the configuration we want to connect to
+                    // Second step: Look for the best Scan result for this configuration
+                    // TODO this algorithm should really be done in one step
+                    String currentBSSID = mWifiStateMachine.getCurrentBSSID();
+                    ScanResult roamCandidate = attemptRoam(null, candidate, 3000, null);
+                    if (roamCandidate != null && currentBSSID != null
+                            && currentBSSID.equals(roamCandidate.BSSID)) {
+                        // Sanity, we were already asociated to that candidate
+                        roamCandidate = null;
+                    }
+                    if (roamCandidate != null && roamCandidate.is5GHz()) {
+                        // If the configuration hasn't a default BSSID selected, and the best
+                        // candidate is 5GHZ, then select this candidate so as WifiStateMachine and
+                        // supplicant will pick it first
+                        candidate.autoJoinBSSID = roamCandidate.BSSID;
+                        if (VDBG) {
+                            logDbg("AutoJoinController: lock to 5GHz "
+                                    + candidate.autoJoinBSSID
+                                    + " RSSI=" + roamCandidate.level
+                                    + " freq=" + roamCandidate.frequency);
+                        }
+                    } else {
+                        // We couldnt find a roam candidate
+                        candidate.autoJoinBSSID = "any";
+                    }
+                }
+                mWifiStateMachine.sendMessage(WifiStateMachineWAP.CMD_AUTO_CONNECT,
+                            candidate.networkId, networkSwitchType, candidate);
+            }
+        }
+
+        if (networkSwitchType == AUTO_JOIN_IDLE) {
+            String currentBSSID = mWifiStateMachine.getCurrentBSSID();
+            // Attempt same WifiConfiguration roaming
+            ScanResult roamCandidate = attemptRoam(null, currentConfiguration, 3000,
+                    currentBSSID);
+            /**
+             *  TODO: (post L initial release)
+             *  consider handling linked configurations roaming (i.e. extended Roaming)
+             *  thru the attemptRoam function which makes use of the RSSI roaming threshold.
+             *  At the moment, extended roaming is only handled thru the attemptAutoJoin()
+             *  function which compare configurations.
+             *
+             *  The advantage of making use of attemptRoam function is that this function
+             *  will looks at all the BSSID of each configurations, instead of only looking
+             *  at WifiConfiguration.visibility which keeps trackonly of the RSSI/band of the
+             *  two highest BSSIDs.
+             */
+            // Attempt linked WifiConfiguration roaming
+            /* if (currentConfiguration != null
+                    && currentConfiguration.linkedConfigurations != null) {
+                for (String key : currentConfiguration.linkedConfigurations.keySet()) {
+                    WifiConfiguration link = mWifiConfigStore.getWifiConfiguration(key);
+                    if (link != null) {
+                        roamCandidate = attemptRoam(roamCandidate, link, 3000,
+                                currentBSSID);
+                    }
+                }
+            }*/
+            if (roamCandidate != null && currentBSSID != null
+                    && currentBSSID.equals(roamCandidate.BSSID)) {
+                roamCandidate = null;
+            }
+            if (roamCandidate != null && mWifiStateMachine.shouldSwitchNetwork(999)) {
+                if (DBG) {
+                    logDbg("AutoJoin auto roam with netId "
+                            + Integer.toString(currentConfiguration.networkId)
+                            + " " + currentConfiguration.configKey() + " to BSSID="
+                            + roamCandidate.BSSID + " freq=" + roamCandidate.frequency
+                            + " RSSI=" + roamCandidate.level);
+                }
+                networkSwitchType = AUTO_JOIN_ROAMING;
+                mWifiConnectionStatistics.numAutoRoamAttempt++;
+
+                mWifiStateMachine.sendMessage(WifiStateMachineWAP.CMD_AUTO_ROAM,
+                            currentConfiguration.networkId, 1, roamCandidate);
+            }
+        }
+        if (VDBG) logDbg("Done attemptAutoJoin status=" + Integer.toString(networkSwitchType));
+    }
+}
+
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiController.java
@@ -37,6 +37,7 @@
 import android.os.Message;
 import android.os.SystemClock;
 import android.os.WorkSource;
+import android.os.ServiceManager;
 import android.provider.Settings;
 import android.util.Slog;
 
@@ -161,7 +162,6 @@
         log("isAirplaneModeOn = " + isAirplaneModeOn +
                 ", isWifiEnabled = " + isWifiEnabled +
                 ", isScanningAvailable = " + isScanningAlwaysAvailable);
-
         if (isScanningAlwaysAvailable) {
             setInitialState(mStaDisabledWithScanState);
         } else {
@@ -472,6 +472,8 @@
     class StaEnabledState extends State {
         @Override
         public void enter() {
+            WifiServiceImpl wifiImpl = (WifiServiceImpl)ServiceManager.getService(Context.WIFI_SERVICE);
+            wifiImpl.clearWifiEnabling();
             mWifiStateMachine.setSupplicantRunning(true);
         }
         @Override
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiControllerWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiControllerWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiControllerWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiControllerWAP.java
@@ -0,0 +1,757 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManagerWAP;
+import static android.net.wifi.WifiManagerWAP.WIFI_MODE_FULL;
+import static android.net.wifi.WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF;
+import static android.net.wifi.WifiManagerWAP.WIFI_MODE_SCAN_ONLY;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_ENABLED;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_ENABLING;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.SystemClock;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.util.Slog;
+
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+import com.android.server.wifi.WifiServiceImplWAP.LockList;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+class WifiControllerWAP extends StateMachine {
+    private static final String TAG = "WifiControllerWAP";
+    private static final boolean DBG = false;
+    private Context mContext;
+    private boolean mScreenOff;
+    private boolean mDeviceIdle;
+    private int mPluggedType;
+    private int mStayAwakeConditions;
+    private long mIdleMillis;
+    private int mSleepPolicy;
+    private boolean mFirstUserSignOnSeen = false;
+
+    private AlarmManager mAlarmManager;
+    private PendingIntent mIdleIntent;
+    private static final int IDLE_REQUEST = 0;
+
+    /**
+     * See {@link Settings.Global#WIFI_IDLE_MS}. This is the default value if a
+     * Settings.Global value is not present. This timeout value is chosen as
+     * the approximate point at which the battery drain caused by Wi-Fi
+     * being enabled but not active exceeds the battery drain caused by
+     * re-establishing a connection to the mobile data network.
+     */
+    private static final long DEFAULT_IDLE_MS = 15 * 60 * 1000; /* 15 minutes */
+
+    /**
+     * See {@link Settings.Global#WIFI_REENABLE_DELAY_MS}.  This is the default value if a
+     * Settings.Global value is not present.  This is the minimum time after wifi is disabled
+     * we'll act on an enable.  Enable requests received before this delay will be deferred.
+     */
+    private static final long DEFAULT_REENABLE_DELAY_MS = 500;
+
+    // finding that delayed messages can sometimes be delivered earlier than expected
+    // probably rounding errors..  add a margin to prevent problems
+    private static final long DEFER_MARGIN_MS = 5;
+
+    NetworkInfo mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_WIFI_WAP, 0, "WIFIWAP", "");
+
+    private static final String ACTION_DEVICE_IDLE =
+            "com.android.server.WifiManagerWAP.action.DEVICE_IDLE";
+
+    /* References to values tracked in WifiService */
+    final WifiStateMachineWAP mWifiStateMachine;
+    final WifiSettingsStoreWAP mSettingsStore;
+    final LockList mLocks;
+
+    /**
+     * Temporary for computing UIDS that are responsible for starting WIFI.
+     * Protected by mWifiStateTracker lock.
+     */
+    private final WorkSource mTmpWorkSource = new WorkSource();
+    private long mReEnableDelayMillis;
+
+    private static final int BASE = Protocol.BASE_WIFI_CONTROLLER;
+
+    static final int CMD_EMERGENCY_MODE_CHANGED     = BASE + 1;
+    static final int CMD_SCREEN_ON                  = BASE + 2;
+    static final int CMD_SCREEN_OFF                 = BASE + 3;
+    static final int CMD_BATTERY_CHANGED            = BASE + 4;
+    static final int CMD_DEVICE_IDLE                = BASE + 5;
+    static final int CMD_LOCKS_CHANGED              = BASE + 6;
+    static final int CMD_SCAN_ALWAYS_MODE_CHANGED   = BASE + 7;
+    static final int CMD_WIFI_TOGGLED               = BASE + 8;
+    static final int CMD_AIRPLANE_TOGGLED           = BASE + 9;
+    static final int CMD_SET_AP                     = BASE + 10;
+    static final int CMD_DEFERRED_TOGGLE            = BASE + 11;
+    static final int CMD_USER_PRESENT               = BASE + 12;
+
+    private DefaultState mDefaultState = new DefaultState();
+    private StaEnabledState mStaEnabledState = new StaEnabledState();
+    private ApStaDisabledState mApStaDisabledState = new ApStaDisabledState();
+    private StaDisabledWithScanState mStaDisabledWithScanState = new StaDisabledWithScanState();
+    private ApEnabledState mApEnabledState = new ApEnabledState();
+    private DeviceActiveState mDeviceActiveState = new DeviceActiveState();
+    private DeviceInactiveState mDeviceInactiveState = new DeviceInactiveState();
+    private ScanOnlyLockHeldState mScanOnlyLockHeldState = new ScanOnlyLockHeldState();
+    private FullLockHeldState mFullLockHeldState = new FullLockHeldState();
+    private FullHighPerfLockHeldState mFullHighPerfLockHeldState = new FullHighPerfLockHeldState();
+    private NoLockHeldState mNoLockHeldState = new NoLockHeldState();
+    private EcmState mEcmState = new EcmState();
+
+    WifiControllerWAP(Context context, WifiServiceImplWAP service, Looper looper) {
+        super(TAG, looper);
+        mContext = context;
+        mWifiStateMachine = service.mWifiStateMachine;
+        mSettingsStore = service.mSettingsStore;
+        mLocks = service.mLocks;
+    
+        mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
+        Intent idleIntent = new Intent(ACTION_DEVICE_IDLE, null);
+        mIdleIntent = PendingIntent.getBroadcast(mContext, IDLE_REQUEST, idleIntent, 0);
+
+        addState(mDefaultState);
+            addState(mApStaDisabledState, mDefaultState);
+            addState(mStaEnabledState, mDefaultState);
+                addState(mDeviceActiveState, mStaEnabledState);
+                addState(mDeviceInactiveState, mStaEnabledState);
+                    addState(mScanOnlyLockHeldState, mDeviceInactiveState);
+                    addState(mFullLockHeldState, mDeviceInactiveState);
+                    addState(mFullHighPerfLockHeldState, mDeviceInactiveState);
+                    addState(mNoLockHeldState, mDeviceInactiveState);
+            addState(mStaDisabledWithScanState, mDefaultState);
+            addState(mApEnabledState, mDefaultState);
+            addState(mEcmState, mDefaultState);
+
+        boolean isAirplaneModeOn = mSettingsStore.isAirplaneModeOn();
+        boolean isWifiEnabled = mSettingsStore.isWifiToggleEnabled();
+        boolean isScanningAlwaysAvailable = mSettingsStore.isScanAlwaysAvailable();
+
+        log("isAirplaneModeOn = " + isAirplaneModeOn +
+                ", isWifiEnabled = " + isWifiEnabled +
+                ", isScanningAvailable = " + isScanningAlwaysAvailable);
+        if (isScanningAlwaysAvailable) {
+            setInitialState(mStaDisabledWithScanState);
+        } else {
+            setInitialState(mApStaDisabledState);
+        }
+
+        setLogRecSize(100);
+        setLogOnlyTransitions(false);
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(ACTION_DEVICE_IDLE);
+        filter.addAction(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION);
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        String action = intent.getAction();
+                        if (action.equals(ACTION_DEVICE_IDLE)) {
+                            sendMessage(CMD_DEVICE_IDLE);
+                        } else if (action.equals(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION)) {
+                            mNetworkInfo = (NetworkInfo) intent.getParcelableExtra(
+                                    WifiManagerWAP.EXTRA_NETWORK_INFO);
+                        }
+                    }
+                },
+                new IntentFilter(filter));
+
+        initializeAndRegisterForSettingsChange(looper);
+    }
+
+    private void initializeAndRegisterForSettingsChange(Looper looper) {
+        Handler handler = new Handler(looper);
+        readStayAwakeConditions();
+        registerForStayAwakeModeChange(handler);
+        readWifiIdleTime();
+        registerForWifiIdleTimeChange(handler);
+        readWifiSleepPolicy();
+        registerForWifiSleepPolicyChange(handler);
+        readWifiReEnableDelay();
+    }
+
+    private void readStayAwakeConditions() {
+        mStayAwakeConditions = Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0);
+    }
+
+    private void readWifiIdleTime() {
+        mIdleMillis = Settings.Global.getLong(mContext.getContentResolver(),
+                Settings.Global.WIFI_IDLE_MS, DEFAULT_IDLE_MS);
+    }
+
+    private void readWifiSleepPolicy() {
+        mSleepPolicy = Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.WIFI_SLEEP_POLICY,
+                Settings.Global.WIFI_SLEEP_POLICY_NEVER);
+    }
+
+    private void readWifiReEnableDelay() {
+        mReEnableDelayMillis = Settings.Global.getLong(mContext.getContentResolver(),
+                Settings.Global.WIFI_REENABLE_DELAY_MS, DEFAULT_REENABLE_DELAY_MS);
+    }
+
+    /**
+     * Observes settings changes to scan always mode.
+     */
+    private void registerForStayAwakeModeChange(Handler handler) {
+        ContentObserver contentObserver = new ContentObserver(handler) {
+            @Override
+            public void onChange(boolean selfChange) {
+                readStayAwakeConditions();
+            }
+        };
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.STAY_ON_WHILE_PLUGGED_IN),
+                false, contentObserver);
+    }
+
+    /**
+     * Observes settings changes to scan always mode.
+     */
+    private void registerForWifiIdleTimeChange(Handler handler) {
+        ContentObserver contentObserver = new ContentObserver(handler) {
+            @Override
+            public void onChange(boolean selfChange) {
+                readWifiIdleTime();
+            }
+        };
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WIFI_IDLE_MS),
+                false, contentObserver);
+    }
+
+    /**
+     * Observes changes to wifi sleep policy
+     */
+    private void registerForWifiSleepPolicyChange(Handler handler) {
+        ContentObserver contentObserver = new ContentObserver(handler) {
+            @Override
+            public void onChange(boolean selfChange) {
+                readWifiSleepPolicy();
+            }
+        };
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WIFI_SLEEP_POLICY),
+                false, contentObserver);
+    }
+
+    /**
+     * Determines whether the Wi-Fi chipset should stay awake or be put to
+     * sleep. Looks at the setting for the sleep policy and the current
+     * conditions.
+     *
+     * @see #shouldDeviceStayAwake(int)
+     */
+    private boolean shouldWifiStayAwake(int pluggedType) {
+        if (mSleepPolicy == Settings.Global.WIFI_SLEEP_POLICY_NEVER) {
+            // Never sleep
+            return true;
+        } else if ((mSleepPolicy == Settings.Global.WIFI_SLEEP_POLICY_NEVER_WHILE_PLUGGED) &&
+                (pluggedType != 0)) {
+            // Never sleep while plugged, and we're plugged
+            return true;
+        } else {
+            // Default
+            return shouldDeviceStayAwake(pluggedType);
+        }
+    }
+
+    /**
+     * Determine whether the bit value corresponding to {@code pluggedType} is set in
+     * the bit string mStayAwakeConditions. This determines whether the device should
+     * stay awake based on the current plugged type.
+     *
+     * @param pluggedType the type of plug (USB, AC, or none) for which the check is
+     * being made
+     * @return {@code true} if {@code pluggedType} indicates that the device is
+     * supposed to stay awake, {@code false} otherwise.
+     */
+    private boolean shouldDeviceStayAwake(int pluggedType) {
+        return (mStayAwakeConditions & pluggedType) != 0;
+    }
+
+    private void updateBatteryWorkSource() {
+        mTmpWorkSource.clear();
+        if (mDeviceIdle) {
+            mLocks.updateWorkSource(mTmpWorkSource);
+        }
+        mWifiStateMachine.updateBatteryWorkSource(mTmpWorkSource);
+    }
+
+    class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_SCREEN_ON:
+                    mAlarmManager.cancel(mIdleIntent);
+                    mScreenOff = false;
+                    mDeviceIdle = false;
+                    updateBatteryWorkSource();
+                    break;
+                case CMD_SCREEN_OFF:
+                    mScreenOff = true;
+                    /*
+                    * Set a timer to put Wi-Fi to sleep, but only if the screen is off
+                    * AND the "stay on while plugged in" setting doesn't match the
+                    * current power conditions (i.e, not plugged in, plugged in to USB,
+                    * or plugged in to AC).
+                    */
+                    if (!shouldWifiStayAwake(mPluggedType)) {
+                        //Delayed shutdown if wifi is connected
+                        if (mNetworkInfo.getDetailedState() ==
+                                NetworkInfo.DetailedState.CONNECTED) {
+                            if (DBG) Slog.d(TAG, "set idle timer: " + mIdleMillis + " ms");
+                            mAlarmManager.set(AlarmManager.RTC_WAKEUP,
+                                    System.currentTimeMillis() + mIdleMillis, mIdleIntent);
+                        } else {
+                            sendMessage(CMD_DEVICE_IDLE);
+                        }
+                    }
+                    break;
+                case CMD_DEVICE_IDLE:
+                    mDeviceIdle = true;
+                    updateBatteryWorkSource();
+                    break;
+                case CMD_BATTERY_CHANGED:
+                    /*
+                    * Set a timer to put Wi-Fi to sleep, but only if the screen is off
+                    * AND we are transitioning from a state in which the device was supposed
+                    * to stay awake to a state in which it is not supposed to stay awake.
+                    * If "stay awake" state is not changing, we do nothing, to avoid resetting
+                    * the already-set timer.
+                    */
+                    int pluggedType = msg.arg1;
+                    if (DBG) Slog.d(TAG, "battery changed pluggedType: " + pluggedType);
+                    if (mScreenOff && shouldWifiStayAwake(mPluggedType) &&
+                            !shouldWifiStayAwake(pluggedType)) {
+                        long triggerTime = System.currentTimeMillis() + mIdleMillis;
+                        if (DBG) Slog.d(TAG, "set idle timer for " + mIdleMillis + "ms");
+                        mAlarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, mIdleIntent);
+                    }
+
+                    mPluggedType = pluggedType;
+                    break;
+                case CMD_SET_AP:
+                case CMD_SCAN_ALWAYS_MODE_CHANGED:
+                case CMD_LOCKS_CHANGED:
+                case CMD_WIFI_TOGGLED:
+                case CMD_AIRPLANE_TOGGLED:
+                case CMD_EMERGENCY_MODE_CHANGED:
+                    break;
+                case CMD_USER_PRESENT:
+                    mFirstUserSignOnSeen = true;
+                    break;
+                case CMD_DEFERRED_TOGGLE:
+                    log("DEFERRED_TOGGLE ignored due to state change");
+                    break;
+                default:
+                    throw new RuntimeException("WifiControllerWAP.handleMessage " + msg.what);
+            }
+            return HANDLED;
+        }
+
+    }
+
+    class ApStaDisabledState extends State {
+        private int mDeferredEnableSerialNumber = 0;
+        private boolean mHaveDeferredEnable = false;
+        private long mDisabledTimestamp;
+
+        @Override
+        public void enter() {
+            mWifiStateMachine.setSupplicantRunning(false);
+            // Supplicant can't restart right away, so not the time we switched off
+            mDisabledTimestamp = SystemClock.elapsedRealtime();
+            mDeferredEnableSerialNumber++;
+            mHaveDeferredEnable = false;
+        }
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_WIFI_TOGGLED:
+                case CMD_AIRPLANE_TOGGLED:
+                    if (!mSettingsStore.isAirplaneModeOn()) {
+                        mWifiStateMachine.setHostApRunning(null, true);
+                        transitionTo(mApEnabledState);
+                    }
+                    break;
+                case CMD_SCAN_ALWAYS_MODE_CHANGED:
+                    if (mSettingsStore.isScanAlwaysAvailable()) {
+                        transitionTo(mStaDisabledWithScanState);
+                    }
+                    break;
+                case CMD_SET_AP:
+                    if (msg.arg1 == 1) {
+                        mWifiStateMachine.setHostApRunning((WifiConfiguration) msg.obj,
+                                true);
+                        transitionTo(mApEnabledState);
+                    }
+                    break;
+                case CMD_DEFERRED_TOGGLE:
+                    if (msg.arg1 != mDeferredEnableSerialNumber) {
+                        log("DEFERRED_TOGGLE ignored due to serial mismatch");
+                        break;
+                    }
+                    log("DEFERRED_TOGGLE handled");
+                    sendMessage((Message)(msg.obj));
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        private boolean doDeferEnable(Message msg) {
+            long delaySoFar = SystemClock.elapsedRealtime() - mDisabledTimestamp;
+            if (delaySoFar >= mReEnableDelayMillis) {
+                return false;
+            }
+
+            log("WifiControllerWAP msg " + msg + " deferred for " +
+                    (mReEnableDelayMillis - delaySoFar) + "ms");
+
+            // need to defer this action.
+            Message deferredMsg = obtainMessage(CMD_DEFERRED_TOGGLE);
+            deferredMsg.obj = Message.obtain(msg);
+            deferredMsg.arg1 = ++mDeferredEnableSerialNumber;
+            sendMessageDelayed(deferredMsg, mReEnableDelayMillis - delaySoFar + DEFER_MARGIN_MS);
+            return true;
+        }
+
+    }
+
+    class StaEnabledState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setSupplicantRunning(true);
+        }
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_WIFI_TOGGLED:
+                    int mWifiState = mWifiStateMachine.syncGetWifiState();
+                    if (! mSettingsStore.isWifiToggleEnabled()) {
+                        if (mSettingsStore.isScanAlwaysAvailable()) {
+                            transitionTo(mStaDisabledWithScanState);
+                        } else {
+                            transitionTo(mApStaDisabledState);
+                        }
+                    }
+                    if ((mWifiState != WIFI_STATE_ENABLING) &&
+                        (mWifiState != WIFI_STATE_ENABLED)) {
+                        if (DBG) {
+                            Slog.d(TAG, "Mismatch in the state " + mWifiState);
+                        }
+                        mWifiStateMachine.setSupplicantRunning(true);
+                    }
+                    break;
+                case CMD_AIRPLANE_TOGGLED:
+                    /* When wi-fi is turned off due to airplane,
+                    * disable entirely (including scan)
+                    */
+                    if (! mSettingsStore.isWifiToggleEnabled()) {
+                        transitionTo(mApStaDisabledState);
+                    }
+                    break;
+                case CMD_EMERGENCY_MODE_CHANGED:
+                    if (msg.arg1 == 1) {
+                        transitionTo(mEcmState);
+                        break;
+                    }
+                default:
+                    return NOT_HANDLED;
+
+            }
+            return HANDLED;
+        }
+    }
+
+    class StaDisabledWithScanState extends State {
+        private int mDeferredEnableSerialNumber = 0;
+        private boolean mHaveDeferredEnable = false;
+        private long mDisabledTimestamp;
+
+        @Override
+        public void enter() {
+            mWifiStateMachine.setSupplicantRunning(true);
+            mWifiStateMachine.setOperationalMode(WifiStateMachineWAP.SCAN_ONLY_WITH_WIFI_OFF_MODE);
+            mWifiStateMachine.setDriverStart(true);
+            // Supplicant can't restart right away, so not the time we switched off
+            mDisabledTimestamp = SystemClock.elapsedRealtime();
+            mDeferredEnableSerialNumber++;
+            mHaveDeferredEnable = false;
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_WIFI_TOGGLED:
+                    if (mSettingsStore.isWifiToggleEnabled()) {
+                        if (doDeferEnable(msg)) {
+                            if (mHaveDeferredEnable) {
+                                // have 2 toggles now, inc serial number and ignore both
+                                mDeferredEnableSerialNumber++;
+                            }
+                            mHaveDeferredEnable = !mHaveDeferredEnable;
+                            break;
+                        }
+                        if (mDeviceIdle == false) {
+                            transitionTo(mDeviceActiveState);
+                        } else {
+                            checkLocksAndTransitionWhenDeviceIdle();
+                        }
+                    }
+                    break;
+                case CMD_AIRPLANE_TOGGLED:
+                    if (mSettingsStore.isAirplaneModeOn() &&
+                            ! mSettingsStore.isWifiToggleEnabled()) {
+                        transitionTo(mApStaDisabledState);
+                    }
+                case CMD_SCAN_ALWAYS_MODE_CHANGED:
+                    if (! mSettingsStore.isScanAlwaysAvailable()) {
+                        transitionTo(mApStaDisabledState);
+                    }
+                    break;
+                case CMD_SET_AP:
+                    // Before starting tethering, turn off supplicant for scan mode
+                    if (msg.arg1 == 1) {
+                        deferMessage(msg);
+                        transitionTo(mApStaDisabledState);
+                    }
+                    break;
+                case CMD_DEFERRED_TOGGLE:
+                    if (msg.arg1 != mDeferredEnableSerialNumber) {
+                        log("DEFERRED_TOGGLE ignored due to serial mismatch");
+                        break;
+                    }
+                    logd("DEFERRED_TOGGLE handled");
+                    sendMessage((Message)(msg.obj));
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        private boolean doDeferEnable(Message msg) {
+            long delaySoFar = SystemClock.elapsedRealtime() - mDisabledTimestamp;
+            if (delaySoFar >= mReEnableDelayMillis) {
+                return false;
+            }
+
+            log("WifiControllerWAP msg " + msg + " deferred for " +
+                    (mReEnableDelayMillis - delaySoFar) + "ms");
+
+            // need to defer this action.
+            Message deferredMsg = obtainMessage(CMD_DEFERRED_TOGGLE);
+            deferredMsg.obj = Message.obtain(msg);
+            deferredMsg.arg1 = ++mDeferredEnableSerialNumber;
+            sendMessageDelayed(deferredMsg, mReEnableDelayMillis - delaySoFar + DEFER_MARGIN_MS);
+            return true;
+        }
+
+    }
+
+    class ApEnabledState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_AIRPLANE_TOGGLED:
+                    if (mSettingsStore.isAirplaneModeOn()) {
+                        mWifiStateMachine.setHostApRunning(null, false);
+                        transitionTo(mApStaDisabledState);
+                    }
+                    break;
+                case CMD_SET_AP:
+                    if (msg.arg1 == 0) {
+                        mWifiStateMachine.setHostApRunning(null, false);
+                        transitionTo(mApStaDisabledState);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class EcmState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setSupplicantRunning(false);
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what == CMD_EMERGENCY_MODE_CHANGED && msg.arg1 == 0) {
+                if (mSettingsStore.isWifiToggleEnabled()) {
+                    if (mDeviceIdle == false) {
+                        transitionTo(mDeviceActiveState);
+                    } else {
+                        checkLocksAndTransitionWhenDeviceIdle();
+                    }
+                } else if (mSettingsStore.isScanAlwaysAvailable()) {
+                    transitionTo(mStaDisabledWithScanState);
+                } else {
+                    transitionTo(mApStaDisabledState);
+                }
+                return HANDLED;
+            } else {
+                return NOT_HANDLED;
+            }
+        }
+    }
+
+    /* Parent: StaEnabledState */
+    class DeviceActiveState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setOperationalMode(WifiStateMachineWAP.CONNECT_MODE);
+            mWifiStateMachine.setDriverStart(true);
+            mWifiStateMachine.setHighPerfModeEnabled(false);
+        }
+
+        @Override
+        public boolean processMessage(Message msg) {
+            if (msg.what == CMD_DEVICE_IDLE) {
+                checkLocksAndTransitionWhenDeviceIdle();
+                // We let default state handle the rest of work
+            } else if (msg.what == CMD_USER_PRESENT) {
+                // TLS networks can't connect until user unlocks keystore. KeyStore
+                // unlocks when the user punches PIN after the reboot. So use this
+                // trigger to get those networks connected.
+                if (mFirstUserSignOnSeen == false) {
+                    mWifiStateMachine.reloadTlsNetworksAndReconnect();
+                }
+                mFirstUserSignOnSeen = true;
+                return HANDLED;
+            }
+            return NOT_HANDLED;
+        }
+    }
+
+    /* Parent: StaEnabledState */
+    class DeviceInactiveState extends State {
+        @Override
+        public boolean processMessage(Message msg) {
+            switch (msg.what) {
+                case CMD_LOCKS_CHANGED:
+                    checkLocksAndTransitionWhenDeviceIdle();
+                    updateBatteryWorkSource();
+                    return HANDLED;
+                case CMD_SCREEN_ON:
+                    transitionTo(mDeviceActiveState);
+                    // More work in default state
+                    return NOT_HANDLED;
+                default:
+                    return NOT_HANDLED;
+            }
+        }
+    }
+
+    /* Parent: DeviceInactiveState. Device is inactive, but an app is holding a scan only lock. */
+    class ScanOnlyLockHeldState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setOperationalMode(WifiStateMachineWAP.SCAN_ONLY_MODE);
+            mWifiStateMachine.setDriverStart(true);
+        }
+    }
+
+    /* Parent: DeviceInactiveState. Device is inactive, but an app is holding a full lock. */
+    class FullLockHeldState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setOperationalMode(WifiStateMachineWAP.CONNECT_MODE);
+            mWifiStateMachine.setDriverStart(true);
+            mWifiStateMachine.setHighPerfModeEnabled(false);
+        }
+    }
+
+    /* Parent: DeviceInactiveState. Device is inactive, but an app is holding a high perf lock. */
+    class FullHighPerfLockHeldState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setOperationalMode(WifiStateMachineWAP.CONNECT_MODE);
+            mWifiStateMachine.setDriverStart(true);
+            mWifiStateMachine.setHighPerfModeEnabled(true);
+        }
+    }
+
+    /* Parent: DeviceInactiveState. Device is inactive and no app is holding a wifi lock. */
+    class NoLockHeldState extends State {
+        @Override
+        public void enter() {
+            mWifiStateMachine.setDriverStart(false);
+        }
+    }
+
+    private void checkLocksAndTransitionWhenDeviceIdle() {
+        if (mLocks.hasLocks()) {
+            switch (mLocks.getStrongestLockMode()) {
+                case WIFI_MODE_FULL:
+                    transitionTo(mFullLockHeldState);
+                    break;
+                case WIFI_MODE_FULL_HIGH_PERF:
+                    transitionTo(mFullHighPerfLockHeldState);
+                    break;
+                case WIFI_MODE_SCAN_ONLY:
+                    transitionTo(mScanOnlyLockHeldState);
+                    break;
+                default:
+                    loge("Illegal lock " + mLocks.getStrongestLockMode());
+            }
+        } else {
+            if (mSettingsStore.isScanAlwaysAvailable()) {
+                transitionTo(mScanOnlyLockHeldState);
+            } else {
+                transitionTo(mNoLockHeldState);
+            }
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        super.dump(fd, pw, args);
+
+        pw.println("mScreenOff " + mScreenOff);
+        pw.println("mDeviceIdle " + mDeviceIdle);
+        pw.println("mPluggedType " + mPluggedType);
+        pw.println("mIdleMillis " + mIdleMillis);
+        pw.println("mSleepPolicy " + mSleepPolicy);
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNative.java
@@ -81,6 +81,12 @@
 
     public native static boolean unloadDriver();
 
+    public native static boolean loadApDriver();
+
+    public native static boolean isApDriverLoaded();
+
+    public native static boolean unloadApDriver();
+
     public native static boolean startSupplicant(boolean p2pSupported);
 
     /* Sends a kill signal to supplicant. To be used when we have lost connection
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationController.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationController.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationController.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationController.java
@@ -32,6 +32,7 @@
 import android.os.Message;
 import android.os.UserHandle;
 import android.provider.Settings;
+import android.os.ServiceManager;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -124,6 +125,15 @@
                             }
                         } else if (intent.getAction().equals(
                                 WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
+                            WifiServiceImplWAP apImpl;
+                            apImpl = (WifiServiceImplWAP)ServiceManager.getService(Context.WAP_SERVICE);
+                            if(apImpl.is1stTimeStartSAP() && apImpl.is1stTimeChooseChan()) {
+                                int wifiApState = apImpl.getWifiApEnabledState();
+                                if(wifiApState == WifiManager.WIFI_AP_STATE_DISABLED) {
+                                    apImpl.checkAndStartWifi();
+                                    apImpl.clear1stTimeStartSAP();
+                                }
+                            }
                             checkAndSetNotification(mNetworkInfo,
                                     mWifiStateMachine.syncGetScanResultsList());
                         }
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationControllerWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationControllerWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationControllerWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiNotificationControllerWAP.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.TaskStackBuilder;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.NetworkInfo;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiManagerWAP;
+import android.os.Handler;
+import android.os.Message;
+import android.os.UserHandle;
+import android.provider.Settings;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.List;
+
+/* Takes care of handling the "open wi-fi network available" notification @hide */
+final class WifiNotificationControllerWAP {
+    /**
+     * The icon to show in the 'available networks' notification. This will also
+     * be the ID of the Notification given to the NotificationManager.
+     */
+    private static final int ICON_NETWORKS_AVAILABLE =
+            com.android.internal.R.drawable.stat_notify_wifi_in_range;
+    /**
+     * When a notification is shown, we wait this amount before possibly showing it again.
+     */
+    private final long NOTIFICATION_REPEAT_DELAY_MS;
+    /**
+     * Whether the user has set the setting to show the 'available networks' notification.
+     */
+    private boolean mNotificationEnabled;
+    /**
+     * Observes the user setting to keep {@link #mNotificationEnabled} in sync.
+     */
+    private NotificationEnabledSettingObserver mNotificationEnabledSettingObserver;
+    /**
+     * The {@link System#currentTimeMillis()} must be at least this value for us
+     * to show the notification again.
+     */
+    private long mNotificationRepeatTime;
+    /**
+     * The Notification object given to the NotificationManager.
+     */
+    private Notification mNotification;
+    /**
+     * Whether the notification is being shown, as set by us. That is, if the
+     * user cancels the notification, we will not receive the callback so this
+     * will still be true. We only guarantee if this is false, then the
+     * notification is not showing.
+     */
+    private boolean mNotificationShown;
+    /**
+     * The number of continuous scans that must occur before consider the
+     * supplicant in a scanning state. This allows supplicant to associate with
+     * remembered networks that are in the scan results.
+     */
+    private static final int NUM_SCANS_BEFORE_ACTUALLY_SCANNING = 3;
+    /**
+     * The number of scans since the last network state change. When this
+     * exceeds {@link #NUM_SCANS_BEFORE_ACTUALLY_SCANNING}, we consider the
+     * supplicant to actually be scanning. When the network state changes to
+     * something other than scanning, we reset this to 0.
+     */
+    private int mNumScansSinceNetworkStateChange;
+
+    private final Context mContext;
+    private final WifiStateMachineWAP mWifiStateMachine;
+    private NetworkInfo mNetworkInfo;
+    private volatile int mWifiState;
+
+    WifiNotificationControllerWAP(Context context, WifiStateMachineWAP wsm) {
+        mContext = context;
+        mWifiStateMachine = wsm;
+        mWifiState = WifiManagerWAP.WIFI_STATE_UNKNOWN;
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(WifiManagerWAP.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION);
+        filter.addAction(WifiManagerWAP.SCAN_RESULTS_AVAILABLE_ACTION);
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (intent.getAction().equals(WifiManagerWAP.WIFI_STATE_CHANGED_ACTION)) {
+                            mWifiState = intent.getIntExtra(WifiManagerWAP.EXTRA_WIFI_STATE,
+                                    WifiManagerWAP.WIFI_STATE_UNKNOWN);
+                            resetNotification();
+                        } else if (intent.getAction().equals(
+                                WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION)) {
+                            mNetworkInfo = (NetworkInfo) intent.getParcelableExtra(
+                                    WifiManagerWAP.EXTRA_NETWORK_INFO);
+                            // reset & clear notification on a network connect & disconnect
+                            switch(mNetworkInfo.getDetailedState()) {
+                                case CONNECTED:
+                                case DISCONNECTED:
+                                case CAPTIVE_PORTAL_CHECK:
+                                    resetNotification();
+                                    break;
+                            }
+                        } else if (intent.getAction().equals(
+                                WifiManagerWAP.SCAN_RESULTS_AVAILABLE_ACTION)) {
+                            checkAndSetNotification(mNetworkInfo,
+                                    mWifiStateMachine.syncGetScanResultsList());
+                        }
+                    }
+                }, filter);
+
+        // Setting is in seconds
+        NOTIFICATION_REPEAT_DELAY_MS = Settings.Global.getInt(context.getContentResolver(),
+                Settings.Global.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY, 900) * 1000l;
+        mNotificationEnabledSettingObserver = new NotificationEnabledSettingObserver(new Handler());
+        mNotificationEnabledSettingObserver.register();
+    }
+
+    private synchronized void checkAndSetNotification(NetworkInfo networkInfo,
+            List<ScanResult> scanResults) {
+
+        // TODO: unregister broadcast so we do not have to check here
+        // If we shouldn't place a notification on available networks, then
+        // don't bother doing any of the following
+        if (!mNotificationEnabled) return;
+        if (mWifiState != WifiManagerWAP.WIFI_STATE_ENABLED) return;
+
+        NetworkInfo.State state = NetworkInfo.State.DISCONNECTED;
+        if (networkInfo != null)
+            state = networkInfo.getState();
+
+        if ((state == NetworkInfo.State.DISCONNECTED)
+                || (state == NetworkInfo.State.UNKNOWN)) {
+            if (scanResults != null) {
+                int numOpenNetworks = 0;
+                for (int i = scanResults.size() - 1; i >= 0; i--) {
+                    ScanResult scanResult = scanResults.get(i);
+
+                    //A capability of [ESS] represents an open access point
+                    //that is available for an STA to connect
+                    if (scanResult.capabilities != null &&
+                            scanResult.capabilities.equals("[ESS]")) {
+                        numOpenNetworks++;
+                    }
+                }
+
+                if (numOpenNetworks > 0) {
+                    if (++mNumScansSinceNetworkStateChange >= NUM_SCANS_BEFORE_ACTUALLY_SCANNING) {
+                        /*
+                         * We've scanned continuously at least
+                         * NUM_SCANS_BEFORE_NOTIFICATION times. The user
+                         * probably does not have a remembered network in range,
+                         * since otherwise supplicant would have tried to
+                         * associate and thus resetting this counter.
+                         */
+                        setNotificationVisible(true, numOpenNetworks, false, 0);
+                    }
+                    return;
+                }
+            }
+        }
+
+        // No open networks in range, remove the notification
+        setNotificationVisible(false, 0, false, 0);
+    }
+
+    /**
+     * Clears variables related to tracking whether a notification has been
+     * shown recently and clears the current notification.
+     */
+    private synchronized void resetNotification() {
+        mNotificationRepeatTime = 0;
+        mNumScansSinceNetworkStateChange = 0;
+        setNotificationVisible(false, 0, false, 0);
+    }
+
+    /**
+     * Display or don't display a notification that there are open Wi-Fi networks.
+     * @param visible {@code true} if notification should be visible, {@code false} otherwise
+     * @param numNetworks the number networks seen
+     * @param force {@code true} to force notification to be shown/not-shown,
+     * even if it is already shown/not-shown.
+     * @param delay time in milliseconds after which the notification should be made
+     * visible or invisible.
+     */
+    private void setNotificationVisible(boolean visible, int numNetworks, boolean force,
+            int delay) {
+
+        // Since we use auto cancel on the notification, when the
+        // mNetworksAvailableNotificationShown is true, the notification may
+        // have actually been canceled.  However, when it is false we know
+        // for sure that it is not being shown (it will not be shown any other
+        // place than here)
+
+        // If it should be hidden and it is already hidden, then noop
+        if (!visible && !mNotificationShown && !force) {
+            return;
+        }
+
+        NotificationManager notificationManager = (NotificationManager) mContext
+                .getSystemService(Context.NOTIFICATION_SERVICE);
+
+        Message message;
+        if (visible) {
+
+            // Not enough time has passed to show the notification again
+            if (System.currentTimeMillis() < mNotificationRepeatTime) {
+                return;
+            }
+
+            if (mNotification == null) {
+                // Cache the Notification object.
+                mNotification = new Notification();
+                mNotification.when = 0;
+                mNotification.icon = ICON_NETWORKS_AVAILABLE;
+                mNotification.flags = Notification.FLAG_AUTO_CANCEL;
+                mNotification.contentIntent = TaskStackBuilder.create(mContext)
+                        .addNextIntentWithParentStack(
+                                new Intent(WifiManagerWAP.ACTION_PICK_WIFI_NETWORK))
+                        .getPendingIntent(0, 0, null, UserHandle.CURRENT);
+            }
+
+            CharSequence title = mContext.getResources().getQuantityText(
+                    com.android.internal.R.plurals.wifi_available, numNetworks);
+            CharSequence details = mContext.getResources().getQuantityText(
+                    com.android.internal.R.plurals.wifi_available_detailed, numNetworks);
+            mNotification.tickerText = title;
+            mNotification.color = mContext.getResources().getColor(
+                    com.android.internal.R.color.system_notification_accent_color);
+            mNotification.setLatestEventInfo(mContext, title, details, mNotification.contentIntent);
+
+            mNotificationRepeatTime = System.currentTimeMillis() + NOTIFICATION_REPEAT_DELAY_MS;
+
+            notificationManager.notifyAsUser(null, ICON_NETWORKS_AVAILABLE, mNotification,
+                    UserHandle.ALL);
+        } else {
+            notificationManager.cancelAsUser(null, ICON_NETWORKS_AVAILABLE, UserHandle.ALL);
+        }
+
+        mNotificationShown = visible;
+    }
+
+    void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("mNotificationEnabled " + mNotificationEnabled);
+        pw.println("mNotificationRepeatTime " + mNotificationRepeatTime);
+        pw.println("mNotificationShown " + mNotificationShown);
+        pw.println("mNumScansSinceNetworkStateChange " + mNumScansSinceNetworkStateChange);
+    }
+
+    private class NotificationEnabledSettingObserver extends ContentObserver {
+        public NotificationEnabledSettingObserver(Handler handler) {
+            super(handler);
+        }
+
+        public void register() {
+            ContentResolver cr = mContext.getContentResolver();
+            cr.registerContentObserver(Settings.Global.getUriFor(
+                    Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON), true, this);
+            synchronized (WifiNotificationControllerWAP.this) {
+                mNotificationEnabled = getValue();
+            }
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            super.onChange(selfChange);
+
+            synchronized (WifiNotificationControllerWAP.this) {
+                mNotificationEnabled = getValue();
+                resetNotification();
+            }
+        }
+
+        private boolean getValue() {
+            return Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON, 1) == 1;
+        }
+    }
+
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
@@ -126,6 +126,8 @@
 
      private boolean mIsControllerStarted = false;
 
+     private boolean mIsWifiEnabling = false;
+
     /**
      * Asynchronous channel to WifiStateMachine
      */
@@ -317,6 +319,7 @@
         mClientHandler = new ClientHandler(wifiThread.getLooper());
         mWifiStateMachineHandler = new WifiStateMachineHandler(wifiThread.getLooper());
         mWifiController = new WifiController(mContext, this, wifiThread.getLooper());
+        mIsWifiEnabling = false;
 
         mBatchedScanSupported = mContext.getResources().getBoolean(
                 R.bool.config_wifi_batched_scan_supported);
@@ -331,9 +334,9 @@
      */
     public void checkAndStartWifi() {
         /* Check if wi-fi needs to be enabled */
-        boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
+        /*boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
         Slog.i(TAG, "WifiService starting up with Wi-Fi " +
-                (wifiEnabled ? "enabled" : "disabled"));
+                (wifiEnabled ? "enabled" : "disabled"));*/
 
         registerForScanModeChange();
         mContext.registerReceiver(
@@ -358,7 +361,7 @@
 
         // If we are already disabled (could be due to airplane mode), avoid changing persist
         // state here
-        if (wifiEnabled) setWifiEnabled(wifiEnabled);
+        setWifiEnabled(true);
 
         mWifiWatchdogStateMachine = WifiWatchdogStateMachine.
                makeWifiWatchdogStateMachine(mContext, mWifiStateMachine.getMessenger());
@@ -641,6 +644,10 @@
                 "ConnectivityService");
     }
 
+    public void clearWifiEnabling() {
+        mIsWifiEnabling = false;
+    }
+
     /**
      * see {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)}
      * @param enable {@code true} to enable, {@code false} to disable.
@@ -648,6 +655,12 @@
      *         started or is already in the queue.
      */
     public synchronized boolean setWifiEnabled(boolean enable) {
+        if(mIsWifiEnabling) {
+            return true;
+        }
+        if(enable) {
+            mIsWifiEnabling = true;
+        }
         enforceChangePermission();
         Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid()
                     + ", uid=" + Binder.getCallingUid());
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImplWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImplWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImplWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImplWAP.java
@@ -0,0 +1,1838 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.app.ActivityManager;
+import android.app.AppOpsManager;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.pm.UserInfo;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.DhcpInfo;
+import android.net.DhcpResults;
+import android.net.IpConfiguration.ProxySettings;
+import android.net.LinkAddress;
+import android.net.NetworkUtils;
+import android.net.RouteInfo;
+import android.net.wifi.*;
+import android.net.wifi.IWifiManager;
+import android.os.AsyncTask;
+import android.os.Binder;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.UserManager;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Slog;
+
+import java.io.FileNotFoundException;
+import java.io.BufferedReader;
+import java.io.FileDescriptor;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.lang.Override;
+import java.net.InetAddress;
+import java.net.Inet4Address;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.android.internal.R;
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.util.AsyncChannel;
+import com.android.server.am.BatteryStatsService;
+
+import static com.android.server.wifi.WifiControllerWAP.CMD_AIRPLANE_TOGGLED;
+import static com.android.server.wifi.WifiControllerWAP.CMD_BATTERY_CHANGED;
+import static com.android.server.wifi.WifiControllerWAP.CMD_EMERGENCY_MODE_CHANGED;
+import static com.android.server.wifi.WifiControllerWAP.CMD_LOCKS_CHANGED;
+import static com.android.server.wifi.WifiControllerWAP.CMD_SCAN_ALWAYS_MODE_CHANGED;
+import static com.android.server.wifi.WifiControllerWAP.CMD_SCREEN_OFF;
+import static com.android.server.wifi.WifiControllerWAP.CMD_SCREEN_ON;
+import static com.android.server.wifi.WifiControllerWAP.CMD_SET_AP;
+import static com.android.server.wifi.WifiControllerWAP.CMD_USER_PRESENT;
+import static com.android.server.wifi.WifiControllerWAP.CMD_WIFI_TOGGLED;
+/**
+ * WifiService handles remote WiFi operation requests by implementing
+ * the IWifiManager interface.
+ *
+ * @hide
+ */
+public final class WifiServiceImplWAP extends IWifiManager.Stub {
+    private static final String TAG = "WifiServiceWAP";
+    private static final boolean DBG = true;
+
+    final WifiStateMachineWAP mWifiStateMachine;
+
+    private final Context mContext;
+
+    final LockList mLocks = new LockList();
+    // some wifi lock statistics
+    private int mFullHighPerfLocksAcquired;
+    private int mFullHighPerfLocksReleased;
+    private int mFullLocksAcquired;
+    private int mFullLocksReleased;
+    private int mScanLocksAcquired;
+    private int mScanLocksReleased;
+
+    private final List<Multicaster> mMulticasters =
+            new ArrayList<Multicaster>();
+    private int mMulticastEnabled;
+    private int mMulticastDisabled;
+
+    private final IBatteryStats mBatteryStats;
+    private final AppOpsManager mAppOps;
+
+    private String mInterfaceName;
+
+    // Debug counter tracking scan requests sent by WifiManager
+    private int scanRequestCounter = 0;
+
+    /* Tracks the open wi-fi network notification */
+    private WifiNotificationControllerWAP mNotificationController;
+    /* Polls traffic stats and notifies clients */
+    private WifiTrafficPoller mTrafficPoller;
+    /* Tracks the persisted states for wi-fi & airplane mode */
+    final WifiSettingsStoreWAP mSettingsStore;
+
+    final boolean mBatchedScanSupported;
+
+     private boolean mIsControllerStarted = false;
+     private boolean mIs1stTimeStartSAP = true;
+     private boolean mIs1stTimeChooseChan = true;
+
+    /**
+     * Asynchronous channel to WifiStateMachine
+     */
+    private AsyncChannel mWifiStateMachineChannel;
+
+    /**
+     * Handles client connections
+     */
+    private class ClientHandler extends Handler {
+
+        ClientHandler(android.os.Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: {
+                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        if (DBG) Slog.d(TAG, "New client listening to asynchronous messages");
+                        // We track the clients by the Messenger
+                        // since it is expected to be always available
+                        mTrafficPoller.addClient(msg.replyTo);
+                    } else {
+                        Slog.e(TAG, "Client connection failure, error=" + msg.arg1);
+                    }
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                    if (msg.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
+                        if (DBG) Slog.d(TAG, "Send failed, client connection lost");
+                    } else {
+                        if (DBG) Slog.d(TAG, "Client connection lost with reason: " + msg.arg1);
+                    }
+                    mTrafficPoller.removeClient(msg.replyTo);
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION: {
+                    AsyncChannel ac = new AsyncChannel();
+                    ac.connect(mContext, this, msg.replyTo);
+                    break;
+                }
+                /* Client commands are forwarded to state machine */
+                case WifiManagerWAP.CONNECT_NETWORK:
+                case WifiManagerWAP.SAVE_NETWORK: {
+                    WifiConfiguration config = (WifiConfiguration) msg.obj;
+                    int networkId = msg.arg1;
+                    if (msg.what == WifiManagerWAP.SAVE_NETWORK) {
+                        if (config != null) {
+                            if (config.networkId == WifiConfiguration.INVALID_NETWORK_ID) {
+                                config.creatorUid = Binder.getCallingUid();
+                            } else {
+                                config.lastUpdateUid = Binder.getCallingUid();
+                            }
+                        }
+                        Slog.e("WiFiServiceImpl ", "SAVE"
+                                + " nid=" + Integer.toString(networkId)
+                                + " uid=" + Integer.toString(config.creatorUid)
+                                + "/" + Integer.toString(config.lastUpdateUid));
+                    }
+                    if (msg.what == WifiManagerWAP.CONNECT_NETWORK) {
+                        if (config != null) {
+                            if (config.networkId == WifiConfiguration.INVALID_NETWORK_ID) {
+                                config.creatorUid = Binder.getCallingUid();
+                            } else {
+                                config.lastUpdateUid = Binder.getCallingUid();
+                            }
+                        }
+                        Slog.e("WiFiServiceImpl ", "CONNECT "
+                                + " nid=" + Integer.toString(networkId)
+                                + " uid=" + Binder.getCallingUid());
+                    }
+                    if (config != null && config.isValid()) {
+                        if (DBG) Slog.d(TAG, "Connect with config" + config);
+                        mWifiStateMachine.sendMessage(Message.obtain(msg));
+                    } else if (config == null
+                            && networkId != WifiConfiguration.INVALID_NETWORK_ID) {
+                        if (DBG) Slog.d(TAG, "Connect with networkId" + networkId);
+                        mWifiStateMachine.sendMessage(Message.obtain(msg));
+                    } else {
+                        Slog.e(TAG, "ClientHandler.handleMessage ignoring invalid msg=" + msg);
+                        if (msg.what == WifiManagerWAP.CONNECT_NETWORK) {
+                            replyFailed(msg, WifiManagerWAP.CONNECT_NETWORK_FAILED,
+                                    WifiManagerWAP.INVALID_ARGS);
+                        } else {
+                            replyFailed(msg, WifiManagerWAP.SAVE_NETWORK_FAILED,
+                                    WifiManagerWAP.INVALID_ARGS);
+                        }
+                    }
+                    break;
+                }
+                case WifiManagerWAP.FORGET_NETWORK:
+                    if (isOwner(msg.sendingUid)) {
+                        mWifiStateMachine.sendMessage(Message.obtain(msg));
+                    } else {
+                        Slog.e(TAG, "Forget is not authorized for user");
+                        replyFailed(msg, WifiManagerWAP.FORGET_NETWORK_FAILED,
+                                WifiManagerWAP.NOT_AUTHORIZED);
+                    }
+                    break;
+                case WifiManagerWAP.START_WPS:
+                case WifiManagerWAP.CANCEL_WPS:
+                case WifiManagerWAP.DISABLE_NETWORK:
+                case WifiManagerWAP.RSSI_PKTCNT_FETCH: {
+                    mWifiStateMachine.sendMessage(Message.obtain(msg));
+                    break;
+                }
+                default: {
+                    Slog.d(TAG, "ClientHandler.handleMessage ignoring msg=" + msg);
+                    break;
+                }
+            }
+        }
+
+        private void replyFailed(Message msg, int what, int why) {
+            Message reply = msg.obtain();
+            reply.what = what;
+            reply.arg1 = why;
+            try {
+                msg.replyTo.send(reply);
+            } catch (RemoteException e) {
+                // There's not much we can do if reply can't be sent!
+            }
+        }
+    }
+    private ClientHandler mClientHandler;
+
+    /**
+     * Handles interaction with WifiStateMachine
+     */
+    private class WifiStateMachineHandler extends Handler {
+        private AsyncChannel mWsmChannel;
+
+        WifiStateMachineHandler(android.os.Looper looper) {
+            super(looper);
+            mWsmChannel = new AsyncChannel();
+            mWsmChannel.connect(mContext, this, mWifiStateMachine.getHandler());
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: {
+                    if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                        mWifiStateMachineChannel = mWsmChannel;
+                    } else {
+                        Slog.e(TAG, "WifiStateMachine connection failure, error=" + msg.arg1);
+                        mWifiStateMachineChannel = null;
+                    }
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                    Slog.e(TAG, "WifiStateMachine channel lost, msg.arg1 =" + msg.arg1);
+                    mWifiStateMachineChannel = null;
+                    //Re-establish connection to state machine
+                    mWsmChannel.connect(mContext, this, mWifiStateMachine.getHandler());
+                    break;
+                }
+                default: {
+                    Slog.d(TAG, "WifiStateMachineHandler.handleMessage ignoring msg=" + msg);
+                    break;
+                }
+            }
+        }
+    }
+
+    WifiStateMachineHandler mWifiStateMachineHandler;
+
+    private WifiWatchdogStateMachine mWifiWatchdogStateMachine;
+
+    private WifiControllerWAP mWifiController;
+
+    public WifiServiceImplWAP(Context context) {
+        mContext = context;
+
+        mInterfaceName =  "wap0";
+
+        mTrafficPoller = new WifiTrafficPoller(mContext, mInterfaceName);
+        mWifiStateMachine = new WifiStateMachineWAP(mContext, mInterfaceName, mTrafficPoller);
+        mWifiStateMachine.enableRssiPolling(true);
+        mBatteryStats = BatteryStatsService.getService();
+        mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
+
+        mNotificationController = new WifiNotificationControllerWAP(mContext, mWifiStateMachine);
+        mSettingsStore = new WifiSettingsStoreWAP(mContext);
+
+        HandlerThread wifiThread = new HandlerThread("WifiServiceWAP");
+        wifiThread.start();
+        mClientHandler = new ClientHandler(wifiThread.getLooper());
+        mWifiStateMachineHandler = new WifiStateMachineHandler(wifiThread.getLooper());
+        mWifiController = new WifiControllerWAP(mContext, this, wifiThread.getLooper());
+        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.AIRPLANE_MODE_ON, 0);
+
+        mBatchedScanSupported = mContext.getResources().getBoolean(
+                R.bool.config_wifi_batched_scan_supported);
+    }
+
+    /**
+     * Check if Wi-Fi needs to be enabled and start
+     * if needed
+     *
+     * This function is used only at boot time
+     */
+    public void checkAndStartWifi() {
+        /* Check if wi-fi needs to be enabled */
+        boolean wifiEnabled = false;//mSettingsStore.isWifiToggleEnabled();
+        Slog.i(TAG, "WifiServiceWAP starting up with Wi-Fi " +
+                (wifiEnabled ? "enabled" : "disabled"));
+
+        registerForScanModeChange();
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        if (mSettingsStore.handleAirplaneModeToggled()) {
+                            mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
+                        }
+                    }
+                },
+                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
+
+        // Adding optimizations of only receiving broadcasts when wifi is enabled
+        // can result in race conditions when apps toggle wifi in the background
+        // without active user involvement. Always receive broadcasts.
+        registerForBroadcasts();
+
+        mWifiController.start();
+
+        mIsControllerStarted = true;
+
+        // If we are already disabled (could be due to airplane mode), avoid changing persist
+        // state here
+        setWifiApEnabled(null, true);
+
+        mWifiWatchdogStateMachine = WifiWatchdogStateMachine.
+               makeWifiWatchdogStateMachine(mContext, mWifiStateMachine.getMessenger());
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#pingSupplicant()}
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     */
+    public boolean pingSupplicant() {
+        enforceAccessPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncPingSupplicant(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#getChannelList}
+     */
+    public List<WifiChannel> getChannelList() {
+        enforceAccessPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncGetChannelList(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#startScan}
+     * and {@link android.net.wifi.WifiManager#startCustomizedScan}
+     *
+     * @param settings If null, use default parameter, i.e. full scan.
+     * @param workSource If null, all blame is given to the calling uid.
+     */
+    public void startScan(ScanSettings settings, WorkSource workSource) {
+        enforceChangePermission();
+        if (settings != null) {
+            // TODO: should be removed once the startCustomizedScan API is opened up
+            mContext.enforceCallingOrSelfPermission(android.Manifest.permission.LOCATION_HARDWARE,
+                    "LocationHardware");
+            settings = new ScanSettings(settings);
+            if (!settings.isValid()) {
+                Slog.e(TAG, "invalid scan setting");
+                return;
+            }
+        }
+        if (workSource != null) {
+            enforceWorkSourcePermission();
+            // WifiManager currently doesn't use names, so need to clear names out of the
+            // supplied WorkSource to allow future WorkSource combining.
+            workSource.clearNames();
+        }
+        mWifiStateMachine.startScan(Binder.getCallingUid(), scanRequestCounter++,
+                settings, workSource);
+    }
+
+    private class BatchedScanRequest extends DeathRecipient {
+        final BatchedScanSettings settings;
+        final int uid;
+        final int pid;
+        final WorkSource workSource;
+
+        BatchedScanRequest(BatchedScanSettings settings, IBinder binder, WorkSource ws) {
+            super(0, null, binder, null);
+            this.settings = settings;
+            this.uid = getCallingUid();
+            this.pid = getCallingPid();
+            workSource = ws;
+        }
+        public void binderDied() {
+            stopBatchedScan(settings, uid, pid);
+        }
+        public String toString() {
+            return "BatchedScanRequest{settings=" + settings + ", binder=" + mBinder + "}";
+        }
+
+        public boolean isSameApp(int uid, int pid) {
+            return (this.uid == uid && this.pid == pid);
+        }
+    }
+
+    private final List<BatchedScanRequest> mBatchedScanners = new ArrayList<BatchedScanRequest>();
+
+    public boolean isBatchedScanSupported() {
+        return mBatchedScanSupported;
+    }
+
+    public void pollBatchedScan() {
+        enforceChangePermission();
+        if (mBatchedScanSupported == false) return;
+        mWifiStateMachine.requestBatchedScanPoll();
+    }
+
+    public String getWpsNfcConfigurationToken(int netId) {
+        enforceConnectivityInternalPermission();
+        return mWifiStateMachine.syncGetWpsNfcConfigurationToken(netId);
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#requestBatchedScan()}
+     */
+    public boolean requestBatchedScan(BatchedScanSettings requested, IBinder binder,
+            WorkSource workSource) {
+        enforceChangePermission();
+        if (workSource != null) {
+            enforceWorkSourcePermission();
+            // WifiManager currently doesn't use names, so need to clear names out of the
+            // supplied WorkSource to allow future WorkSource combining.
+            workSource.clearNames();
+        }
+        if (mBatchedScanSupported == false) return false;
+        requested = new BatchedScanSettings(requested);
+        if (requested.isInvalid()) return false;
+        BatchedScanRequest r = new BatchedScanRequest(requested, binder, workSource);
+        synchronized(mBatchedScanners) {
+            mBatchedScanners.add(r);
+            resolveBatchedScannersLocked();
+        }
+        return true;
+    }
+
+    public List<BatchedScanResult> getBatchedScanResults(String callingPackage) {
+        enforceAccessPermission();
+        if (mBatchedScanSupported == false) return new ArrayList<BatchedScanResult>();
+        int uid = Binder.getCallingUid();
+        int userId = UserHandle.getCallingUserId();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (mAppOps.noteOp(AppOpsManager.OP_WIFI_SCAN, uid, callingPackage)
+                    != AppOpsManager.MODE_ALLOWED) {
+                return new ArrayList<BatchedScanResult>();
+            }
+            if (!isCurrentProfile(userId)) {
+                return new ArrayList<BatchedScanResult>();
+            }
+            return mWifiStateMachine.syncGetBatchedScanResultsList();
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public void stopBatchedScan(BatchedScanSettings settings) {
+        enforceChangePermission();
+        if (mBatchedScanSupported == false) return;
+        stopBatchedScan(settings, getCallingUid(), getCallingPid());
+    }
+
+    private void stopBatchedScan(BatchedScanSettings settings, int uid, int pid) {
+        ArrayList<BatchedScanRequest> found = new ArrayList<BatchedScanRequest>();
+        synchronized(mBatchedScanners) {
+            for (BatchedScanRequest r : mBatchedScanners) {
+                if (r.isSameApp(uid, pid) && (settings == null || settings.equals(r.settings))) {
+                    found.add(r);
+                    if (settings != null) break;
+                }
+            }
+            for (BatchedScanRequest r : found) {
+                mBatchedScanners.remove(r);
+            }
+            if (found.size() != 0) {
+                resolveBatchedScannersLocked();
+            }
+        }
+    }
+
+    private void resolveBatchedScannersLocked() {
+        BatchedScanSettings setting = new BatchedScanSettings();
+        WorkSource responsibleWorkSource = null;
+        int responsibleUid = 0;
+        double responsibleCsph = 0; // Channel Scans Per Hour
+
+        if (mBatchedScanners.size() == 0) {
+            mWifiStateMachine.setBatchedScanSettings(null, 0, 0, null);
+            return;
+        }
+        for (BatchedScanRequest r : mBatchedScanners) {
+            BatchedScanSettings s = r.settings;
+
+            // evaluate responsibility
+            int currentChannelCount;
+            int currentScanInterval;
+            double currentCsph;
+
+            if (s.channelSet == null || s.channelSet.isEmpty()) {
+                // all channels - 11 B and 9 A channels roughly.
+                currentChannelCount = 9 + 11;
+            } else {
+                currentChannelCount = s.channelSet.size();
+                // these are rough est - no real need to correct for reg-domain;
+                if (s.channelSet.contains("A")) currentChannelCount += (9 - 1);
+                if (s.channelSet.contains("B")) currentChannelCount += (11 - 1);
+
+            }
+            if (s.scanIntervalSec == BatchedScanSettings.UNSPECIFIED) {
+                currentScanInterval = BatchedScanSettings.DEFAULT_INTERVAL_SEC;
+            } else {
+                currentScanInterval = s.scanIntervalSec;
+            }
+            currentCsph = 60 * 60 * currentChannelCount / currentScanInterval;
+
+            if (currentCsph > responsibleCsph) {
+                responsibleUid = r.uid;
+                responsibleWorkSource = r.workSource;
+                responsibleCsph = currentCsph;
+            }
+
+            if (s.maxScansPerBatch != BatchedScanSettings.UNSPECIFIED &&
+                    s.maxScansPerBatch < setting.maxScansPerBatch) {
+                setting.maxScansPerBatch = s.maxScansPerBatch;
+            }
+            if (s.maxApPerScan != BatchedScanSettings.UNSPECIFIED &&
+                    (setting.maxApPerScan == BatchedScanSettings.UNSPECIFIED ||
+                    s.maxApPerScan > setting.maxApPerScan)) {
+                setting.maxApPerScan = s.maxApPerScan;
+            }
+            if (s.scanIntervalSec != BatchedScanSettings.UNSPECIFIED &&
+                    s.scanIntervalSec < setting.scanIntervalSec) {
+                setting.scanIntervalSec = s.scanIntervalSec;
+            }
+            if (s.maxApForDistance != BatchedScanSettings.UNSPECIFIED &&
+                    (setting.maxApForDistance == BatchedScanSettings.UNSPECIFIED ||
+                    s.maxApForDistance > setting.maxApForDistance)) {
+                setting.maxApForDistance = s.maxApForDistance;
+            }
+            if (s.channelSet != null && s.channelSet.size() != 0) {
+                if (setting.channelSet == null || setting.channelSet.size() != 0) {
+                    if (setting.channelSet == null) setting.channelSet = new ArrayList<String>();
+                    for (String i : s.channelSet) {
+                        if (setting.channelSet.contains(i) == false) setting.channelSet.add(i);
+                    }
+                } // else, ignore the constraint - we already use all channels
+            } else {
+                if (setting.channelSet == null || setting.channelSet.size() != 0) {
+                    setting.channelSet = new ArrayList<String>();
+                }
+            }
+        }
+
+        setting.constrain();
+        mWifiStateMachine.setBatchedScanSettings(setting, responsibleUid, (int)responsibleCsph,
+                responsibleWorkSource);
+    }
+
+    private void enforceAccessPermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.ACCESS_WIFI_STATE,
+                "WifiServiceWAP");
+    }
+
+    private void enforceChangePermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CHANGE_WIFI_STATE,
+                                                "WifiServiceWAP");
+
+    }
+
+    private void enforceReadCredentialPermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.READ_WIFI_CREDENTIAL,
+                                                "WifiServiceWAP");
+    }
+
+    private void enforceWorkSourcePermission() {
+        mContext.enforceCallingPermission(android.Manifest.permission.UPDATE_DEVICE_STATS,
+                "WifiServiceWAP");
+
+    }
+
+    private void enforceMulticastChangePermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CHANGE_WIFI_MULTICAST_STATE,
+                "WifiServiceWAP");
+    }
+
+    private void enforceConnectivityInternalPermission() {
+        mContext.enforceCallingOrSelfPermission(
+                android.Manifest.permission.CONNECTIVITY_INTERNAL,
+                "ConnectivityService");
+    }
+
+    public void clear1stTimeStartSAP() {
+        mIs1stTimeStartSAP = false;
+    }
+
+    public boolean is1stTimeStartSAP() {
+        return mIs1stTimeStartSAP;
+    }
+
+    public void clear1stTimeChooseChan() {
+        mIs1stTimeChooseChan = false;
+    }
+
+    public boolean is1stTimeChooseChan() {
+        return mIs1stTimeChooseChan;
+    }
+    /**
+     * see {@link android.net.wifi.WifiManager#setWifiEnabled(boolean)}
+     * @param enable {@code true} to enable, {@code false} to disable.
+     * @return {@code true} if the enable/disable operation was
+     *         started or is already in the queue.
+     */
+    public synchronized boolean setWifiEnabled(boolean enable) {
+        enforceChangePermission();
+        Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+        if (DBG) {
+            Slog.e(TAG, "Invoking mWifiStateMachine.setWifiEnabled\n");
+        }
+
+        /*
+        * Caller might not have WRITE_SECURE_SETTINGS,
+        * only CHANGE_WIFI_STATE is enforced
+        */
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (! mSettingsStore.handleWifiToggled(enable)) {
+                // Nothing to do if wifi cannot be toggled
+                return true;
+            }
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        if (!mIsControllerStarted) {
+            Slog.e(TAG,"WifiController is not yet started, abort setWifiEnabled");
+            return false;
+        }
+
+        mWifiController.sendMessage(CMD_WIFI_TOGGLED);
+        return true;
+    }
+
+    /**
+     * see {@link WifiManager#getWifiState()}
+     * @return One of {@link WifiManager#WIFI_STATE_DISABLED},
+     *         {@link WifiManager#WIFI_STATE_DISABLING},
+     *         {@link WifiManager#WIFI_STATE_ENABLED},
+     *         {@link WifiManager#WIFI_STATE_ENABLING},
+     *         {@link WifiManager#WIFI_STATE_UNKNOWN}
+     */
+    public int getWifiEnabledState() {
+        enforceAccessPermission();
+        return mWifiStateMachine.syncGetWifiState();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#setWifiApEnabled(WifiConfiguration, boolean)}
+     * @param wifiConfig SSID, security and channel details as
+     *        part of WifiConfiguration
+     * @param enabled true to enable and false to disable
+     */
+    public void setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) {
+        enforceChangePermission();
+        ConnectivityManager.enforceTetherChangePermission(mContext);
+        UserManager um = UserManager.get(mContext);
+        if (um.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
+            throw new SecurityException("DISALLOW_CONFIG_TETHERING is enabled for this user.");
+        }
+        // null wifiConfig is a meaningful input for CMD_SET_AP
+        if (wifiConfig == null || wifiConfig.isValid()) {
+            mWifiController.obtainMessage(CMD_SET_AP, enabled ? 1 : 0, 0, wifiConfig).sendToTarget();
+        } else {
+            Slog.e(TAG, "Invalid WifiConfiguration");
+        }
+    }
+
+    /**
+     * see {@link WifiManager#getWifiApState()}
+     * @return One of {@link WifiManager#WIFI_AP_STATE_DISABLED},
+     *         {@link WifiManager#WIFI_AP_STATE_DISABLING},
+     *         {@link WifiManager#WIFI_AP_STATE_ENABLED},
+     *         {@link WifiManager#WIFI_AP_STATE_ENABLING},
+     *         {@link WifiManager#WIFI_AP_STATE_FAILED}
+     */
+    public int getWifiApEnabledState() {
+        enforceAccessPermission();
+        return mWifiStateMachine.syncGetWifiApState();
+    }
+
+    /**
+     * see {@link WifiManager#getWifiApConfiguration()}
+     * @return soft access point configuration
+     */
+    public WifiConfiguration getWifiApConfiguration() {
+        enforceAccessPermission();
+        return mWifiStateMachine.syncGetWifiApConfiguration();
+    }
+
+    /**
+     * see {@link WifiManager#setWifiApConfiguration(WifiConfiguration)}
+     * @param wifiConfig WifiConfiguration details for soft access point
+     */
+    public void setWifiApConfiguration(WifiConfiguration wifiConfig) {
+        enforceChangePermission();
+        if (wifiConfig == null)
+            return;
+        if (wifiConfig.isValid()) {
+            mWifiStateMachine.setWifiApConfiguration(wifiConfig);
+        } else {
+            Slog.e(TAG, "Invalid WifiConfiguration");
+        }
+    }
+
+    /**
+     * @param enable {@code true} to enable, {@code false} to disable.
+     * @return {@code true} if the enable/disable operation was
+     *         started or is already in the queue.
+     */
+    public boolean isScanAlwaysAvailable() {
+        enforceAccessPermission();
+        return mSettingsStore.isScanAlwaysAvailable();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#disconnect()}
+     */
+    public void disconnect() {
+        enforceChangePermission();
+        mWifiStateMachine.disconnectCommand();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#reconnect()}
+     */
+    public void reconnect() {
+        enforceChangePermission();
+        mWifiStateMachine.reconnectCommand();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#reassociate()}
+     */
+    public void reassociate() {
+        enforceChangePermission();
+        mWifiStateMachine.reassociateCommand();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#getSupportedFeatures}
+     */
+    public int getSupportedFeatures() {
+        enforceAccessPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncGetSupportedFeatures(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return 0;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiAdapter#reportActivityInfo}
+     */
+    public WifiActivityEnergyInfo reportActivityInfo() {
+        enforceAccessPermission();
+        WifiLinkLayerStats stats;
+        WifiActivityEnergyInfo energyInfo = null;
+        if (mWifiStateMachineChannel != null) {
+            stats = mWifiStateMachine.syncGetLinkLayerStats(mWifiStateMachineChannel);
+            if (stats != null) {
+                // Convert the LinkLayerStats into EnergyActivity
+                energyInfo = new WifiActivityEnergyInfo(
+                        WifiActivityEnergyInfo.STACK_STATE_STATE_IDLE, stats.tx_time,
+                        stats.rx_time, stats.on_time - stats.tx_time - stats.rx_time,
+                        0 /* TBD */);
+            }
+            return energyInfo;
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#getConfiguredNetworks()}
+     * @return the list of configured networks
+     */
+    public List<WifiConfiguration> getConfiguredNetworks() {
+        enforceAccessPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncGetConfiguredNetworks(Binder.getCallingUid(),
+                    mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#getPrivilegedConfiguredNetworks()}
+     * @return the list of configured networks with real preSharedKey
+     */
+    public List<WifiConfiguration> getPrivilegedConfiguredNetworks() {
+        enforceReadCredentialPermission();
+        enforceAccessPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncGetPrivilegedConfiguredNetwork(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#addOrUpdateNetwork(WifiConfiguration)}
+     * @return the supplicant-assigned identifier for the new or updated
+     * network if the operation succeeds, or {@code -1} if it fails
+     */
+    public int addOrUpdateNetwork(WifiConfiguration config) {
+        enforceChangePermission();
+        if (config.isValid()) {
+            //TODO: pass the Uid the WifiStateMachine as a message parameter
+            Slog.e("addOrUpdateNetwork", " uid = " + Integer.toString(Binder.getCallingUid())
+                    + " SSID " + config.SSID
+                    + " nid=" + Integer.toString(config.networkId));
+            if (config.networkId == WifiConfiguration.INVALID_NETWORK_ID) {
+                config.creatorUid = Binder.getCallingUid();
+            } else {
+                config.lastUpdateUid = Binder.getCallingUid();
+            }
+            if (mWifiStateMachineChannel != null) {
+                return mWifiStateMachine.syncAddOrUpdateNetwork(mWifiStateMachineChannel, config);
+            } else {
+                Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+                return -1;
+            }
+        } else {
+            Slog.e(TAG, "bad network configuration");
+            return -1;
+        }
+    }
+
+     /**
+     * See {@link android.net.wifi.WifiManager#removeNetwork(int)}
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean removeNetwork(int netId) {
+        enforceChangePermission();
+
+        if (!isOwner(Binder.getCallingUid())) {
+            Slog.e(TAG, "Remove is not authorized for user");
+            return false;
+        }
+
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncRemoveNetwork(mWifiStateMachineChannel, netId);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.wifi.WifiManager#enableNetwork(int, boolean)}
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @param disableOthers if true, disable all other networks.
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean enableNetwork(int netId, boolean disableOthers) {
+        enforceChangePermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncEnableNetwork(mWifiStateMachineChannel, netId,
+                    disableOthers);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.wifi.WifiManager#disableNetwork(int)}
+     * @param netId the integer that identifies the network configuration
+     * to the supplicant
+     * @return {@code true} if the operation succeeded
+     */
+    public boolean disableNetwork(int netId) {
+        enforceChangePermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncDisableNetwork(mWifiStateMachineChannel, netId);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * See {@link android.net.wifi.WifiManager#getConnectionInfo()}
+     * @return the Wi-Fi information, contained in {@link WifiInfo}.
+     */
+    public WifiInfo getConnectionInfo() {
+        enforceAccessPermission();
+        /*
+         * Make sure we have the latest information, by sending
+         * a status request to the supplicant.
+         */
+        return mWifiStateMachine.syncRequestConnectionInfo();
+    }
+
+    /**
+     * Return the results of the most recent access point scan, in the form of
+     * a list of {@link ScanResult} objects.
+     * @return the list of results
+     */
+    public List<ScanResult> getScanResults(String callingPackage) {
+        enforceAccessPermission();
+        int userId = UserHandle.getCallingUserId();
+        int uid = Binder.getCallingUid();
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (mAppOps.noteOp(AppOpsManager.OP_WIFI_SCAN, uid, callingPackage)
+                    != AppOpsManager.MODE_ALLOWED) {
+                return new ArrayList<ScanResult>();
+            }
+            if (!isCurrentProfile(userId)) {
+                return new ArrayList<ScanResult>();
+            }
+            return mWifiStateMachine.syncGetScanResultsList();
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    /**
+     * Returns true if the calling user is the current one or a profile of the
+     * current user..
+     */
+    private boolean isCurrentProfile(int userId) {
+        int currentUser = ActivityManager.getCurrentUser();
+        if (userId == currentUser) {
+            return true;
+        }
+        List<UserInfo> profiles = UserManager.get(mContext).getProfiles(currentUser);
+        for (UserInfo user : profiles) {
+            if (userId == user.id) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns true if uid is an application running under the owner or a profile of the owner.
+     *
+     * Note: Should not be called if identity is cleared.
+     */
+    private boolean isOwner(int uid) {
+        long ident = Binder.clearCallingIdentity();
+        int userId = UserHandle.getUserId(uid);
+        try {
+            int ownerUser = UserHandle.USER_OWNER;
+            if (userId == ownerUser) {
+                return true;
+            }
+            List<UserInfo> profiles = UserManager.get(mContext).getProfiles(ownerUser);
+            for (UserInfo profile : profiles) {
+                if (userId == profile.id) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+
+    /**
+     * Tell the supplicant to persist the current list of configured networks.
+     * @return {@code true} if the operation succeeded
+     *
+     * TODO: deprecate this
+     */
+    public boolean saveConfiguration() {
+        boolean result = true;
+        enforceChangePermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncSaveConfig(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return false;
+        }
+    }
+
+    /**
+     * Set the country code
+     * @param countryCode ISO 3166 country code.
+     * @param persist {@code true} if the setting should be remembered.
+     *
+     * The persist behavior exists so that wifi can fall back to the last
+     * persisted country code on a restart, when the locale information is
+     * not available from telephony.
+     */
+    public void setCountryCode(String countryCode, boolean persist) {
+        Slog.i(TAG, "WifiServiceWAP trying to set country code to " + countryCode +
+                " with persist set to " + persist);
+        enforceConnectivityInternalPermission();
+        final long token = Binder.clearCallingIdentity();
+        try {
+            mWifiStateMachine.setCountryCode(countryCode, persist);
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+
+    /**
+     * Set the operational frequency band
+     * @param band One of
+     *     {@link WifiManager#WIFI_FREQUENCY_BAND_AUTO},
+     *     {@link WifiManager#WIFI_FREQUENCY_BAND_5GHZ},
+     *     {@link WifiManager#WIFI_FREQUENCY_BAND_2GHZ},
+     * @param persist {@code true} if the setting should be remembered.
+     *
+     */
+    public void setFrequencyBand(int band, boolean persist) {
+        enforceChangePermission();
+        if (!isDualBandSupported()) return;
+        Slog.i(TAG, "WifiServiceWAP trying to set frequency band to " + band +
+                " with persist set to " + persist);
+        final long token = Binder.clearCallingIdentity();
+        try {
+            mWifiStateMachine.setFrequencyBand(band, persist);
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+
+
+    /**
+     * Get the operational frequency band
+     */
+    public int getFrequencyBand() {
+        enforceAccessPermission();
+        return mWifiStateMachine.getFrequencyBand();
+    }
+
+    public boolean isDualBandSupported() {
+        //TODO: Should move towards adding a driver API that checks at runtime
+        return mContext.getResources().getBoolean(
+                com.android.internal.R.bool.config_wifi_dual_band_support);
+    }
+
+    /**
+     * Return the DHCP-assigned addresses from the last successful DHCP request,
+     * if any.
+     * @return the DHCP information
+     * @deprecated
+     */
+    public DhcpInfo getDhcpInfo() {
+        enforceAccessPermission();
+        DhcpResults dhcpResults = mWifiStateMachine.syncGetDhcpResults();
+
+        DhcpInfo info = new DhcpInfo();
+
+        if (dhcpResults.ipAddress != null &&
+                dhcpResults.ipAddress.getAddress() instanceof Inet4Address) {
+            info.ipAddress = NetworkUtils.inetAddressToInt(
+               (Inet4Address) dhcpResults.ipAddress.getAddress());
+            info.netmask = NetworkUtils.prefixLengthToNetmaskInt(
+               dhcpResults.ipAddress.getNetworkPrefixLength());
+        }
+
+        if (dhcpResults.gateway != null) {
+            info.gateway = NetworkUtils.inetAddressToInt((Inet4Address) dhcpResults.gateway);
+        }
+
+        int dnsFound = 0;
+        for (InetAddress dns : dhcpResults.dnsServers) {
+            if (dns instanceof Inet4Address) {
+                if (dnsFound == 0) {
+                    info.dns1 = NetworkUtils.inetAddressToInt((Inet4Address)dns);
+                } else {
+                    info.dns2 = NetworkUtils.inetAddressToInt((Inet4Address)dns);
+                }
+                if (++dnsFound > 1) break;
+            }
+        }
+        InetAddress serverAddress = dhcpResults.serverAddress;
+        if (serverAddress instanceof Inet4Address) {
+            info.serverAddress = NetworkUtils.inetAddressToInt((Inet4Address)serverAddress);
+        }
+        info.leaseDuration = dhcpResults.leaseDuration;
+
+        return info;
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#startWifi}
+     *
+     */
+    public void startWifi() {
+        enforceConnectivityInternalPermission();
+        /* TODO: may be add permissions for access only to connectivity service
+         * TODO: if a start issued, keep wifi alive until a stop issued irrespective
+         * of WifiLock & device idle status unless wifi enabled status is toggled
+         */
+
+        mWifiStateMachine.setDriverStart(true);
+        mWifiStateMachine.reconnectCommand();
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#stopWifi}
+     *
+     */
+    public void stopWifi() {
+        enforceConnectivityInternalPermission();
+        /*
+         * TODO: if a stop is issued, wifi is brought up only by startWifi
+         * unless wifi enabled status is toggled
+         */
+        mWifiStateMachine.setDriverStart(false);
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#addToBlacklist}
+     *
+     */
+    public void addToBlacklist(String bssid) {
+        enforceChangePermission();
+
+        mWifiStateMachine.addToBlacklist(bssid);
+    }
+
+    /**
+     * see {@link android.net.wifi.WifiManager#clearBlacklist}
+     *
+     */
+    public void clearBlacklist() {
+        enforceChangePermission();
+
+        mWifiStateMachine.clearBlacklist();
+    }
+
+    /**
+     * enable TDLS for the local NIC to remote NIC
+     * The APPs don't know the remote MAC address to identify NIC though,
+     * so we need to do additional work to find it from remote IP address
+     */
+
+    class TdlsTaskParams {
+        public String remoteIpAddress;
+        public boolean enable;
+    }
+
+    class TdlsTask extends AsyncTask<TdlsTaskParams, Integer, Integer> {
+        @Override
+        protected Integer doInBackground(TdlsTaskParams... params) {
+
+            // Retrieve parameters for the call
+            TdlsTaskParams param = params[0];
+            String remoteIpAddress = param.remoteIpAddress.trim();
+            boolean enable = param.enable;
+
+            // Get MAC address of Remote IP
+            String macAddress = null;
+
+            BufferedReader reader = null;
+
+            try {
+                reader = new BufferedReader(new FileReader("/proc/net/arp"));
+
+                // Skip over the line bearing colum titles
+                String line = reader.readLine();
+
+                while ((line = reader.readLine()) != null) {
+                    String[] tokens = line.split("[ ]+");
+                    if (tokens.length < 6) {
+                        continue;
+                    }
+
+                    // ARP column format is
+                    // Address HWType HWAddress Flags Mask IFace
+                    String ip = tokens[0];
+                    String mac = tokens[3];
+
+                    if (remoteIpAddress.equals(ip)) {
+                        macAddress = mac;
+                        break;
+                    }
+                }
+
+                if (macAddress == null) {
+                    Slog.w(TAG, "Did not find remoteAddress {" + remoteIpAddress + "} in " +
+                            "/proc/net/arp");
+                } else {
+                    enableTdlsWithMacAddress(macAddress, enable);
+                }
+
+            } catch (FileNotFoundException e) {
+                Slog.e(TAG, "Could not open /proc/net/arp to lookup mac address");
+            } catch (IOException e) {
+                Slog.e(TAG, "Could not read /proc/net/arp to lookup mac address");
+            } finally {
+                try {
+                    if (reader != null) {
+                        reader.close();
+                    }
+                }
+                catch (IOException e) {
+                    // Do nothing
+                }
+            }
+
+            return 0;
+        }
+    }
+
+    public void enableTdls(String remoteAddress, boolean enable) {
+        if (remoteAddress == null) {
+          throw new IllegalArgumentException("remoteAddress cannot be null");
+        }
+
+        TdlsTaskParams params = new TdlsTaskParams();
+        params.remoteIpAddress = remoteAddress;
+        params.enable = enable;
+        new TdlsTask().execute(params);
+    }
+
+
+    public void enableTdlsWithMacAddress(String remoteMacAddress, boolean enable) {
+        if (remoteMacAddress == null) {
+          throw new IllegalArgumentException("remoteMacAddress cannot be null");
+        }
+
+        mWifiStateMachine.enableTdls(remoteMacAddress, enable);
+    }
+
+    /**
+     * Get a reference to handler. This is used by a client to establish
+     * an AsyncChannel communication with WifiService
+     */
+    public Messenger getWifiServiceMessenger() {
+        enforceAccessPermission();
+        enforceChangePermission();
+        return new Messenger(mClientHandler);
+    }
+
+
+    /**
+     * Get the IP and proxy configuration file
+     */
+    public String getConfigFile() {
+        enforceAccessPermission();
+        return mWifiStateMachine.getConfigFile();
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                mWifiController.sendMessage(CMD_SCREEN_ON);
+            } else if (action.equals(Intent.ACTION_USER_PRESENT)) {
+                mWifiController.sendMessage(CMD_USER_PRESENT);
+            } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                mWifiController.sendMessage(CMD_SCREEN_OFF);
+            } else if (action.equals(Intent.ACTION_BATTERY_CHANGED)) {
+                int pluggedType = intent.getIntExtra("plugged", 0);
+                mWifiController.sendMessage(CMD_BATTERY_CHANGED, pluggedType, 0, null);
+            } else if (action.equals(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)) {
+                int state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE,
+                        BluetoothAdapter.STATE_DISCONNECTED);
+                mWifiStateMachine.sendBluetoothAdapterStateChange(state);
+            } else if (action.equals(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED)) {
+                boolean emergencyMode = intent.getBooleanExtra("phoneinECMState", false);
+                mWifiController.sendMessage(CMD_EMERGENCY_MODE_CHANGED, emergencyMode ? 1 : 0, 0);
+            }
+        }
+    };
+
+    /**
+     * Observes settings changes to scan always mode.
+     */
+    private void registerForScanModeChange() {
+        ContentObserver contentObserver = new ContentObserver(null) {
+            @Override
+            public void onChange(boolean selfChange) {
+                mSettingsStore.handleWifiScanAlwaysAvailableToggled();
+                mWifiController.sendMessage(CMD_SCAN_ALWAYS_MODE_CHANGED);
+            }
+        };
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE),
+                false, contentObserver);
+    }
+
+    private void registerForBroadcasts() {
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_USER_PRESENT);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
+        intentFilter.addAction(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION);
+        intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);
+        intentFilter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED);
+        mContext.registerReceiver(mReceiver, intentFilter);
+    }
+
+    @Override
+    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PackageManager.PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump WifiServiceWAP from from pid="
+                    + Binder.getCallingPid()
+                    + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        pw.println("Wi-Fi is " + mWifiStateMachine.syncGetWifiStateByName());
+        pw.println("Stay-awake conditions: " +
+                Settings.Global.getInt(mContext.getContentResolver(),
+                                       Settings.Global.STAY_ON_WHILE_PLUGGED_IN, 0));
+        pw.println("mMulticastEnabled " + mMulticastEnabled);
+        pw.println("mMulticastDisabled " + mMulticastDisabled);
+        mWifiController.dump(fd, pw, args);
+        mSettingsStore.dump(fd, pw, args);
+        mNotificationController.dump(fd, pw, args);
+        mTrafficPoller.dump(fd, pw, args);
+
+        pw.println("Latest scan results:");
+        List<ScanResult> scanResults = mWifiStateMachine.syncGetScanResultsList();
+        long nowMs = System.currentTimeMillis();
+        if (scanResults != null && scanResults.size() != 0) {
+            pw.println("    BSSID              Frequency  RSSI    Age      SSID " +
+                    "                                Flags");
+            for (ScanResult r : scanResults) {
+                long ageSec = 0;
+                long ageMilli = 0;
+                if (nowMs > r.seen && r.seen > 0) {
+                    ageSec = (nowMs - r.seen) / 1000;
+                    ageMilli = (nowMs - r.seen) % 1000;
+                }
+                String candidate = " ";
+                if (r.isAutoJoinCandidate > 0) candidate = "+";
+                pw.printf("  %17s  %9d  %5d  %3d.%03d%s   %-32s  %s\n",
+                                         r.BSSID,
+                                         r.frequency,
+                                         r.level,
+                                         ageSec, ageMilli,
+                                         candidate,
+                                         r.SSID == null ? "" : r.SSID,
+                                         r.capabilities);
+            }
+        }
+        pw.println();
+        pw.println("Locks acquired: " + mFullLocksAcquired + " full, " +
+                mFullHighPerfLocksAcquired + " full high perf, " +
+                mScanLocksAcquired + " scan");
+        pw.println("Locks released: " + mFullLocksReleased + " full, " +
+                mFullHighPerfLocksReleased + " full high perf, " +
+                mScanLocksReleased + " scan");
+        pw.println();
+        pw.println("Locks held:");
+        mLocks.dump(pw);
+
+        mWifiWatchdogStateMachine.dump(fd, pw, args);
+        pw.println();
+        mWifiStateMachine.dump(fd, pw, args);
+        pw.println();
+    }
+
+    private class WifiLock extends DeathRecipient {
+        WifiLock(int lockMode, String tag, IBinder binder, WorkSource ws) {
+            super(lockMode, tag, binder, ws);
+        }
+
+        public void binderDied() {
+            synchronized (mLocks) {
+                releaseWifiLockLocked(mBinder);
+            }
+        }
+
+        public String toString() {
+            return "WifiLock{" + mTag + " type=" + mMode + " binder=" + mBinder + "}";
+        }
+    }
+
+    class LockList {
+        private List<WifiLock> mList;
+
+        private LockList() {
+            mList = new ArrayList<WifiLock>();
+        }
+
+        synchronized boolean hasLocks() {
+            return !mList.isEmpty();
+        }
+
+        synchronized int getStrongestLockMode() {
+            if (mList.isEmpty()) {
+                return WifiManagerWAP.WIFI_MODE_FULL;
+            }
+
+            if (mFullHighPerfLocksAcquired > mFullHighPerfLocksReleased) {
+                return WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF;
+            }
+
+            if (mFullLocksAcquired > mFullLocksReleased) {
+                return WifiManagerWAP.WIFI_MODE_FULL;
+            }
+
+            return WifiManagerWAP.WIFI_MODE_SCAN_ONLY;
+        }
+
+        synchronized void updateWorkSource(WorkSource ws) {
+            for (int i = 0; i < mLocks.mList.size(); i++) {
+                ws.add(mLocks.mList.get(i).mWorkSource);
+            }
+        }
+
+        private void addLock(WifiLock lock) {
+            if (findLockByBinder(lock.mBinder) < 0) {
+                mList.add(lock);
+            }
+        }
+
+        private WifiLock removeLock(IBinder binder) {
+            int index = findLockByBinder(binder);
+            if (index >= 0) {
+                WifiLock ret = mList.remove(index);
+                ret.unlinkDeathRecipient();
+                return ret;
+            } else {
+                return null;
+            }
+        }
+
+        private int findLockByBinder(IBinder binder) {
+            int size = mList.size();
+            for (int i = size - 1; i >= 0; i--) {
+                if (mList.get(i).mBinder == binder)
+                    return i;
+            }
+            return -1;
+        }
+
+        private void dump(PrintWriter pw) {
+            for (WifiLock l : mList) {
+                pw.print("    ");
+                pw.println(l);
+            }
+        }
+    }
+
+    void enforceWakeSourcePermission(int uid, int pid) {
+        if (uid == android.os.Process.myUid()) {
+            return;
+        }
+        mContext.enforcePermission(android.Manifest.permission.UPDATE_DEVICE_STATS,
+                pid, uid, null);
+    }
+
+    public boolean acquireWifiLock(IBinder binder, int lockMode, String tag, WorkSource ws) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
+        if (lockMode != WifiManagerWAP.WIFI_MODE_FULL &&
+                lockMode != WifiManagerWAP.WIFI_MODE_SCAN_ONLY &&
+                lockMode != WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF) {
+            Slog.e(TAG, "Illegal argument, lockMode= " + lockMode);
+            if (DBG) throw new IllegalArgumentException("lockMode=" + lockMode);
+            return false;
+        }
+        if (ws != null && ws.size() == 0) {
+            ws = null;
+        }
+        if (ws != null) {
+            enforceWakeSourcePermission(Binder.getCallingUid(), Binder.getCallingPid());
+        }
+        if (ws == null) {
+            ws = new WorkSource(Binder.getCallingUid());
+        }
+        WifiLock wifiLock = new WifiLock(lockMode, tag, binder, ws);
+        synchronized (mLocks) {
+            return acquireWifiLockLocked(wifiLock);
+        }
+    }
+
+    private void noteAcquireWifiLock(WifiLock wifiLock) throws RemoteException {
+        switch(wifiLock.mMode) {
+            case WifiManagerWAP.WIFI_MODE_FULL:
+            case WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF:
+            case WifiManagerWAP.WIFI_MODE_SCAN_ONLY:
+                mBatteryStats.noteFullWifiLockAcquiredFromSource(wifiLock.mWorkSource);
+                break;
+        }
+    }
+
+    private void noteReleaseWifiLock(WifiLock wifiLock) throws RemoteException {
+        switch(wifiLock.mMode) {
+            case WifiManagerWAP.WIFI_MODE_FULL:
+            case WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF:
+            case WifiManagerWAP.WIFI_MODE_SCAN_ONLY:
+                mBatteryStats.noteFullWifiLockReleasedFromSource(wifiLock.mWorkSource);
+                break;
+        }
+    }
+
+    private boolean acquireWifiLockLocked(WifiLock wifiLock) {
+        if (DBG) Slog.d(TAG, "acquireWifiLockLocked: " + wifiLock);
+
+        mLocks.addLock(wifiLock);
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            noteAcquireWifiLock(wifiLock);
+            switch(wifiLock.mMode) {
+            case WifiManagerWAP.WIFI_MODE_FULL:
+                ++mFullLocksAcquired;
+                break;
+            case WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF:
+                ++mFullHighPerfLocksAcquired;
+                break;
+
+            case WifiManagerWAP.WIFI_MODE_SCAN_ONLY:
+                ++mScanLocksAcquired;
+                break;
+            }
+            mWifiController.sendMessage(CMD_LOCKS_CHANGED);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public void updateWifiLockWorkSource(IBinder lock, WorkSource ws) {
+        int uid = Binder.getCallingUid();
+        int pid = Binder.getCallingPid();
+        if (ws != null && ws.size() == 0) {
+            ws = null;
+        }
+        if (ws != null) {
+            enforceWakeSourcePermission(uid, pid);
+        }
+        long ident = Binder.clearCallingIdentity();
+        try {
+            synchronized (mLocks) {
+                int index = mLocks.findLockByBinder(lock);
+                if (index < 0) {
+                    throw new IllegalArgumentException("Wifi lock not active");
+                }
+                WifiLock wl = mLocks.mList.get(index);
+                noteReleaseWifiLock(wl);
+                wl.mWorkSource = ws != null ? new WorkSource(ws) : new WorkSource(uid);
+                noteAcquireWifiLock(wl);
+            }
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public boolean releaseWifiLock(IBinder lock) {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WAKE_LOCK, null);
+        synchronized (mLocks) {
+            return releaseWifiLockLocked(lock);
+        }
+    }
+
+    private boolean releaseWifiLockLocked(IBinder lock) {
+        boolean hadLock;
+
+        WifiLock wifiLock = mLocks.removeLock(lock);
+
+        if (DBG) Slog.d(TAG, "releaseWifiLockLocked: " + wifiLock);
+
+        hadLock = (wifiLock != null);
+
+        long ident = Binder.clearCallingIdentity();
+        try {
+            if (hadLock) {
+                noteReleaseWifiLock(wifiLock);
+                switch(wifiLock.mMode) {
+                    case WifiManagerWAP.WIFI_MODE_FULL:
+                        ++mFullLocksReleased;
+                        break;
+                    case WifiManagerWAP.WIFI_MODE_FULL_HIGH_PERF:
+                        ++mFullHighPerfLocksReleased;
+                        break;
+                    case WifiManagerWAP.WIFI_MODE_SCAN_ONLY:
+                        ++mScanLocksReleased;
+                        break;
+                }
+                mWifiController.sendMessage(CMD_LOCKS_CHANGED);
+            }
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+
+        return hadLock;
+    }
+
+    private abstract class DeathRecipient
+            implements IBinder.DeathRecipient {
+        String mTag;
+        int mMode;
+        IBinder mBinder;
+        WorkSource mWorkSource;
+
+        DeathRecipient(int mode, String tag, IBinder binder, WorkSource ws) {
+            super();
+            mTag = tag;
+            mMode = mode;
+            mBinder = binder;
+            mWorkSource = ws;
+            try {
+                mBinder.linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                binderDied();
+            }
+        }
+
+        void unlinkDeathRecipient() {
+            mBinder.unlinkToDeath(this, 0);
+        }
+    }
+
+    private class Multicaster extends DeathRecipient {
+        Multicaster(String tag, IBinder binder) {
+            super(Binder.getCallingUid(), tag, binder, null);
+        }
+
+        public void binderDied() {
+            Slog.e(TAG, "Multicaster binderDied");
+            synchronized (mMulticasters) {
+                int i = mMulticasters.indexOf(this);
+                if (i != -1) {
+                    removeMulticasterLocked(i, mMode);
+                }
+            }
+        }
+
+        public String toString() {
+            return "Multicaster{" + mTag + " binder=" + mBinder + "}";
+        }
+
+        public int getUid() {
+            return mMode;
+        }
+    }
+
+    public void initializeMulticastFiltering() {
+        enforceMulticastChangePermission();
+
+        synchronized (mMulticasters) {
+            // if anybody had requested filters be off, leave off
+            if (mMulticasters.size() != 0) {
+                return;
+            } else {
+                mWifiStateMachine.startFilteringMulticastV4Packets();
+            }
+        }
+    }
+
+    public void acquireMulticastLock(IBinder binder, String tag) {
+        enforceMulticastChangePermission();
+
+        synchronized (mMulticasters) {
+            mMulticastEnabled++;
+            mMulticasters.add(new Multicaster(tag, binder));
+            // Note that we could call stopFilteringMulticastV4Packets only when
+            // our new size == 1 (first call), but this function won't
+            // be called often and by making the stopPacket call each
+            // time we're less fragile and self-healing.
+            mWifiStateMachine.stopFilteringMulticastV4Packets();
+        }
+
+        int uid = Binder.getCallingUid();
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteWifiMulticastEnabled(uid);
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public void releaseMulticastLock() {
+        enforceMulticastChangePermission();
+
+        int uid = Binder.getCallingUid();
+        synchronized (mMulticasters) {
+            mMulticastDisabled++;
+            int size = mMulticasters.size();
+            for (int i = size - 1; i >= 0; i--) {
+                Multicaster m = mMulticasters.get(i);
+                if ((m != null) && (m.getUid() == uid)) {
+                    removeMulticasterLocked(i, uid);
+                }
+            }
+        }
+    }
+
+    private void removeMulticasterLocked(int i, int uid)
+    {
+        Multicaster removed = mMulticasters.remove(i);
+
+        if (removed != null) {
+            removed.unlinkDeathRecipient();
+        }
+        if (mMulticasters.size() == 0) {
+            mWifiStateMachine.startFilteringMulticastV4Packets();
+        }
+
+        final long ident = Binder.clearCallingIdentity();
+        try {
+            mBatteryStats.noteWifiMulticastDisabled(uid);
+        } catch (RemoteException e) {
+        } finally {
+            Binder.restoreCallingIdentity(ident);
+        }
+    }
+
+    public boolean isMulticastEnabled() {
+        enforceAccessPermission();
+
+        synchronized (mMulticasters) {
+            return (mMulticasters.size() > 0);
+        }
+    }
+
+    public WifiMonitor getWifiMonitor() {
+        return mWifiStateMachine.getWifiMonitor();
+    }
+
+    public void enableVerboseLogging(int verbose) {
+        enforceAccessPermission();
+        mWifiStateMachine.enableVerboseLogging(verbose);
+    }
+
+    public int getVerboseLoggingLevel() {
+        enforceAccessPermission();
+        return mWifiStateMachine.getVerboseLoggingLevel();
+    }
+
+    public void enableAggressiveHandover(int enabled) {
+        enforceAccessPermission();
+        mWifiStateMachine.enableAggressiveHandover(enabled);
+    }
+
+    public int getAggressiveHandover() {
+        enforceAccessPermission();
+        return mWifiStateMachine.getAggressiveHandover();
+    }
+
+    public void setAllowScansWithTraffic(int enabled) {
+        enforceAccessPermission();
+        mWifiStateMachine.setAllowScansWithTraffic(enabled);
+    }
+
+    public int getAllowScansWithTraffic() {
+        enforceAccessPermission();
+        return mWifiStateMachine.getAllowScansWithTraffic();
+    }
+
+    /* Return the Wifi Connection statistics object */
+    public WifiConnectionStatistics getConnectionStatistics() {
+        enforceAccessPermission();
+        enforceReadCredentialPermission();
+        if (mWifiStateMachineChannel != null) {
+            return mWifiStateMachine.syncGetConnectionStatistics(mWifiStateMachineChannel);
+        } else {
+            Slog.e(TAG, "mWifiStateMachineChannel is not initialized");
+            return null;
+        }
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiServiceWAP.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.content.Context;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiScanner;
+import android.util.Log;
+import com.android.server.SystemService;
+
+import java.util.List;
+
+public final class WifiServiceWAP extends SystemService {
+
+    private static final String TAG = "WifiServiceWAP";
+    final WifiServiceImplWAP mImpl;
+
+    public WifiServiceWAP(Context context) {
+        super(context);
+        mImpl = new WifiServiceImplWAP(context);
+    }
+
+    @Override
+    public void onStart() {
+        Log.i(TAG, "Registering " + Context.WAP_SERVICE);
+        publishBinderService(Context.WAP_SERVICE, mImpl);
+    }
+
+    @Override
+    public void onBootPhase(int phase) {
+        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
+//            mImpl.checkAndStartWifi();
+        }
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStore.java
@@ -84,7 +84,6 @@
         if (mAirplaneModeOn && !isAirplaneToggleable()) {
             return false;
         }
-
         if (wifiEnabled) {
             if (mAirplaneModeOn) {
                 persistWifiState(WIFI_ENABLED_AIRPLANE_OVERRIDE);
@@ -106,7 +105,6 @@
         if (!isAirplaneSensitive()) {
             return false;
         }
-
         mAirplaneModeOn = getPersistedAirplaneModeOn();
         if (mAirplaneModeOn) {
             // Wifi disabled due to airplane on
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStoreWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStoreWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStoreWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiSettingsStoreWAP.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import android.content.ContentResolver;
+import android.content.Context;
+import android.provider.Settings;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+/* Tracks persisted settings for Wi-Fi and airplane mode interaction */
+final class WifiSettingsStoreWAP {
+    /* Values tracked in Settings.Global.WIFI_ON */
+    private static final int WIFI_DISABLED                      = 0;
+    private static final int WIFI_ENABLED                       = 1;
+    /* Wifi enabled while in airplane mode */
+    private static final int WIFI_ENABLED_AIRPLANE_OVERRIDE     = 2;
+    /* Wifi disabled due to airplane mode on */
+    private static final int WIFI_DISABLED_AIRPLANE_ON          = 3;
+
+    /* Persisted state that tracks the wifi & airplane interaction from settings */
+    private int mPersistWifiState = WIFI_DISABLED;
+    /* Tracks current airplane mode state */
+    private boolean mAirplaneModeOn = false;
+
+    /* Tracks the setting of scan being available even when wi-fi is turned off
+     */
+    private boolean mScanAlwaysAvailable;
+
+    private final Context mContext;
+
+    /* Tracks if we have checked the saved wi-fi state after boot */
+    private boolean mCheckSavedStateAtBoot = false;
+
+    WifiSettingsStoreWAP(Context context) {
+        mContext = context;
+        mAirplaneModeOn = getPersistedAirplaneModeOn();
+        mPersistWifiState = getPersistedWifiState();
+        mScanAlwaysAvailable = getPersistedScanAlwaysAvailable();
+    }
+
+    synchronized boolean isWifiToggleEnabled() {
+        if (!mCheckSavedStateAtBoot) {
+            mCheckSavedStateAtBoot = true;
+            if (testAndClearWifiSavedState()) return true;
+        }
+
+        if (mAirplaneModeOn) {
+            return mPersistWifiState == WIFI_ENABLED_AIRPLANE_OVERRIDE;
+        } else {
+            return mPersistWifiState != WIFI_DISABLED;
+        }
+    }
+
+    /**
+     * Returns true if airplane mode is currently on.
+     * @return {@code true} if airplane mode is on.
+     */
+    synchronized boolean isAirplaneModeOn() {
+       return mAirplaneModeOn;
+    }
+
+    synchronized boolean isScanAlwaysAvailable() {
+        return !mAirplaneModeOn && mScanAlwaysAvailable;
+    }
+
+    synchronized boolean handleWifiToggled(boolean wifiEnabled) {
+        // Can Wi-Fi be toggled in airplane mode ?
+        if (mAirplaneModeOn && !isAirplaneToggleable()) {
+            return false;
+        }
+        if (wifiEnabled) {
+            if (mAirplaneModeOn) {
+                persistWifiState(WIFI_ENABLED_AIRPLANE_OVERRIDE);
+            } else {
+                persistWifiState(WIFI_ENABLED);
+            }
+        } else {
+            // When wifi state is disabled, we do not care
+            // if airplane mode is on or not. The scenario of
+            // wifi being disabled due to airplane mode being turned on
+            // is handled handleAirplaneModeToggled()
+            persistWifiState(WIFI_DISABLED);
+        }
+        return true;
+    }
+
+    synchronized boolean handleAirplaneModeToggled() {
+        // Is Wi-Fi sensitive to airplane mode changes ?
+        if (!isAirplaneSensitive()) {
+            return false;
+        }
+
+        mAirplaneModeOn = getPersistedAirplaneModeOn();
+        if (mAirplaneModeOn) {
+            // Wifi disabled due to airplane on
+            if (mPersistWifiState == WIFI_ENABLED) {
+                persistWifiState(WIFI_DISABLED_AIRPLANE_ON);
+            }
+        } else {
+            /* On airplane mode disable, restore wifi state if necessary */
+            if (testAndClearWifiSavedState() ||
+                    mPersistWifiState == WIFI_ENABLED_AIRPLANE_OVERRIDE) {
+                persistWifiState(WIFI_ENABLED);
+            }
+        }
+        return true;
+    }
+
+    synchronized void handleWifiScanAlwaysAvailableToggled() {
+        mScanAlwaysAvailable = getPersistedScanAlwaysAvailable();
+    }
+
+    void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("mPersistWifiState " + mPersistWifiState);
+        pw.println("mAirplaneModeOn " + mAirplaneModeOn);
+    }
+
+    private void persistWifiState(int state) {
+        final ContentResolver cr = mContext.getContentResolver();
+        mPersistWifiState = state;
+        Settings.Global.putInt(cr, Settings.Global.WIFI_ON, state);
+    }
+
+    /* Does Wi-Fi need to be disabled when airplane mode is on ? */
+    private boolean isAirplaneSensitive() {
+        String airplaneModeRadios = Settings.Global.getString(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_RADIOS);
+        return airplaneModeRadios == null
+                || airplaneModeRadios.contains(Settings.Global.RADIO_WIFI);
+    }
+
+    /* Is Wi-Fi allowed to be re-enabled while airplane mode is on ? */
+    private boolean isAirplaneToggleable() {
+        String toggleableRadios = Settings.Global.getString(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
+        return toggleableRadios != null
+                && toggleableRadios.contains(Settings.Global.RADIO_WIFI);
+    }
+
+     /* After a reboot, we restore wi-fi to be on if it was turned off temporarily for tethering.
+      * The settings app tracks the saved state, but the framework has to check it at boot to
+      * make sure the wi-fi is turned on in case it was turned off for the purpose of tethering.
+      *
+      * Note that this is not part of the regular WIFI_ON setting because this only needs to
+      * be controlled through the settings app and not the Wi-Fi public API.
+      */
+    private boolean testAndClearWifiSavedState() {
+        final ContentResolver cr = mContext.getContentResolver();
+        int wifiSavedState = 0;
+        try {
+            wifiSavedState = Settings.Global.getInt(cr, Settings.Global.WIFI_SAVED_STATE);
+            if(wifiSavedState == 1)
+                Settings.Global.putInt(cr, Settings.Global.WIFI_SAVED_STATE, 0);
+        } catch (Settings.SettingNotFoundException e) {
+            ;
+        }
+        return (wifiSavedState == 1);
+    }
+
+    private int getPersistedWifiState() {
+        final ContentResolver cr = mContext.getContentResolver();
+        try {
+            return Settings.Global.getInt(cr, Settings.Global.WIFI_ON);
+        } catch (Settings.SettingNotFoundException e) {
+            Settings.Global.putInt(cr, Settings.Global.WIFI_ON, WIFI_DISABLED);
+            return WIFI_DISABLED;
+        }
+    }
+
+    private boolean getPersistedAirplaneModeOn() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_ON, 0) == 1;
+    }
+
+    private boolean getPersistedScanAlwaysAvailable() {
+        return Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE,
+                0) == 1;
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
@@ -4601,7 +4601,6 @@
         @Override
         public boolean processMessage(Message message) {
             logStateAndMessage(message, getClass().getSimpleName());
-
             switch (message.what) {
                 case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: {
                     AsyncChannel ac = (AsyncChannel) message.obj;
@@ -5052,7 +5051,6 @@
         @Override
         public boolean processMessage(Message message) {
             logStateAndMessage(message, getClass().getSimpleName());
-
             switch(message.what) {
                 case CMD_STOP_SUPPLICANT:   /* Supplicant stopped by user */
                     if (mP2pSupported) {
diff -Nuar a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachineWAP.java b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachineWAP.java
--- a/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachineWAP.java
+++ b/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachineWAP.java
@@ -0,0 +1,8550 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.wifi;
+
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_DISABLED;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_DISABLING;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_ENABLED;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_ENABLING;
+import static android.net.wifi.WifiManagerWAP.WIFI_STATE_UNKNOWN;
+
+/**
+ * TODO:
+ * Deprecate WIFI_STATE_UNKNOWN
+ */
+import static android.net.wifi.WifiManagerWAP.WIFI_AP_STATE_DISABLED;
+import static android.net.wifi.WifiManagerWAP.WIFI_AP_STATE_DISABLING;
+import static android.net.wifi.WifiManagerWAP.WIFI_AP_STATE_ENABLED;
+import static android.net.wifi.WifiManagerWAP.WIFI_AP_STATE_ENABLING;
+import static android.net.wifi.WifiManagerWAP.WIFI_AP_STATE_FAILED;
+
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+import android.app.backup.IBackupManager;
+import android.bluetooth.BluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.DhcpResults;
+import android.net.DhcpStateMachine;
+import android.net.InterfaceConfiguration;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.NetworkAgent;
+import android.net.NetworkCapabilities;
+import android.net.NetworkFactory;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.NetworkUtils;
+import android.net.RouteInfo;
+import android.net.StaticIpConfiguration;
+import android.net.TrafficStats;
+import android.net.wifi.*;
+import android.net.wifi.SupplicantState;
+import android.net.wifi.WpsResult.Status;
+import android.net.wifi.p2p.IWifiP2pManager;
+import android.os.BatteryStats;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.PowerManager;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.util.LruCache;
+import android.text.TextUtils;
+import android.util.Log;
+
+import com.android.internal.R;
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.util.AsyncChannel;
+import com.android.internal.util.Protocol;
+import com.android.internal.util.State;
+import com.android.internal.util.StateMachine;
+import com.android.server.net.BaseNetworkObserver;
+import com.android.server.net.NetlinkTracker;
+
+import com.android.server.wifi.p2p.WifiP2pServiceImpl;
+import android.net.wifi.p2p.WifiP2pManager;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.net.InetAddress;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.regex.Pattern;
+import java.io.FileReader;
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.net.Inet4Address;
+
+/**
+ * Track the state of Wifi connectivity. All event handling is done here,
+ * and all changes in connectivity state are initiated here.
+ *
+ * Wi-Fi now supports three modes of operation: Client, SoftAp and p2p
+ * In the current implementation, we support concurrent wifi p2p and wifi operation.
+ * The WifiStateMachine handles SoftAp and Client operations while WifiP2pService
+ * handles p2p operation.
+ *
+ * @hide
+ */
+public class WifiStateMachineWAP extends StateMachine {
+
+    private static final String NETWORKTYPE = "WIFI";
+    private static boolean DBG = false;
+    private static boolean VDBG = false;
+    private static boolean VVDBG = false;
+    private static boolean mLogMessages = false;
+
+    private static final int ONE_HOUR_MILLI = 1000 * 60 * 60;
+
+    private static final String GOOGLE_OUI = "DA-A1-19";
+
+    private static final String EXTRA_FEATURE_ID = "cneFeatureId";
+
+    private static final String EXTRA_FEATURE_PARAMETER = "cneFeatureParameter";
+
+    private static final String EXTRA_PARAMETER_VALUE = "cneParameterValue";
+
+    private static final int FEATURE_ID = 1;
+
+    private static final int FEATURE_PARAM = 1;
+
+    private static final int FEATURE_OFF = 1;
+
+    private static final int FEATURE_ON = FEATURE_OFF + 1;
+
+    /* temporary debug flag - best network selection development */
+    private static boolean PDBG = false;
+
+    /* debug flag, indicating if handling of ASSOCIATION_REJECT ended up blacklisting
+     * the corresponding BSSID.
+     */
+    private boolean didBlackListBSSID = false;
+
+    /**
+     * Log with error attribute
+     *
+     * @param s is string log
+     */
+    protected void loge(String s) {
+        Log.e(getName(), s);
+    }
+    protected void log(String s) {;
+        Log.e(getName(), s);
+    }
+
+    private WifiMonitor mWifiMonitor;
+    private WifiNative mWifiNative;
+    private WifiConfigStore mWifiConfigStore;
+    private WifiAutoJoinControllerWAP mWifiAutoJoinController;
+    private INetworkManagementService mNwService;
+    private ConnectivityManager mCm;
+    private WifiManager mWifiManager;
+
+    private final boolean mP2pSupported;
+    private final AtomicBoolean mP2pConnected = new AtomicBoolean(false);
+    private boolean mTemporarilyDisconnectWifi = false;
+    private final String mPrimaryDeviceType;
+
+    /* Scan results handling */
+    private List<ScanResult> mScanResults = new ArrayList<ScanResult>();
+    private static final Pattern scanResultPattern = Pattern.compile("\t+");
+    private static final int SCAN_RESULT_CACHE_SIZE = 160;
+    private final LruCache<String, ScanResult> mScanResultCache;
+    // For debug, number of known scan results that were found as part of last scan result event,
+    // as well the number of scans results returned by the supplicant with that message
+    private int mNumScanResultsKnown;
+    private int mNumScanResultsReturned;
+    private int mWpsNetworkId = -1;
+    private boolean mWpsSuccess = false;
+    private final int reason3 = 3;
+
+    /* Batch scan results */
+    private final List<BatchedScanResult> mBatchedScanResults =
+            new ArrayList<BatchedScanResult>();
+    private int mBatchedScanOwnerUid = UNKNOWN_SCAN_SOURCE;
+    private int mExpectedBatchedScans = 0;
+    private long mBatchedScanMinPollTime = 0;
+
+    private boolean mScreenOn = false;
+
+    /* Chipset supports background scan */
+    private final boolean mBackgroundScanSupported;
+
+    /* Flag to verify backgroundScan is configured successfully */
+    private boolean mBackgroundScanConfigured = false;
+
+    private String mInterfaceName;
+    /* Tethering interface could be separate from wlan interface */
+    private String mTetherInterfaceName;
+
+    private int mLastSignalLevel = -1;
+    private String mLastBssid;
+    private int mLastNetworkId; // The network Id we successfully joined
+    private boolean linkDebouncing = false;
+
+    // Testing various network disconnect cases by sending lots of spurious
+    // disconnect to supplicant
+    private boolean testNetworkDisconnect = false;
+
+    private boolean mEnableRssiPolling = false;
+    private boolean mEnableBackgroundScan = false;
+    private boolean mDisabled5GhzFrequencies = false;
+    private int mRssiPollToken = 0;
+    /* 3 operational states for STA operation: CONNECT_MODE, SCAN_ONLY_MODE, SCAN_ONLY_WIFI_OFF_MODE
+    * In CONNECT_MODE, the STA can scan and connect to an access point
+    * In SCAN_ONLY_MODE, the STA can only scan for access points
+    * In SCAN_ONLY_WIFI_OFF_MODE, the STA can only scan for access points with wifi toggle being off
+    */
+    private int mOperationalMode = CONNECT_MODE;
+    private boolean mIsScanOngoing = false;
+    private boolean mIsFullScanOngoing = false;
+    private final Queue<Message> mBufferedScanMsg = new LinkedList<Message>();
+    private WorkSource mScanWorkSource = null;
+    private static final int UNKNOWN_SCAN_SOURCE = -1;
+    private static final int SCAN_ALARM_SOURCE = -2;
+    private static final int ADD_OR_UPDATE_SOURCE = -3;
+
+    private static final int SCAN_REQUEST_BUFFER_MAX_SIZE = 10;
+    private static final String CUSTOMIZED_SCAN_SETTING = "customized_scan_settings";
+    private static final String CUSTOMIZED_SCAN_WORKSOURCE = "customized_scan_worksource";
+    private static final String SCAN_REQUEST_TIME = "scan_request_time";
+
+    private static final String BATCHED_SETTING = "batched_settings";
+    private static final String BATCHED_WORKSOURCE = "batched_worksource";
+
+    /* Tracks if state machine has received any screen state change broadcast yet.
+     * We can miss one of these at boot.
+     */
+    private AtomicBoolean mScreenBroadcastReceived = new AtomicBoolean(false);
+
+    private boolean mBluetoothConnectionActive = false;
+
+    private PowerManager.WakeLock mSuspendWakeLock;
+
+    /**
+     * Interval in milliseconds between polling for RSSI
+     * and linkspeed information
+     */
+    private static final int POLL_RSSI_INTERVAL_MSECS = 3000;
+
+    /**
+     * Interval in milliseconds between receiving a disconnect event
+     * while connected to a good AP, and handling the disconnect proper
+     */
+    private static final int LINK_FLAPPING_DEBOUNCE_MSEC = 7000;
+
+    /**
+     * Delay between supplicant restarts upon failure to establish connection
+     */
+    private static final int SUPPLICANT_RESTART_INTERVAL_MSECS = 5000;
+
+    /**
+     * Number of times we attempt to restart supplicant
+     */
+    private static final int SUPPLICANT_RESTART_TRIES = 5;
+
+    private int mSupplicantRestartCount = 0;
+    /* Tracks sequence number on stop failure message */
+    private int mSupplicantStopFailureToken = 0;
+
+    /**
+     * Tether state change notification time out
+     */
+    private static final int TETHER_NOTIFICATION_TIME_OUT_MSECS = 5000;
+
+    /* Tracks sequence number on a tether notification time out */
+    private int mTetherToken = 0;
+
+    /**
+     * Driver start time out.
+     */
+    private static final int DRIVER_START_TIME_OUT_MSECS = 10000;
+
+    /* Tracks sequence number on a driver time out */
+    private int mDriverStartToken = 0;
+
+    /**
+     * The link properties of the wifi interface.
+     * Do not modify this directly; use updateLinkProperties instead.
+     */
+    private LinkProperties mLinkProperties;
+
+    /* Tracks sequence number on a periodic scan message */
+    private int mPeriodicScanToken = 0;
+
+    /* Tracks sequence number on a periodic scan message in case of PNO failure */
+    private int mPnoPeriodicScanToken = 0;
+
+    // Wakelock held during wifi start/stop and driver load/unload
+    private PowerManager.WakeLock mWakeLock;
+
+    private Context mContext;
+
+    private final Object mDhcpResultsLock = new Object();
+    private DhcpResults mDhcpResults;
+    private WifiInfo mWifiInfo;
+    private NetworkInfo mNetworkInfo;
+    private NetworkCapabilities mNetworkCapabilities;
+    private SupplicantStateTrackerWAP mSupplicantStateTracker;
+    private DhcpStateMachine mDhcpStateMachine;
+    private boolean mDhcpActive = false;
+
+    private int mWifiLinkLayerStatsSupported = 4; // Temporary disable
+
+    private final AtomicInteger mCountryCodeSequence = new AtomicInteger();
+
+    // Whether the state machine goes thru the Disconnecting->Disconnected->ObtainingIpAddress
+    private int mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+
+    // Roaming failure count
+    private int mRoamFailCount = 0;
+
+    // This is the BSSID we are trying to associate to, it can be set to "any"
+    // if we havent selected a BSSID for joining.
+    // The BSSID we are associated to is found in mWifiInfo
+    private String mTargetRoamBSSID = "any";
+
+    private long mLastDriverRoamAttempt = 0;
+
+    private WifiConfiguration targetWificonfiguration = null;
+
+    // Used as debug to indicate which configuration last was saved
+    private WifiConfiguration lastSavedConfigurationAttempt = null;
+
+    // Used as debug to indicate which configuration last was removed
+    private WifiConfiguration lastForgetConfigurationAttempt = null;
+
+    boolean isRoaming() {
+        return mAutoRoaming == WifiAutoJoinControllerWAP.AUTO_JOIN_ROAMING
+                || mAutoRoaming == WifiAutoJoinControllerWAP.AUTO_JOIN_EXTENDED_ROAMING;
+    }
+
+    public void autoRoamSetBSSID(int netId, String bssid) {
+        autoRoamSetBSSID(mWifiConfigStore.getWifiConfiguration(netId), bssid);
+    }
+
+    public boolean autoRoamSetBSSID(WifiConfiguration config, String bssid) {
+        boolean ret = true;
+        if (mTargetRoamBSSID == null) mTargetRoamBSSID = "any";
+        if (bssid == null) bssid = "any";
+        if (config == null) return false; // Nothing to do
+
+        if (mTargetRoamBSSID != null && bssid == mTargetRoamBSSID && bssid == config.BSSID) {
+            return false; // We didnt change anything
+        }
+        if (!mTargetRoamBSSID.equals("any") && bssid.equals("any")) {
+            // Changing to ANY
+            if (!mWifiConfigStore.roamOnAny) {
+                ret =  false; // Nothing to do
+            }
+        }
+        if (VDBG) {
+           loge("autoRoamSetBSSID " + bssid
+                   + " key=" + config.configKey());
+        }
+        config.autoJoinBSSID = bssid;
+        mTargetRoamBSSID = bssid;
+        mWifiConfigStore.saveWifiConfigBSSID(config);
+        return ret;
+    }
+
+    /**
+     * Subset of link properties coming from netlink.
+     * Currently includes IPv4 and IPv6 addresses. In the future will also include IPv6 DNS servers
+     * and domains obtained from router advertisements (RFC 6106).
+     */
+    private NetlinkTracker mNetlinkTracker;
+
+    private AlarmManager mAlarmManager;
+    private PendingIntent mScanIntent;
+    private PendingIntent mDriverStopIntent;
+    private PendingIntent mBatchedScanIntervalIntent;
+
+    /* Tracks current frequency mode */
+    private AtomicInteger mFrequencyBand = new AtomicInteger(WifiManagerWAP.WIFI_FREQUENCY_BAND_AUTO);
+
+    /* Tracks if we are filtering Multicast v4 packets. Default is to filter. */
+    private AtomicBoolean mFilteringMulticastV4Packets = new AtomicBoolean(true);
+
+    // Channel for sending replies.
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+
+  //  private WifiP2pServiceImpl mWifiP2pServiceImpl;
+
+    // Used to initiate a connection with WifiP2pService
+    private AsyncChannel mWifiP2pChannel;
+    private AsyncChannel mWifiApConfigChannel;
+
+    private WifiNetworkFactory mNetworkFactory;
+    private WifiNetworkAgent mNetworkAgent;
+
+    // Keep track of various statistics, for retrieval by System Apps, i.e. under @SystemApi
+    // We should really persist that into the networkHistory.txt file, and read it back when
+    // WifiStateMachine starts up
+    private WifiConnectionStatistics mWifiConnectionStatistics = new WifiConnectionStatistics();
+
+    // Used to filter out requests we couldn't possibly satisfy.
+    private final NetworkCapabilities mNetworkCapabilitiesFilter = new NetworkCapabilities();
+
+    /* The base for wifi message types */
+    static final int BASE = Protocol.BASE_WIFI;
+    /* Start the supplicant */
+    static final int CMD_START_SUPPLICANT                 = BASE + 11;
+    /* Stop the supplicant */
+    static final int CMD_STOP_SUPPLICANT                  = BASE + 12;
+    /* Start the driver */
+    static final int CMD_START_DRIVER                     = BASE + 13;
+    /* Stop the driver */
+    static final int CMD_STOP_DRIVER                      = BASE + 14;
+    /* Indicates Static IP succeeded */
+    static final int CMD_STATIC_IP_SUCCESS                = BASE + 15;
+    /* Indicates Static IP failed */
+    static final int CMD_STATIC_IP_FAILURE                = BASE + 16;
+    /* Indicates supplicant stop failed */
+    static final int CMD_STOP_SUPPLICANT_FAILED           = BASE + 17;
+    /* Delayed stop to avoid shutting down driver too quick*/
+    static final int CMD_DELAYED_STOP_DRIVER              = BASE + 18;
+    /* A delayed message sent to start driver when it fail to come up */
+    static final int CMD_DRIVER_START_TIMED_OUT           = BASE + 19;
+
+    /* Start the soft access point */
+    static final int CMD_START_AP                         = BASE + 21;
+    /* Indicates soft ap start succeeded */
+    static final int CMD_START_AP_SUCCESS                 = BASE + 22;
+    /* Indicates soft ap start failed */
+    static final int CMD_START_AP_FAILURE                 = BASE + 23;
+    /* Stop the soft access point */
+    static final int CMD_STOP_AP                          = BASE + 24;
+    /* Set the soft access point configuration */
+    static final int CMD_SET_AP_CONFIG                    = BASE + 25;
+    /* Soft access point configuration set completed */
+    static final int CMD_SET_AP_CONFIG_COMPLETED          = BASE + 26;
+    /* Request the soft access point configuration */
+    static final int CMD_REQUEST_AP_CONFIG                = BASE + 27;
+    /* Response to access point configuration request */
+    static final int CMD_RESPONSE_AP_CONFIG               = BASE + 28;
+    /* Invoked when getting a tether state change notification */
+    static final int CMD_TETHER_STATE_CHANGE              = BASE + 29;
+    /* A delayed message sent to indicate tether state change failed to arrive */
+    static final int CMD_TETHER_NOTIFICATION_TIMED_OUT    = BASE + 30;
+
+    static final int CMD_BLUETOOTH_ADAPTER_STATE_CHANGE   = BASE + 31;
+
+    /* Supplicant commands */
+    /* Is supplicant alive ? */
+    static final int CMD_PING_SUPPLICANT                  = BASE + 51;
+    /* Add/update a network configuration */
+    static final int CMD_ADD_OR_UPDATE_NETWORK            = BASE + 52;
+    /* Delete a network */
+    static final int CMD_REMOVE_NETWORK                   = BASE + 53;
+    /* Enable a network. The device will attempt a connection to the given network. */
+    static final int CMD_ENABLE_NETWORK                   = BASE + 54;
+    /* Enable all networks */
+    static final int CMD_ENABLE_ALL_NETWORKS              = BASE + 55;
+    /* Blacklist network. De-prioritizes the given BSSID for connection. */
+    static final int CMD_BLACKLIST_NETWORK                = BASE + 56;
+    /* Clear the blacklist network list */
+    static final int CMD_CLEAR_BLACKLIST                  = BASE + 57;
+    /* Save configuration */
+    static final int CMD_SAVE_CONFIG                      = BASE + 58;
+    /* Get configured networks */
+    static final int CMD_GET_CONFIGURED_NETWORKS          = BASE + 59;
+    /* Get available frequencies */
+    static final int CMD_GET_CAPABILITY_FREQ              = BASE + 60;
+    /* Get adaptors */
+    static final int CMD_GET_SUPPORTED_FEATURES           = BASE + 61;
+    /* Get configured networks with real preSharedKey */
+    static final int CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS = BASE + 62;
+    /* Get Link Layer Stats thru HAL */
+    static final int CMD_GET_LINK_LAYER_STATS             = BASE + 63;
+    /* Supplicant commands after driver start*/
+    /* Initiate a scan */
+    static final int CMD_START_SCAN                       = BASE + 71;
+    /* Set operational mode. CONNECT, SCAN ONLY, SCAN_ONLY with Wi-Fi off mode */
+    static final int CMD_SET_OPERATIONAL_MODE             = BASE + 72;
+    /* Disconnect from a network */
+    static final int CMD_DISCONNECT                       = BASE + 73;
+    /* Reconnect to a network */
+    static final int CMD_RECONNECT                        = BASE + 74;
+    /* Reassociate to a network */
+    static final int CMD_REASSOCIATE                      = BASE + 75;
+    /* Get Connection Statistis */
+    static final int CMD_GET_CONNECTION_STATISTICS        = BASE + 76;
+
+    /* Controls suspend mode optimizations
+     *
+     * When high perf mode is enabled, suspend mode optimizations are disabled
+     *
+     * When high perf mode is disabled, suspend mode optimizations are enabled
+     *
+     * Suspend mode optimizations include:
+     * - packet filtering
+     * - turn off roaming
+     * - DTIM wake up settings
+     */
+    static final int CMD_SET_HIGH_PERF_MODE               = BASE + 77;
+    /* Set the country code */
+    static final int CMD_SET_COUNTRY_CODE                 = BASE + 80;
+    /* Enables RSSI poll */
+    static final int CMD_ENABLE_RSSI_POLL                 = BASE + 82;
+    /* RSSI poll */
+    static final int CMD_RSSI_POLL                        = BASE + 83;
+    /* Set up packet filtering */
+    static final int CMD_START_PACKET_FILTERING           = BASE + 84;
+    /* Clear packet filter */
+    static final int CMD_STOP_PACKET_FILTERING            = BASE + 85;
+    /* Enable suspend mode optimizations in the driver */
+    static final int CMD_SET_SUSPEND_OPT_ENABLED          = BASE + 86;
+    /* Delayed NETWORK_DISCONNECT */
+    static final int CMD_DELAYED_NETWORK_DISCONNECT       = BASE + 87;
+    /* When there are no saved networks, we do a periodic scan to notify user of
+     * an open network */
+    static final int CMD_NO_NETWORKS_PERIODIC_SCAN        = BASE + 88;
+    /* Test network Disconnection NETWORK_DISCONNECT */
+    static final int CMD_TEST_NETWORK_DISCONNECT          = BASE + 89;
+    private int testNetworkDisconnectCounter = 0;
+
+    /* arg1 values to CMD_STOP_PACKET_FILTERING and CMD_START_PACKET_FILTERING */
+    static final int MULTICAST_V6  = 1;
+    static final int MULTICAST_V4  = 0;
+
+   /* Set the frequency band */
+    static final int CMD_SET_FREQUENCY_BAND               = BASE + 90;
+    /* Enable TDLS on a specific MAC address */
+    static final int CMD_ENABLE_TDLS                      = BASE + 92;
+    /* DHCP/IP configuration watchdog */
+    static final int CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER    = BASE + 93;
+    /* When there are saved networks and PNO fails, we do a periodic scan to notify
+       a saved/open network in suspend mode */
+    static final int CMD_PNO_PERIODIC_SCAN                = BASE + 94;
+
+    /**
+     * Make this timer 40 seconds, which is about the normal DHCP timeout.
+     * In no valid case, the WiFiStateMachine should remain stuck in ObtainingIpAddress
+     * for more than 30 seconds.
+     */
+    static final int OBTAINING_IP_ADDRESS_GUARD_TIMER_MSEC = 40000;
+
+    int obtainingIpWatchdogCount = 0;
+
+    /* Commands from/to the SupplicantStateTracker */
+    /* Reset the supplicant state tracker */
+    static final int CMD_RESET_SUPPLICANT_STATE           = BASE + 111;
+
+
+    /**
+     * Watchdog for protecting against b/16823537
+     * Leave time for 4-ways handshake to succeed
+     */
+    static final int ROAM_GUARD_TIMER_MSEC = 15000;
+
+    int roamWatchdogCount = 0;
+    /* Roam state watchdog */
+    static final int CMD_ROAM_WATCHDOG_TIMER    = BASE + 94;
+    /* Screen change intent handling */
+    static final int CMD_SCREEN_STATE_CHANGED              = BASE + 95;
+
+    int disconnectingWatchdogCount = 0;
+    static final int DISCONNECTING_GUARD_TIMER_MSEC = 5000;
+
+    /* Disconnecting state watchdog */
+    static final int CMD_DISCONNECTING_WATCHDOG_TIMER     = BASE + 96;
+
+    /* P2p commands */
+    /* We are ok with no response here since we wont do much with it anyway */
+    public static final int CMD_ENABLE_P2P                = BASE + 131;
+    /* In order to shut down supplicant cleanly, we wait till p2p has
+     * been disabled */
+    public static final int CMD_DISABLE_P2P_REQ           = BASE + 132;
+    public static final int CMD_DISABLE_P2P_RSP           = BASE + 133;
+
+    public static final int CMD_BOOT_COMPLETED            = BASE + 134;
+
+    /* change the batch scan settings.
+     * arg1 = responsible UID
+     * arg2 = csph (channel scans per hour)
+     * obj = bundle with the new settings and the optional worksource
+     */
+    public static final int CMD_SET_BATCHED_SCAN          = BASE + 135;
+    public static final int CMD_START_NEXT_BATCHED_SCAN   = BASE + 136;
+    public static final int CMD_POLL_BATCHED_SCAN         = BASE + 137;
+
+    /* We now have a valid IP configuration. */
+    static final int CMD_IP_CONFIGURATION_SUCCESSFUL      = BASE + 138;
+    /* We no longer have a valid IP configuration. */
+    static final int CMD_IP_CONFIGURATION_LOST            = BASE + 139;
+    /* Link configuration (IP address, DNS, ...) changes notified via netlink */
+    static final int CMD_UPDATE_LINKPROPERTIES            = BASE + 140;
+
+    /* Supplicant is trying to associate to a given BSSID */
+    static final int CMD_TARGET_BSSID                     = BASE + 141;
+
+    /* Reload all networks and reconnect */
+    static final int CMD_RELOAD_TLS_AND_RECONNECT         = BASE + 142;
+
+    static final int CMD_AUTO_CONNECT                     = BASE + 143;
+
+    static final int network_status_unwanted_disconnect = 0;
+    static final int network_status_unwanted_disable_autojoin = 1;
+
+    static final int CMD_UNWANTED_NETWORK                 = BASE + 144;
+
+    static final int CMD_AUTO_ROAM                        = BASE + 145;
+
+    static final int CMD_AUTO_SAVE_NETWORK                = BASE + 146;
+
+    static final int CMD_ASSOCIATED_BSSID                = BASE + 147;
+
+    /* Supplicant is trying to associate to a given SSID */
+    static final int CMD_TARGET_SSID                     = BASE + 148;
+
+    /* Wifi state machine modes of operation */
+    /* CONNECT_MODE - connect to any 'known' AP when it becomes available */
+    public static final int CONNECT_MODE                   = 1;
+    /* SCAN_ONLY_MODE - don't connect to any APs; scan, but only while apps hold lock */
+    public static final int SCAN_ONLY_MODE                 = 2;
+    /* SCAN_ONLY_WITH_WIFI_OFF - scan, but don't connect to any APs */
+    public static final int SCAN_ONLY_WITH_WIFI_OFF_MODE   = 3;
+
+    private static final int SUCCESS = 1;
+    private static final int FAILURE = -1;
+
+    /* Tracks if suspend optimizations need to be disabled by DHCP,
+     * screen or due to high perf mode.
+     * When any of them needs to disable it, we keep the suspend optimizations
+     * disabled
+     */
+    private int mSuspendOptNeedsDisabled = 0;
+
+    private static final int SUSPEND_DUE_TO_DHCP       = 1;
+    private static final int SUSPEND_DUE_TO_HIGH_PERF  = 1<<1;
+    private static final int SUSPEND_DUE_TO_SCREEN     = 1<<2;
+
+    /* Tracks if user has enabled suspend optimizations through settings */
+    private AtomicBoolean mUserWantsSuspendOpt = new AtomicBoolean(true);
+
+    /**
+     * Default framework scan interval in milliseconds. This is used in the scenario in which
+     * wifi chipset does not support background scanning to set up a
+     * periodic wake up scan so that the device can connect to a new access
+     * point on the move. {@link Settings.Global#WIFI_FRAMEWORK_SCAN_INTERVAL_MS} can
+     * override this.
+     */
+    private final int mDefaultFrameworkScanIntervalMs;
+
+    private int mDisconnectedScanPeriodMs = 10000;
+
+    /**
+     * Supplicant scan interval in milliseconds.
+     * Comes from {@link Settings.Global#WIFI_SUPPLICANT_SCAN_INTERVAL_MS} or
+     * from the default config if the setting is not set
+     */
+    private long mSupplicantScanIntervalMs;
+
+    /**
+     * timeStamp of last full band scan we perfoemed for autojoin while connected with screen lit
+     */
+    private long lastFullBandConnectedTimeMilli;
+
+    /**
+     * time interval to the next full band scan we will perform for
+     * autojoin while connected with screen lit
+     */
+    private long fullBandConnectedTimeIntervalMilli;
+
+    /**
+     * max time interval to the next full band scan we will perform for
+     * autojoin while connected with screen lit
+     * Max time is 5 minutes
+     */
+    private static final long  maxFullBandConnectedTimeIntervalMilli = 1000 * 60 * 5;
+
+    /**
+     * Minimum time interval between enabling all networks.
+     * A device can end up repeatedly connecting to a bad network on screen on/off toggle
+     * due to enabling every time. We add a threshold to avoid this.
+     */
+    private static final int MIN_INTERVAL_ENABLE_ALL_NETWORKS_MS = 10 * 60 * 1000; /* 10 minutes */
+    private long mLastEnableAllNetworksTime;
+
+    int mRunningBeaconCount = 0;
+
+    /**
+     * Starting and shutting down driver too quick causes problems leading to driver
+     * being in a bad state. Delay driver stop.
+     */
+    private final int mDriverStopDelayMs;
+    private int mDelayedStopCounter;
+    private boolean mInDelayedStop = false;
+
+    // sometimes telephony gives us this data before boot is complete and we can't store it
+    // until after, so the write is deferred
+    private volatile String mPersistedCountryCode;
+
+    // Supplicant doesn't like setting the same country code multiple times (it may drop
+    // currently connected network), so we save the country code here to avoid redundency
+    private String mLastSetCountryCode;
+
+    /* Default parent state */
+    private State mDefaultState = new DefaultState();
+    /* Temporary initial state */
+    private State mInitialState = new InitialState();
+    /* Driver loaded, waiting for supplicant to start */
+    private State mSupplicantStartingState = new SupplicantStartingState();
+    /* Driver loaded and supplicant ready */
+    private State mSupplicantStartedState = new SupplicantStartedState();
+    /* Waiting for supplicant to stop and monitor to exit */
+    private State mSupplicantStoppingState = new SupplicantStoppingState();
+    /* Driver start issued, waiting for completed event */
+    private State mDriverStartingState = new DriverStartingState();
+    /* Driver started */
+    private State mDriverStartedState = new DriverStartedState();
+    /* Wait until p2p is disabled
+     * This is a special state which is entered right after we exit out of DriverStartedState
+     * before transitioning to another state.
+     */
+    private State mWaitForP2pDisableState = new WaitForP2pDisableState();
+    /* Driver stopping */
+    private State mDriverStoppingState = new DriverStoppingState();
+    /* Driver stopped */
+    private State mDriverStoppedState = new DriverStoppedState();
+    /* Scan for networks, no connection will be established */
+    private State mScanModeState = new ScanModeState();
+    /* Connecting to an access point */
+    private State mConnectModeState = new ConnectModeState();
+    /* Connected at 802.11 (L2) level */
+    private State mL2ConnectedState = new L2ConnectedState();
+    /* fetching IP after connection to access point (assoc+auth complete) */
+    private State mObtainingIpState = new ObtainingIpState();
+    /* Waiting for link quality verification to be complete */
+    private State mVerifyingLinkState = new VerifyingLinkState();
+    /* Connected with IP addr */
+    private State mConnectedState = new ConnectedState();
+    /* Roaming */
+    private State mRoamingState = new RoamingState();
+    /* disconnect issued, waiting for network disconnect confirmation */
+    private State mDisconnectingState = new DisconnectingState();
+    /* Network is not connected, supplicant assoc+auth is not complete */
+    private State mDisconnectedState = new DisconnectedState();
+    /* Waiting for WPS to be completed*/
+    private State mWpsRunningState = new WpsRunningState();
+
+    /* Soft ap is starting up */
+    private State mSoftApStartingState = new SoftApStartingState();
+    /* Soft ap is running */
+    private State mSoftApStartedState = new SoftApStartedState();
+    /* Soft ap is running and we are waiting for tether notification */
+    private State mTetheringState = new TetheringState();
+    /* Soft ap is running and we are tethered through connectivity service */
+    private State mTetheredState = new TetheredState();
+    /* Waiting for untether confirmation before stopping soft Ap */
+    private State mUntetheringState = new UntetheringState();
+
+    private class TetherStateChange {
+        ArrayList<String> available;
+        ArrayList<String> active;
+        TetherStateChange(ArrayList<String> av, ArrayList<String> ac) {
+            available = av;
+            active = ac;
+        }
+    }
+
+    public static class SimAuthRequestData {
+        int networkId;
+        int protocol;
+        String ssid;
+        String[] challenges;
+    }
+
+    public static class SimAuthResponseData {
+        int id;
+        String Kc1;
+        String SRES1;
+        String Kc2;
+        String SRES2;
+        String Kc3;
+        String SRES3;
+    }
+
+    /**
+     * One of  {@link WifiManager#WIFI_STATE_DISABLED},
+     *         {@link WifiManager#WIFI_STATE_DISABLING},
+     *         {@link WifiManager#WIFI_STATE_ENABLED},
+     *         {@link WifiManager#WIFI_STATE_ENABLING},
+     *         {@link WifiManager#WIFI_STATE_UNKNOWN}
+     *
+     */
+    private final AtomicInteger mWifiState = new AtomicInteger(WIFI_STATE_DISABLED);
+
+    /**
+     * One of  {@link WifiManager#WIFI_AP_STATE_DISABLED},
+     *         {@link WifiManager#WIFI_AP_STATE_DISABLING},
+     *         {@link WifiManager#WIFI_AP_STATE_ENABLED},
+     *         {@link WifiManager#WIFI_AP_STATE_ENABLING},
+     *         {@link WifiManager#WIFI_AP_STATE_FAILED}
+     *
+     */
+    private final AtomicInteger mWifiApState = new AtomicInteger(WIFI_AP_STATE_DISABLED);
+
+    private static final int SCAN_REQUEST = 0;
+    private static final String ACTION_START_SCAN =
+        "com.android.server.WifiManagerWAP.action.START_SCAN";
+
+    private static final String DELAYED_STOP_COUNTER = "DelayedStopCounter";
+    private static final int DRIVER_STOP_REQUEST = 0;
+    private static final String ACTION_DELAYED_DRIVER_STOP =
+        "com.android.server.WifiManagerWAP.action.DELAYED_DRIVER_STOP";
+
+    private static final String ACTION_REFRESH_BATCHED_SCAN =
+            "com.android.server.WifiManagerWAP.action.REFRESH_BATCHED_SCAN";
+    /**
+     * Keep track of whether WIFI is running.
+     */
+    private boolean mIsRunning = false;
+
+    /**
+     * Keep track of whether we last told the battery stats we had started.
+     */
+    private boolean mReportedRunning = false;
+
+    /**
+     * Most recently set source of starting WIFI.
+     */
+    private final WorkSource mRunningWifiUids = new WorkSource();
+
+    /**
+     * The last reported UIDs that were responsible for starting WIFI.
+     */
+    private final WorkSource mLastRunningWifiUids = new WorkSource();
+
+    private final IBatteryStats mBatteryStats;
+
+    private BatchedScanSettings mBatchedScanSettings = null;
+
+    /**
+     * Track the worksource/cost of the current settings and track what's been noted
+     * to the battery stats, so we can mark the end of the previous when changing.
+     */
+    private WorkSource mBatchedScanWorkSource = null;
+    private int mBatchedScanCsph = 0;
+    private WorkSource mNotedBatchedScanWorkSource = null;
+    private int mNotedBatchedScanCsph = 0;
+
+    private String mTcpBufferSizes = null;
+
+    // Used for debug and stats gathering
+    private static int sScanAlarmIntentCount = 0;
+    private boolean isPropFeatureEnabled = false;
+
+    private static int DEFAULT_SCORE = NetworkAgent.WIFI_BASE_SCORE;
+
+    public WifiStateMachineWAP(Context context, String wlanInterface,
+            WifiTrafficPoller trafficPoller){
+        super("WifiStateMachineWAP");
+        mContext = context;
+        mInterfaceName = wlanInterface;
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mNetworkInfo = new NetworkInfo(ConnectivityManager.TYPE_WIFI_WAP, 0, NETWORKTYPE, "");
+        mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService(
+                BatteryStats.SERVICE_NAME));
+
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNwService = INetworkManagementService.Stub.asInterface(b);
+
+        mP2pSupported = false;//mContext.getPackageManager().hasSystemFeature(
+                //PackageManager.FEATURE_WIFI_DIRECT);
+
+        mWifiNative = new WifiNative(mInterfaceName);
+        mWifiConfigStore = new WifiConfigStore(context, mWifiNative);
+        mWifiAutoJoinController = new WifiAutoJoinControllerWAP(context, this,
+                mWifiConfigStore, mWifiConnectionStatistics, mWifiNative);
+        mWifiMonitor = new WifiMonitor(this, mWifiNative);
+        mWifiInfo = new WifiInfo();
+        mSupplicantStateTracker = new SupplicantStateTrackerWAP(context, this, mWifiConfigStore,
+                getHandler());
+        mLinkProperties = new LinkProperties();
+
+        IBinder s1 = ServiceManager.getService(Context.WIFI_P2P_SERVICE);
+        //mWifiP2pServiceImpl = (WifiP2pServiceImpl)IWifiP2pManager.Stub.asInterface(s1);
+
+        mNetworkInfo.setIsAvailable(false);
+        mLastBssid = null;
+        mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
+        mLastSignalLevel = -1;
+
+        mNetlinkTracker = new NetlinkTracker(mInterfaceName, new NetlinkTracker.Callback() {
+            public void update(LinkProperties lp) {
+                sendMessage(CMD_UPDATE_LINKPROPERTIES, lp);
+            }
+        });
+        try {
+            mNwService.registerObserver(mNetlinkTracker);
+        } catch (RemoteException e) {
+            loge("Couldn't register netlink tracker: " + e.toString());
+        }
+
+        mAlarmManager = (AlarmManager)mContext.getSystemService(Context.ALARM_SERVICE);
+        Intent scanIntent = new Intent(ACTION_START_SCAN, null);
+        mScanIntent = PendingIntent.getBroadcast(mContext, SCAN_REQUEST, scanIntent, 0);
+
+        Intent batchedIntent = new Intent(ACTION_REFRESH_BATCHED_SCAN, null);
+        mBatchedScanIntervalIntent = PendingIntent.getBroadcast(mContext, 0, batchedIntent, 0);
+
+        mDefaultFrameworkScanIntervalMs = mContext.getResources().getInteger(
+                R.integer.config_wifi_framework_scan_interval);
+
+        mDriverStopDelayMs = mContext.getResources().getInteger(
+                R.integer.config_wifi_driver_stop_delay);
+
+        mBackgroundScanSupported = mContext.getResources().getBoolean(
+                R.bool.config_wifi_background_scan_support);
+
+        mPrimaryDeviceType = mContext.getResources().getString(
+                R.string.config_wifi_p2p_device_type);
+
+        mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
+
+        mNetworkCapabilitiesFilter.addTransportType(NetworkCapabilities.TRANSPORT_WIFI);
+        mNetworkCapabilitiesFilter.addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET);
+        mNetworkCapabilitiesFilter.addCapability(NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED);
+        mNetworkCapabilitiesFilter.setLinkUpstreamBandwidthKbps(1024 * 1024);
+        mNetworkCapabilitiesFilter.setLinkDownstreamBandwidthKbps(1024 * 1024);
+        // TODO - needs to be a bit more dynamic
+        mNetworkCapabilities = new NetworkCapabilities(mNetworkCapabilitiesFilter);
+
+        mContext.registerReceiver(
+            new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    ArrayList<String> available = intent.getStringArrayListExtra(
+                            ConnectivityManager.EXTRA_AVAILABLE_TETHER);
+                    ArrayList<String> active = intent.getStringArrayListExtra(
+                            ConnectivityManager.EXTRA_ACTIVE_TETHER);
+                    sendMessage(CMD_TETHER_STATE_CHANGE, new TetherStateChange(available, active));
+                }
+            },new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        sScanAlarmIntentCount++;
+                        startScan(SCAN_ALARM_SOURCE, -2, null, null);
+                        if (VDBG)
+                            loge("WiFiStateMachine SCAN ALARM");
+                    }
+                },
+                new IntentFilter(ACTION_START_SCAN));
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(ACTION_REFRESH_BATCHED_SCAN);
+        int val = SystemProperties.getInt("persist.cne.feature", 0);
+        boolean isPropFeatureAvail = (val == 3) ? true : false;
+        if (isPropFeatureAvail) {
+            DEFAULT_SCORE = 1;
+            filter.addAction("com.quicinc.cne.CNE_PREFERENCE_CHANGED");
+            filter.addAction("prop_state_change");
+            filter.addAction("blacklist_bad_bssid");
+        }
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        String action = intent.getAction();
+
+                        if (action.equals(Intent.ACTION_SCREEN_ON)) {
+                            sendMessage(CMD_SCREEN_STATE_CHANGED, 1);
+                        } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
+                            sendMessage(CMD_SCREEN_STATE_CHANGED, 0);
+                        } else if (action.equals(ACTION_REFRESH_BATCHED_SCAN)) {
+                            startNextBatchedScanAsync();
+                        } else if (action.equals("com.quicinc.cne.CNE_PREFERENCE_CHANGED")) {
+                            int featureId = intent.getIntExtra(EXTRA_FEATURE_ID, -1);
+                            int featureParam = intent.getIntExtra(EXTRA_FEATURE_PARAMETER, -1);
+                            int featureVal = intent.getIntExtra(EXTRA_PARAMETER_VALUE, -1);
+                            handlePrefChange(featureId, featureParam, featureVal);
+                        } else if (action.equals("prop_state_change")) {
+                            int state = intent.getIntExtra("state", 0);
+                            handleStateChange(state);
+                        } else if (action.equals("blacklist_bad_bssid") ) {
+                            // 1 = blacklist, 0 = unblacklist
+                            int blacklist = intent.getIntExtra("blacklistBSSID", -1);
+                            String bssid  =  intent.getStringExtra("BSSIDToBlacklist");
+                            int reason = intent.getIntExtra("blacklistReason", -1 );
+                            handleBSSIDBlacklist( ( blacklist == 0) ? true : false, bssid, reason );
+                        }
+                    }
+                }, filter);
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                       int counter = intent.getIntExtra(DELAYED_STOP_COUNTER, 0);
+                       sendMessage(CMD_DELAYED_STOP_DRIVER, counter, 0);
+                    }
+                },
+                new IntentFilter(ACTION_DELAYED_DRIVER_STOP));
+
+        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(
+                Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED), false,
+                new ContentObserver(getHandler()) {
+                    @Override
+                    public void onChange(boolean selfChange) {
+                        mUserWantsSuspendOpt.set(Settings.Global.getInt(mContext.getContentResolver(),
+                                Settings.Global.WIFI_SUSPEND_OPTIMIZATIONS_ENABLED, 1) == 1);
+                    }
+                });
+
+        mContext.registerReceiver(
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        sendMessage(CMD_BOOT_COMPLETED);
+                    }
+                },
+                new IntentFilter(Intent.ACTION_BOOT_COMPLETED));
+
+        mScanResultCache = new LruCache<String, ScanResult>(SCAN_RESULT_CACHE_SIZE);
+
+        PowerManager powerManager = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getName());
+
+        mSuspendWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "WifiSuspend");
+        mSuspendWakeLock.setReferenceCounted(false);
+
+        mTcpBufferSizes = mContext.getResources().getString(
+                com.android.internal.R.string.config_wifi_tcp_buffers);
+
+        addState(mDefaultState);
+            addState(mInitialState, mDefaultState);
+            addState(mSupplicantStartingState, mDefaultState);
+            addState(mSupplicantStartedState, mDefaultState);
+                addState(mDriverStartingState, mSupplicantStartedState);
+                addState(mDriverStartedState, mSupplicantStartedState);
+                    addState(mScanModeState, mDriverStartedState);
+                    addState(mConnectModeState, mDriverStartedState);
+                        addState(mL2ConnectedState, mConnectModeState);
+                            addState(mObtainingIpState, mL2ConnectedState);
+                            addState(mVerifyingLinkState, mL2ConnectedState);
+                            addState(mConnectedState, mL2ConnectedState);
+                            addState(mRoamingState, mL2ConnectedState);
+                        addState(mDisconnectingState, mConnectModeState);
+                        addState(mDisconnectedState, mConnectModeState);
+                        addState(mWpsRunningState, mConnectModeState);
+                addState(mWaitForP2pDisableState, mSupplicantStartedState);
+                addState(mDriverStoppingState, mSupplicantStartedState);
+                addState(mDriverStoppedState, mSupplicantStartedState);
+            addState(mSupplicantStoppingState, mDefaultState);
+            addState(mSoftApStartingState, mDefaultState);
+            addState(mSoftApStartedState, mDefaultState);
+                addState(mTetheringState, mSoftApStartedState);
+                addState(mTetheredState, mSoftApStartedState);
+                addState(mUntetheringState, mSoftApStartedState);
+
+        setInitialState(mInitialState);
+
+        setLogRecSize(3000);
+        setLogOnlyTransitions(false);
+        if (VDBG) setDbg(true);
+
+        //start the state machine
+        start();
+
+        final Intent intent = new Intent(WifiManagerWAP.WIFI_SCAN_AVAILABLE);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private int mVerboseLoggingLevel = 0;
+
+    int getVerboseLoggingLevel() {
+        return mVerboseLoggingLevel;
+    }
+
+    void enableVerboseLogging(int verbose) {
+        mVerboseLoggingLevel = verbose;
+        if (verbose > 0) {
+            DBG = true;
+            VDBG = true;
+            PDBG = true;
+            mLogMessages = true;
+            mWifiNative.setSupplicantLogLevel("DEBUG");
+        } else {
+            DBG = false;
+            VDBG = false;
+            PDBG = false;
+            mLogMessages = false;
+            mWifiNative.setSupplicantLogLevel("INFO");
+        }
+        //mWifiP2pServiceImpl.enableVerboseLogging(verbose);
+        mWifiAutoJoinController.enableVerboseLogging(verbose);
+        mWifiMonitor.enableVerboseLogging(verbose);
+        mWifiNative.enableVerboseLogging(verbose);
+        mWifiConfigStore.enableVerboseLogging(verbose);
+        mSupplicantStateTracker.enableVerboseLogging(verbose);
+    }
+
+    private int mAggressiveHandover = 0;
+
+    int getAggressiveHandover() {
+        return mAggressiveHandover;
+    }
+
+    void enableAggressiveHandover(int enabled) {
+        mAggressiveHandover = enabled;
+    }
+
+    public void setAllowScansWithTraffic(int enabled) {
+        mWifiConfigStore.alwaysEnableScansWhileAssociated = enabled;
+    }
+
+    public int getAllowScansWithTraffic() {
+        return mWifiConfigStore.alwaysEnableScansWhileAssociated;
+    }
+
+    /*
+     *
+     * Framework scan control
+     */
+
+    private boolean mAlarmEnabled = false;
+    /* This is set from the overlay config file or from a secure setting.
+     * A value of 0 disables scanning in the framework.
+     */
+    private long mFrameworkScanIntervalMs = 10000;
+
+    private long mCurrentScanAlarmMs = 10000;
+    private void setScanAlarm(boolean enabled, int delayMilli) {
+        if (PDBG) {
+            loge("setScanAlarm " + enabled
+                    + " period " + mCurrentScanAlarmMs
+                    + " initial delay " + delayMilli);
+        }
+        if (mCurrentScanAlarmMs <= 0) enabled = false;
+        if (enabled == mAlarmEnabled) return;
+        if (enabled) {
+            long initialDelayMilli;
+            if (delayMilli <= 0) {
+                // scan now
+                startScan(SCAN_ALARM_SOURCE, 0, null, null);
+                initialDelayMilli = mCurrentScanAlarmMs;
+            } else {
+                initialDelayMilli = delayMilli;
+            }
+
+            int type = AlarmManager.RTC;
+
+            /* Set RTC_WAKEUP alarms if PNO is not supported - because no one is */
+            /* going to wake up the host processor to look for access points */
+            if (mBackgroundScanSupported == false)
+                type = AlarmManager.RTC_WAKEUP;
+
+            mAlarmManager.setRepeating(type,
+                    System.currentTimeMillis() + initialDelayMilli,
+                    mCurrentScanAlarmMs,
+                    mScanIntent);
+            mAlarmEnabled = true;
+        } else {
+            mAlarmManager.cancel(mScanIntent);
+            mAlarmEnabled = false;
+        }
+    }
+
+    private boolean setRandomMacOui() {
+        String oui = mContext.getResources().getString(
+                R.string.config_wifi_random_mac_oui, GOOGLE_OUI);
+        String[] ouiParts = oui.split("-");
+        byte[] ouiBytes = new byte[3];
+        ouiBytes[0] = (byte) (Integer.parseInt(ouiParts[0], 16) & 0xFF);
+        ouiBytes[1] = (byte) (Integer.parseInt(ouiParts[1], 16) & 0xFF);
+        ouiBytes[2] = (byte) (Integer.parseInt(ouiParts[2], 16) & 0xFF);
+
+        logd("Setting OUI to " + oui);
+        return mWifiNative.setScanningMacOui(ouiBytes);
+    }
+
+    /*********************************************************
+     * Methods exposed for public use
+     ********************************************************/
+
+    public Messenger getMessenger() {
+        return new Messenger(getHandler());
+    }
+
+    public WifiMonitor getWifiMonitor() {
+        return mWifiMonitor;
+    }
+
+    /**
+     * TODO: doc
+     */
+    public boolean syncPingSupplicant(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_PING_SUPPLICANT);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    public List<WifiChannel> syncGetChannelList(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_CAPABILITY_FREQ);
+        List<WifiChannel> list = null;
+        if (resultMsg.obj != null) {
+            list = new ArrayList<WifiChannel>();
+            String freqs = (String) resultMsg.obj;
+            String[] lines = freqs.split("\n");
+            for (String line : lines)
+                if (line.contains("MHz")) {
+                    // line format: " 52 = 5260 MHz (NO_IBSS) (DFS)"
+                    WifiChannel c = new WifiChannel();
+                    String[] prop = line.split(" ");
+                    if (prop.length < 5) continue;
+                    try {
+                        c.channelNum = Integer.parseInt(prop[1]);
+                        c.freqMHz = Integer.parseInt(prop[3]);
+                    } catch (NumberFormatException e) { }
+                    c.isDFS = line.contains("(DFS)");
+                    list.add(c);
+                } else if (line.contains("Mode[B] Channels:")) {
+                    // B channels are the same as G channels, skipped
+                    break;
+                }
+        }
+        resultMsg.recycle();
+        return (list != null && list.size() > 0) ? list : null;
+    }
+
+
+    /**
+     * Initiate a wifi scan. If workSource is not null, blame is given to it, otherwise blame is
+     * given to callingUid.
+     *
+     * @param callingUid The uid initiating the wifi scan. Blame will be given here unless
+     *                   workSource is specified.
+     * @param workSource If not null, blame is given to workSource.
+     * @param settings Scan settings, see {@link ScanSettings}.
+     */
+    public void startScan(int callingUid, int scanCounter,
+                          ScanSettings settings, WorkSource workSource) {
+        Bundle bundle = new Bundle();
+        bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, settings);
+        bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
+        bundle.putLong(SCAN_REQUEST_TIME, System.currentTimeMillis());
+        sendMessage(CMD_START_SCAN, callingUid, scanCounter, bundle);
+    }
+
+    /**
+     * start or stop batched scanning using the given settings
+     */
+    public void setBatchedScanSettings(BatchedScanSettings settings, int callingUid, int csph,
+            WorkSource workSource) {
+        Bundle bundle = new Bundle();
+        bundle.putParcelable(BATCHED_SETTING, settings);
+        bundle.putParcelable(BATCHED_WORKSOURCE, workSource);
+        sendMessage(CMD_SET_BATCHED_SCAN, callingUid, csph, bundle);
+    }
+
+    public List<BatchedScanResult> syncGetBatchedScanResultsList() {
+        synchronized (mBatchedScanResults) {
+            List<BatchedScanResult> batchedScanList =
+                    new ArrayList<BatchedScanResult>(mBatchedScanResults.size());
+            for(BatchedScanResult result: mBatchedScanResults) {
+                batchedScanList.add(new BatchedScanResult(result));
+            }
+            return batchedScanList;
+        }
+    }
+
+    public void requestBatchedScanPoll() {
+        sendMessage(CMD_POLL_BATCHED_SCAN);
+    }
+
+    private void startBatchedScan() {
+        if (mBatchedScanSettings == null) return;
+
+        if (mDhcpActive) {
+            if (DBG) log("not starting Batched Scans due to DHCP");
+            return;
+        }
+
+        // first grab any existing data
+        retrieveBatchedScanData();
+
+        if (PDBG) loge("try  starting Batched Scans due to DHCP");
+
+
+        mAlarmManager.cancel(mBatchedScanIntervalIntent);
+
+        String scansExpected = mWifiNative.setBatchedScanSettings(mBatchedScanSettings);
+        try {
+            mExpectedBatchedScans = Integer.parseInt(scansExpected);
+            setNextBatchedAlarm(mExpectedBatchedScans);
+            if (mExpectedBatchedScans > 0) noteBatchedScanStart();
+        } catch (NumberFormatException e) {
+            stopBatchedScan();
+            loge("Exception parsing WifiNative.setBatchedScanSettings response " + e);
+        }
+    }
+
+    // called from BroadcastListener
+    private void startNextBatchedScanAsync() {
+        sendMessage(CMD_START_NEXT_BATCHED_SCAN);
+    }
+
+    private void startNextBatchedScan() {
+        // first grab any existing data
+        retrieveBatchedScanData();
+
+        setNextBatchedAlarm(mExpectedBatchedScans);
+    }
+
+    private void handleBatchedScanPollRequest() {
+        if (DBG) {
+            log("handleBatchedScanPoll Request - mBatchedScanMinPollTime=" +
+                    mBatchedScanMinPollTime + " , mBatchedScanSettings=" +
+                    mBatchedScanSettings);
+        }
+        // if there is no appropriate PollTime that's because we either aren't
+        // batching or we've already set a time for a poll request
+        if (mBatchedScanMinPollTime == 0) return;
+        if (mBatchedScanSettings == null) return;
+
+        long now = System.currentTimeMillis();
+
+        if (now > mBatchedScanMinPollTime) {
+            // do the poll and reset our timers
+            startNextBatchedScan();
+        } else {
+            mAlarmManager.setExact(AlarmManager.RTC_WAKEUP, mBatchedScanMinPollTime,
+                    mBatchedScanIntervalIntent);
+            mBatchedScanMinPollTime = 0;
+        }
+    }
+
+    // return true if new/different
+    private boolean recordBatchedScanSettings(int responsibleUid, int csph, Bundle bundle) {
+        BatchedScanSettings settings = bundle.getParcelable(BATCHED_SETTING);
+        WorkSource responsibleWorkSource = bundle.getParcelable(BATCHED_WORKSOURCE);
+
+        if (DBG) {
+            log("set batched scan to " + settings + " for uid=" + responsibleUid +
+                    ", worksource=" + responsibleWorkSource);
+        }
+        if (settings != null) {
+            if (settings.equals(mBatchedScanSettings)) return false;
+        } else {
+            if (mBatchedScanSettings == null) return false;
+        }
+        mBatchedScanSettings = settings;
+        if (responsibleWorkSource == null) responsibleWorkSource = new WorkSource(responsibleUid);
+        mBatchedScanWorkSource = responsibleWorkSource;
+        mBatchedScanCsph = csph;
+        return true;
+    }
+
+    private void stopBatchedScan() {
+        mAlarmManager.cancel(mBatchedScanIntervalIntent);
+        retrieveBatchedScanData();
+        mWifiNative.setBatchedScanSettings(null);
+        noteBatchedScanStop();
+    }
+
+    private void setNextBatchedAlarm(int scansExpected) {
+
+        if (mBatchedScanSettings == null || scansExpected < 1) return;
+
+        mBatchedScanMinPollTime = System.currentTimeMillis() +
+                mBatchedScanSettings.scanIntervalSec * 1000;
+
+        if (mBatchedScanSettings.maxScansPerBatch < scansExpected) {
+            scansExpected = mBatchedScanSettings.maxScansPerBatch;
+        }
+
+        int secToFull = mBatchedScanSettings.scanIntervalSec;
+        secToFull *= scansExpected;
+
+        int debugPeriod = SystemProperties.getInt("wifi.batchedScan.pollPeriod", 0);
+        if (debugPeriod > 0) secToFull = debugPeriod;
+
+        // set the alarm to do the next poll.  We set it a little short as we'd rather
+        // wake up wearly than miss a scan due to buffer overflow
+        mAlarmManager.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis()
+                + ((secToFull - (mBatchedScanSettings.scanIntervalSec / 2)) * 1000),
+                mBatchedScanIntervalIntent);
+    }
+
+    /**
+     * Start reading new scan data
+     * Data comes in as:
+     * "scancount=5\n"
+     * "nextcount=5\n"
+     *   "apcount=3\n"
+     *   "trunc\n" (optional)
+     *     "bssid=...\n"
+     *     "ssid=...\n"
+     *     "freq=...\n" (in Mhz)
+     *     "level=...\n"
+     *     "dist=...\n" (in cm)
+     *     "distsd=...\n" (standard deviation, in cm)
+     *     "===="
+     *     "bssid=...\n"
+     *     etc
+     *     "===="
+     *     "bssid=...\n"
+     *     etc
+     *     "%%%%"
+     *   "apcount=2\n"
+     *     "bssid=...\n"
+     *     etc
+     *     "%%%%
+     *   etc
+     *   "----"
+     */
+    private final static boolean DEBUG_PARSE = false;
+    private void retrieveBatchedScanData() {
+        String rawData = mWifiNative.getBatchedScanResults();
+        if (DEBUG_PARSE) log("rawData = " + rawData);
+        mBatchedScanMinPollTime = 0;
+        if (rawData == null || rawData.equalsIgnoreCase("OK")) {
+            loge("Unexpected BatchedScanResults :" + rawData);
+            return;
+        }
+
+        int scanCount = 0;
+        final String END_OF_BATCHES = "----";
+        final String SCANCOUNT = "scancount=";
+        final String TRUNCATED = "trunc";
+        final String AGE = "age=";
+        final String DIST = "dist=";
+        final String DISTSD = "distSd=";
+
+        String splitData[] = rawData.split("\n");
+        int n = 0;
+        if (splitData[n].startsWith(SCANCOUNT)) {
+            try {
+                scanCount = Integer.parseInt(splitData[n++].substring(SCANCOUNT.length()));
+            } catch (NumberFormatException e) {
+                loge("scancount parseInt Exception from " + splitData[n]);
+            }
+        } else log("scancount not found");
+        if (scanCount == 0) {
+            loge("scanCount==0 - aborting");
+            return;
+        }
+
+        final Intent intent = new Intent(WifiManagerWAP.BATCHED_SCAN_RESULTS_AVAILABLE_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+
+        synchronized (mBatchedScanResults) {
+            mBatchedScanResults.clear();
+            BatchedScanResult batchedScanResult = new BatchedScanResult();
+
+            String bssid = null;
+            WifiSsid wifiSsid = null;
+            int level = 0;
+            int freq = 0;
+            int dist, distSd;
+            long tsf = 0;
+            dist = distSd = ScanResult.UNSPECIFIED;
+            final long now = SystemClock.elapsedRealtime();
+            final int bssidStrLen = BSSID_STR.length();
+
+            while (true) {
+                while (n < splitData.length) {
+                    if (DEBUG_PARSE) logd("parsing " + splitData[n]);
+                    if (splitData[n].equals(END_OF_BATCHES)) {
+                        if (n+1 != splitData.length) {
+                            loge("didn't consume " + (splitData.length-n));
+                        }
+                        if (mBatchedScanResults.size() > 0) {
+                            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+                        }
+                        logd("retrieveBatchedScanResults X");
+                        return;
+                    }
+                    if ((splitData[n].equals(END_STR)) || splitData[n].equals(DELIMITER_STR)) {
+                        if (bssid != null) {
+                            batchedScanResult.scanResults.add(new ScanResult(
+                                    wifiSsid, bssid, "", level, freq, tsf, dist, distSd));
+                            wifiSsid = null;
+                            bssid = null;
+                            level = 0;
+                            freq = 0;
+                            tsf = 0;
+                            dist = distSd = ScanResult.UNSPECIFIED;
+                        }
+                        if (splitData[n].equals(END_STR)) {
+                            if (batchedScanResult.scanResults.size() != 0) {
+                                mBatchedScanResults.add(batchedScanResult);
+                                batchedScanResult = new BatchedScanResult();
+                            } else {
+                                logd("Found empty batch");
+                            }
+                        }
+                    } else if (splitData[n].equals(TRUNCATED)) {
+                        batchedScanResult.truncated = true;
+                    } else if (splitData[n].startsWith(BSSID_STR)) {
+                        bssid = new String(splitData[n].getBytes(), bssidStrLen,
+                                splitData[n].length() - bssidStrLen);
+                    } else if (splitData[n].startsWith(FREQ_STR)) {
+                        try {
+                            freq = Integer.parseInt(splitData[n].substring(FREQ_STR.length()));
+                        } catch (NumberFormatException e) {
+                            loge("Invalid freqency: " + splitData[n]);
+                            freq = 0;
+                        }
+                    } else if (splitData[n].startsWith(AGE)) {
+                        try {
+                            tsf = now - Long.parseLong(splitData[n].substring(AGE.length()));
+                            tsf *= 1000; // convert mS -> uS
+                        } catch (NumberFormatException e) {
+                            loge("Invalid timestamp: " + splitData[n]);
+                            tsf = 0;
+                        }
+                    } else if (splitData[n].startsWith(SSID_STR)) {
+                        wifiSsid = WifiSsid.createFromAsciiEncoded(
+                                splitData[n].substring(SSID_STR.length()));
+                    } else if (splitData[n].startsWith(LEVEL_STR)) {
+                        try {
+                            level = Integer.parseInt(splitData[n].substring(LEVEL_STR.length()));
+                            if (level > 0) level -= 256;
+                        } catch (NumberFormatException e) {
+                            loge("Invalid level: " + splitData[n]);
+                            level = 0;
+                        }
+                    } else if (splitData[n].startsWith(DIST)) {
+                        try {
+                            dist = Integer.parseInt(splitData[n].substring(DIST.length()));
+                        } catch (NumberFormatException e) {
+                            loge("Invalid distance: " + splitData[n]);
+                            dist = ScanResult.UNSPECIFIED;
+                        }
+                    } else if (splitData[n].startsWith(DISTSD)) {
+                        try {
+                            distSd = Integer.parseInt(splitData[n].substring(DISTSD.length()));
+                        } catch (NumberFormatException e) {
+                            loge("Invalid distanceSd: " + splitData[n]);
+                            distSd = ScanResult.UNSPECIFIED;
+                        }
+                    } else {
+                        loge("Unable to parse batched scan result line: " + splitData[n]);
+                    }
+                    n++;
+                }
+                rawData = mWifiNative.getBatchedScanResults();
+                if (DEBUG_PARSE) log("reading more data:\n" + rawData);
+                if (rawData == null) {
+                    loge("Unexpected null BatchedScanResults");
+                    return;
+                }
+                splitData = rawData.split("\n");
+                if (splitData.length == 0 || splitData[0].equals("ok")) {
+                    loge("batch scan results just ended!");
+                    if (mBatchedScanResults.size() > 0) {
+                        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+                    }
+                    return;
+                }
+                n = 0;
+            }
+        }
+    }
+
+    private long mDisconnectedTimeStamp = 0;
+
+    public long getDisconnectedTimeMilli() {
+        if (getCurrentState() == mDisconnectedState
+                && mDisconnectedTimeStamp != 0) {
+            long now_ms = System.currentTimeMillis();
+            return now_ms - mDisconnectedTimeStamp;
+        }
+        return 0;
+    }
+
+    // Keeping track of scan requests
+    private long lastStartScanTimeStamp = 0;
+    private long lastScanDuration = 0;
+    // Last connect attempt is used to prevent scan requests:
+    //  - for a period of 10 seconds after attempting to connect
+    private long lastConnectAttempt = 0;
+    private String lastScanFreqs = null;
+
+    // For debugging, keep track of last message status handling
+    // TODO, find an equivalent mechanism as part of parent class
+    private static int MESSAGE_HANDLING_STATUS_PROCESSED = 2;
+    private static int MESSAGE_HANDLING_STATUS_OK = 1;
+    private static int MESSAGE_HANDLING_STATUS_UNKNOWN = 0;
+    private static int MESSAGE_HANDLING_STATUS_REFUSED = -1;
+    private static int MESSAGE_HANDLING_STATUS_FAIL = -2;
+    private static int MESSAGE_HANDLING_STATUS_BUFFERED = -3;
+    private static int MESSAGE_HANDLING_STATUS_DEFERRED = -4;
+    private static int MESSAGE_HANDLING_STATUS_DISCARD = -5;
+    private static int MESSAGE_HANDLING_STATUS_LOOPED = -6;
+    private static int MESSAGE_HANDLING_STATUS_HANDLING_ERROR = -7;
+
+    private int messageHandlingStatus = 0;
+    private static long lastScanDuringP2p = 0;
+
+    //TODO: this is used only to track connection attempts, however the link state and packet per
+    //TODO: second logic should be folded into that
+    private boolean isScanAllowed(int scanSource) {
+        long now = System.currentTimeMillis();
+        if (lastConnectAttempt != 0 && (now - lastConnectAttempt) < 10000) {
+            return false;
+        }
+        if (mP2pConnected.get()) {
+            if (scanSource == SCAN_ALARM_SOURCE) {
+                if (VDBG) {
+                    logd("P2P connected: lastScanDuringP2p=" +
+                         lastScanDuringP2p +
+                         " CurrentTime=" + now +
+                         " autoJoinScanIntervalWhenP2pConnected=" +
+                         mWifiConfigStore.autoJoinScanIntervalWhenP2pConnected);
+                }
+
+                if (lastScanDuringP2p == 0 || (now - lastScanDuringP2p)
+                    < mWifiConfigStore.autoJoinScanIntervalWhenP2pConnected) {
+                    if (lastScanDuringP2p == 0) lastScanDuringP2p = now;
+                    if (VDBG) {
+                        logd("P2P connected, discard scan within " +
+                             mWifiConfigStore.autoJoinScanIntervalWhenP2pConnected
+                             + " milliseconds");
+                    }
+                    return false;
+                }
+                lastScanDuringP2p = now;
+            }
+        } else {
+            lastScanDuringP2p = 0;
+        }
+        return true;
+    }
+
+    private int mOnTime = 0;
+    private int mTxTime = 0;
+    private int mRxTime = 0;
+    private int mOnTimeStartScan = 0;
+    private int mTxTimeStartScan = 0;
+    private int mRxTimeStartScan = 0;
+    private int mOnTimeScan = 0;
+    private int mTxTimeScan = 0;
+    private int mRxTimeScan = 0;
+    private int mOnTimeThisScan = 0;
+    private int mTxTimeThisScan = 0;
+    private int mRxTimeThisScan = 0;
+
+    private int mOnTimeScreenStateChange = 0;
+    private int mOnTimeAtLastReport = 0;
+    private long lastOntimeReportTimeStamp = 0;
+    private long lastScreenStateChangeTimeStamp = 0;
+    private int mOnTimeLastReport = 0;
+    private int mTxTimeLastReport = 0;
+    private int mRxTimeLastReport = 0;
+
+    private long lastLinkLayerStatsUpdate = 0;
+
+    String reportOnTime() {
+        long now = System.currentTimeMillis();
+        StringBuilder sb = new StringBuilder();
+        // Report stats since last report
+        int on = mOnTime - mOnTimeLastReport;
+        mOnTimeLastReport = mOnTime;
+        int tx = mTxTime - mTxTimeLastReport;
+        mTxTimeLastReport = mTxTime;
+        int rx = mRxTime - mRxTimeLastReport;
+        mRxTimeLastReport = mRxTime;
+        int period = (int)(now - lastOntimeReportTimeStamp);
+        lastOntimeReportTimeStamp = now;
+        sb.append(String.format("[on:%d tx:%d rx:%d period:%d]", on, tx, rx, period));
+        // Report stats since Screen State Changed
+        on = mOnTime - mOnTimeScreenStateChange;
+        period = (int)(now - lastScreenStateChangeTimeStamp);
+        sb.append(String.format(" from screen [on:%d period:%d]", on, period));
+        return sb.toString();
+    }
+
+    WifiLinkLayerStats getWifiLinkLayerStats(boolean dbg) {
+        WifiLinkLayerStats stats = null;
+        if (mWifiLinkLayerStatsSupported > 0) {
+            String name = "wlan0";
+            stats = mWifiNative.getWifiLinkLayerStats(name);
+            if (name != null && stats == null && mWifiLinkLayerStatsSupported > 0) {
+                mWifiLinkLayerStatsSupported -= 1;
+            } else if (stats != null) {
+                lastLinkLayerStatsUpdate = System.currentTimeMillis();
+                mOnTime = stats.on_time;
+                mTxTime = stats.tx_time;
+                mRxTime = stats.rx_time;
+                mRunningBeaconCount = stats.beacon_rx;
+                if (dbg) {
+                    loge("WifiLinkLayerStats:");
+                    loge(stats.toString());
+                }
+            }
+        }
+        return stats;
+    }
+
+    void startRadioScanStats() {
+        WifiLinkLayerStats stats = getWifiLinkLayerStats(false);
+        if (stats != null) {
+            mOnTimeStartScan = stats.on_time;
+            mTxTimeStartScan = stats.tx_time;
+            mRxTimeStartScan = stats.rx_time;
+            mOnTime = stats.on_time;
+            mTxTime = stats.tx_time;
+            mRxTime = stats.rx_time;
+        }
+    }
+
+    void closeRadioScanStats() {
+        WifiLinkLayerStats stats = getWifiLinkLayerStats(false);
+        if (stats != null) {
+            mOnTimeThisScan = stats.on_time - mOnTimeStartScan;
+            mTxTimeThisScan = stats.tx_time - mTxTimeStartScan;
+            mRxTimeThisScan = stats.rx_time - mRxTimeStartScan;
+            mOnTimeScan += mOnTimeThisScan;
+            mTxTimeScan += mTxTimeThisScan;
+            mRxTimeScan += mRxTimeThisScan;
+        }
+    }
+
+    // If workSource is not null, blame is given to it, otherwise blame is given to callingUid.
+    private void noteScanStart(int callingUid, WorkSource workSource) {
+        long now = System.currentTimeMillis();
+        lastStartScanTimeStamp = now;
+        lastScanDuration = 0;
+        if (DBG) {
+            String ts = String.format("[%,d ms]", now);
+            if (workSource != null) {
+                loge(ts + " noteScanStart" + workSource.toString()
+                        + " uid " + Integer.toString(callingUid));
+            } else {
+                loge(ts + " noteScanstart no scan source");
+            }
+        }
+        startRadioScanStats();
+        if (mScanWorkSource == null && ((callingUid != UNKNOWN_SCAN_SOURCE
+                && callingUid != SCAN_ALARM_SOURCE)
+                || workSource != null)) {
+            mScanWorkSource = workSource != null ? workSource : new WorkSource(callingUid);
+            try {
+                mBatteryStats.noteWifiScanStartedFromSource(mScanWorkSource);
+            } catch (RemoteException e) {
+                log(e.toString());
+            }
+        }
+    }
+
+    private void noteScanEnd() {
+        long now = System.currentTimeMillis();
+        if (lastStartScanTimeStamp != 0) {
+            lastScanDuration = now - lastStartScanTimeStamp;
+        }
+        lastStartScanTimeStamp = 0;
+        if (DBG) {
+            String ts = String.format("[%,d ms]", now);
+            if (mScanWorkSource != null)
+                loge(ts + " noteScanEnd " + mScanWorkSource.toString());
+            else
+                loge(ts + " noteScanEnd no scan source");
+        }
+        if (mScanWorkSource != null) {
+            try {
+                mBatteryStats.noteWifiScanStoppedFromSource(mScanWorkSource);
+            } catch (RemoteException e) {
+                log(e.toString());
+            } finally {
+                mScanWorkSource = null;
+            }
+        }
+    }
+
+    private void noteBatchedScanStart() {
+        if (PDBG) loge("noteBatchedScanstart()");
+        // note the end of a previous scan set
+        if (mNotedBatchedScanWorkSource != null &&
+                (mNotedBatchedScanWorkSource.equals(mBatchedScanWorkSource) == false ||
+                 mNotedBatchedScanCsph != mBatchedScanCsph)) {
+            try {
+                mBatteryStats.noteWifiBatchedScanStoppedFromSource(mNotedBatchedScanWorkSource);
+            } catch (RemoteException e) {
+                log(e.toString());
+            } finally {
+                mNotedBatchedScanWorkSource = null;
+                mNotedBatchedScanCsph = 0;
+            }
+        }
+        // note the start of the new
+        try {
+            mBatteryStats.noteWifiBatchedScanStartedFromSource(mBatchedScanWorkSource,
+                    mBatchedScanCsph);
+            mNotedBatchedScanWorkSource = mBatchedScanWorkSource;
+            mNotedBatchedScanCsph = mBatchedScanCsph;
+        } catch (RemoteException e) {
+            log(e.toString());
+        }
+    }
+
+    private void noteBatchedScanStop() {
+        if (PDBG) loge("noteBatchedScanstop()");
+
+        if (mNotedBatchedScanWorkSource != null) {
+            try {
+                mBatteryStats.noteWifiBatchedScanStoppedFromSource(mNotedBatchedScanWorkSource);
+            } catch (RemoteException e) {
+                log(e.toString());
+            } finally {
+                mNotedBatchedScanWorkSource = null;
+                mNotedBatchedScanCsph = 0;
+            }
+        }
+    }
+
+    private void handleScanRequest(int type, Message message) {
+        // unbundle parameters
+        Bundle bundle = (Bundle) message.obj;
+        ScanSettings settings = bundle.getParcelable(CUSTOMIZED_SCAN_SETTING);
+        WorkSource workSource = bundle.getParcelable(CUSTOMIZED_SCAN_WORKSOURCE);
+
+        // parse scan settings
+        String freqs = null;
+        if (settings != null && settings.channelSet != null) {
+            StringBuilder sb = new StringBuilder();
+            boolean first = true;
+            for (WifiChannel channel : settings.channelSet) {
+                if (!first) sb.append(','); else first = false;
+                sb.append(channel.freqMHz);
+            }
+            freqs = sb.toString();
+        }
+
+        // call wifi native to start the scan
+        if (startScanNative(type, freqs)) {
+            // only count battery consumption if scan request is accepted
+            noteScanStart(message.arg1, workSource);
+            // a full scan covers everything, clearing scan request buffer
+            if (freqs == null)
+                mBufferedScanMsg.clear();
+            messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
+            return;
+        }
+
+        // if reach here, scan request is rejected
+
+        if (!mIsScanOngoing) {
+            // if rejection is NOT due to ongoing scan (e.g. bad scan parameters),
+
+            // discard this request and pop up the next one
+            if (mBufferedScanMsg.size() > 0) {
+                sendMessage(mBufferedScanMsg.remove());
+            }
+            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+        } else if (!mIsFullScanOngoing) {
+            // if rejection is due to an ongoing scan, and the ongoing one is NOT a full scan,
+            // buffer the scan request to make sure specified channels will be scanned eventually
+            if (freqs == null)
+                mBufferedScanMsg.clear();
+            if (mBufferedScanMsg.size() < SCAN_REQUEST_BUFFER_MAX_SIZE) {
+                Message msg = obtainMessage(CMD_START_SCAN,
+                        message.arg1, message.arg2, bundle);
+                mBufferedScanMsg.add(msg);
+            } else {
+                // if too many requests in buffer, combine them into a single full scan
+                bundle = new Bundle();
+                bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, null);
+                bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
+                Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
+                mBufferedScanMsg.clear();
+                mBufferedScanMsg.add(msg);
+            }
+            messageHandlingStatus = MESSAGE_HANDLING_STATUS_LOOPED;
+        } else {
+            // mIsScanOngoing and mIsFullScanOngoing
+            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+        }
+    }
+
+
+    /** return true iff scan request is accepted */
+    private boolean startScanNative(int type, String freqs) {
+        if (mWifiNative.scan(type, freqs)) {
+            mIsScanOngoing = true;
+            mIsFullScanOngoing = (freqs == null);
+            lastScanFreqs = freqs;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * TODO: doc
+     */
+    public void setSupplicantRunning(boolean enable) {
+        if (enable) {
+            sendMessage(CMD_START_SUPPLICANT);
+        } else {
+            sendMessage(CMD_STOP_SUPPLICANT);
+        }
+    }
+
+    /**
+     * TODO: doc
+     */
+    public void setHostApRunning(WifiConfiguration wifiConfig, boolean enable) {
+        if (enable) {
+            sendMessage(CMD_START_AP, wifiConfig);
+        } else {
+            sendMessage(CMD_STOP_AP);
+        }
+    }
+
+    public void setWifiApConfiguration(WifiConfiguration config) {
+        mWifiApConfigChannel.sendMessage(CMD_SET_AP_CONFIG, config);
+    }
+
+    public WifiConfiguration syncGetWifiApConfiguration() {
+        Message resultMsg = mWifiApConfigChannel.sendMessageSynchronously(CMD_REQUEST_AP_CONFIG);
+        WifiConfiguration ret = (WifiConfiguration) resultMsg.obj;
+        resultMsg.recycle();
+        return ret;
+    }
+
+    /**
+     * TODO: doc
+     */
+    public int syncGetWifiState() {
+        return mWifiState.get();
+    }
+
+    /**
+     * TODO: doc
+     */
+    public String syncGetWifiStateByName() {
+        switch (mWifiState.get()) {
+            case WIFI_STATE_DISABLING:
+                return "disabling";
+            case WIFI_STATE_DISABLED:
+                return "disabled";
+            case WIFI_STATE_ENABLING:
+                return "enabling";
+            case WIFI_STATE_ENABLED:
+                return "enabled";
+            case WIFI_STATE_UNKNOWN:
+                return "unknown state";
+            default:
+                return "[invalid state]";
+        }
+    }
+
+    /**
+     * TODO: doc
+     */
+    public int syncGetWifiApState() {
+        return mWifiApState.get();
+    }
+
+    /**
+     * TODO: doc
+     */
+    public String syncGetWifiApStateByName() {
+        switch (mWifiApState.get()) {
+            case WIFI_AP_STATE_DISABLING:
+                return "disabling";
+            case WIFI_AP_STATE_DISABLED:
+                return "disabled";
+            case WIFI_AP_STATE_ENABLING:
+                return "enabling";
+            case WIFI_AP_STATE_ENABLED:
+                return "enabled";
+            case WIFI_AP_STATE_FAILED:
+                return "failed";
+            default:
+                return "[invalid state]";
+        }
+    }
+
+    /**
+     * Get status information for the current connection, if any.
+     * @return a {@link WifiInfo} object containing information about the current connection
+     *
+     */
+    public WifiInfo syncRequestConnectionInfo() {
+        return mWifiInfo;
+    }
+
+    public DhcpResults syncGetDhcpResults() {
+        synchronized (mDhcpResultsLock) {
+            return new DhcpResults(mDhcpResults);
+        }
+    }
+
+    /**
+     * TODO: doc
+     */
+    public void setDriverStart(boolean enable) {
+        if (enable) {
+            sendMessage(CMD_START_DRIVER);
+        } else {
+            sendMessage(CMD_STOP_DRIVER);
+        }
+    }
+
+    /**
+     * TODO: doc
+     */
+    public void setOperationalMode(int mode) {
+        if (DBG) log("setting operational mode to " + String.valueOf(mode));
+        sendMessage(CMD_SET_OPERATIONAL_MODE, mode, 0);
+    }
+
+    /**
+     * TODO: doc
+     */
+    public List<ScanResult> syncGetScanResultsList() {
+        synchronized (mScanResultCache) {
+            List<ScanResult> scanList = new ArrayList<ScanResult>();
+            for(ScanResult result: mScanResults) {
+                scanList.add(new ScanResult(result));
+            }
+            return scanList;
+        }
+    }
+
+    /**
+     * Get unsynchronized pointer to scan result list
+     * Can be called only from AutoJoinController which runs in the WifiStateMachine context
+     */
+    public List<ScanResult> getScanResultsListNoCopyUnsync() {
+        return mScanResults;
+    }
+
+    /**
+     * Disconnect from Access Point
+     */
+    public void disconnectCommand() {
+        sendMessage(CMD_DISCONNECT);
+    }
+
+    /**
+     * Initiate a reconnection to AP
+     */
+    public void reconnectCommand() {
+        sendMessage(CMD_RECONNECT);
+    }
+
+    /**
+     * Initiate a re-association to AP
+     */
+    public void reassociateCommand() {
+        sendMessage(CMD_REASSOCIATE);
+    }
+
+    /**
+     * Reload networks and then reconnect; helps load correct data for TLS networks
+     */
+
+    public void reloadTlsNetworksAndReconnect() {
+        sendMessage(CMD_RELOAD_TLS_AND_RECONNECT);
+    }
+
+    /**
+     * Add a network synchronously
+     *
+     * @return network id of the new network
+     */
+    public int syncAddOrUpdateNetwork(AsyncChannel channel, WifiConfiguration config) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_ADD_OR_UPDATE_NETWORK, config);
+        int result = resultMsg.arg1;
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Get configured networks synchronously
+     * @param channel
+     * @return
+     */
+
+    public List<WifiConfiguration> syncGetConfiguredNetworks(int uuid, AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_CONFIGURED_NETWORKS, uuid);
+        List<WifiConfiguration> result = (List<WifiConfiguration>) resultMsg.obj;
+        resultMsg.recycle();
+        return result;
+    }
+
+    public List<WifiConfiguration> syncGetPrivilegedConfiguredNetwork(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(
+                CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS);
+        List<WifiConfiguration> result = (List<WifiConfiguration>) resultMsg.obj;
+        resultMsg.recycle();
+        return result;
+    }
+
+
+    /**
+     * Get connection statistics synchronously
+     * @param channel
+     * @return
+     */
+
+    public WifiConnectionStatistics syncGetConnectionStatistics(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_CONNECTION_STATISTICS);
+        WifiConnectionStatistics result = (WifiConnectionStatistics) resultMsg.obj;
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Get adaptors synchronously
+     */
+
+    public int syncGetSupportedFeatures(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_SUPPORTED_FEATURES);
+        int supportedFeatureSet = resultMsg.arg1;
+        resultMsg.recycle();
+        return supportedFeatureSet;
+    }
+
+    /**
+     * Get link layers stats for adapter synchronously
+     */
+    public WifiLinkLayerStats syncGetLinkLayerStats(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_GET_LINK_LAYER_STATS);
+        WifiLinkLayerStats result = (WifiLinkLayerStats) resultMsg.obj;
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Delete a network
+     *
+     * @param networkId id of the network to be removed
+     */
+    public boolean syncRemoveNetwork(AsyncChannel channel, int networkId) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_REMOVE_NETWORK, networkId);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Enable a network
+     *
+     * @param netId network id of the network
+     * @param disableOthers true, if all other networks have to be disabled
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     */
+    public boolean syncEnableNetwork(AsyncChannel channel, int netId, boolean disableOthers) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_ENABLE_NETWORK, netId,
+                disableOthers ? 1 : 0);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Disable a network
+     *
+     * @param netId network id of the network
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     */
+    public boolean syncDisableNetwork(AsyncChannel channel, int netId) {
+        Message resultMsg = channel.sendMessageSynchronously(WifiManagerWAP.DISABLE_NETWORK, netId);
+        boolean result = (resultMsg.arg1 != WifiManagerWAP.DISABLE_NETWORK_FAILED);
+        resultMsg.recycle();
+        return result;
+    }
+
+    /**
+     * Retrieves a WPS-NFC configuration token for the specified network
+     * @return a hex string representation of the WPS-NFC configuration token
+     */
+    public String syncGetWpsNfcConfigurationToken(int netId) {
+        return mWifiNative.getNfcWpsConfigurationToken(netId);
+    }
+
+    /**
+     * Blacklist a BSSID. This will avoid the AP if there are
+     * alternate APs to connect
+     *
+     * @param bssid BSSID of the network
+     */
+    public void addToBlacklist(String bssid) {
+        sendMessage(CMD_BLACKLIST_NETWORK, bssid);
+    }
+
+    /**
+     * Clear the blacklist list
+     *
+     */
+    public void clearBlacklist() {
+        sendMessage(CMD_CLEAR_BLACKLIST);
+    }
+
+    public void enableRssiPolling(boolean enabled) {
+       sendMessage(CMD_ENABLE_RSSI_POLL, enabled ? 1 : 0, 0);
+    }
+
+    public void enableAllNetworks() {
+        sendMessage(CMD_ENABLE_ALL_NETWORKS);
+    }
+
+    /**
+     * Start filtering Multicast v4 packets
+     */
+    public void startFilteringMulticastV4Packets() {
+        mFilteringMulticastV4Packets.set(true);
+        sendMessage(CMD_START_PACKET_FILTERING, MULTICAST_V4, 0);
+    }
+
+    /**
+     * Stop filtering Multicast v4 packets
+     */
+    public void stopFilteringMulticastV4Packets() {
+        mFilteringMulticastV4Packets.set(false);
+        sendMessage(CMD_STOP_PACKET_FILTERING, MULTICAST_V4, 0);
+    }
+
+    /**
+     * Start filtering Multicast v4 packets
+     */
+    public void startFilteringMulticastV6Packets() {
+        sendMessage(CMD_START_PACKET_FILTERING, MULTICAST_V6, 0);
+    }
+
+    /**
+     * Stop filtering Multicast v4 packets
+     */
+    public void stopFilteringMulticastV6Packets() {
+        sendMessage(CMD_STOP_PACKET_FILTERING, MULTICAST_V6, 0);
+    }
+
+    /**
+     * Set high performance mode of operation.
+     * Enabling would set active power mode and disable suspend optimizations;
+     * disabling would set auto power mode and enable suspend optimizations
+     * @param enable true if enable, false otherwise
+     */
+    public void setHighPerfModeEnabled(boolean enable) {
+        sendMessage(CMD_SET_HIGH_PERF_MODE, enable ? 1 : 0, 0);
+    }
+
+    /**
+     * Set the country code
+     * @param countryCode following ISO 3166 format
+     * @param persist {@code true} if the setting should be remembered.
+     */
+    public void setCountryCode(String countryCode, boolean persist) {
+        // If it's a good country code, apply after the current
+        // wifi connection is terminated; ignore resetting of code
+        // for now (it is unclear what the chipset should do when
+        // country code is reset)
+        int countryCodeSequence = mCountryCodeSequence.incrementAndGet();
+        if (TextUtils.isEmpty(countryCode)) {
+            log("Ignoring resetting of country code");
+        } else {
+            sendMessage(CMD_SET_COUNTRY_CODE, countryCodeSequence, persist ? 1 : 0, countryCode);
+        }
+    }
+
+    /**
+     * Set the operational frequency band
+     * @param band
+     * @param persist {@code true} if the setting should be remembered.
+     */
+    public void setFrequencyBand(int band, boolean persist) {
+        if (persist) {
+            Settings.Global.putInt(mContext.getContentResolver(),
+                    Settings.Global.WIFI_FREQUENCY_BAND,
+                    band);
+        }
+        sendMessage(CMD_SET_FREQUENCY_BAND, band, 0);
+    }
+
+    /**
+     * Enable TDLS for a specific MAC address
+     */
+    public void enableTdls(String remoteMacAddress, boolean enable) {
+        int enabler = enable ? 1 : 0;
+        sendMessage(CMD_ENABLE_TDLS, enabler, 0, remoteMacAddress);
+    }
+
+    /**
+     * Returns the operational frequency band
+     */
+    public int getFrequencyBand() {
+        return mFrequencyBand.get();
+    }
+
+    /**
+     * Returns the wifi configuration file
+     */
+    public String getConfigFile() {
+        return mWifiConfigStore.getConfigFile();
+    }
+
+    /**
+     * Send a message indicating bluetooth adapter connection state changed
+     */
+    public void sendBluetoothAdapterStateChange(int state) {
+        sendMessage(CMD_BLUETOOTH_ADAPTER_STATE_CHANGE, state, 0);
+    }
+
+    /**
+     * Save configuration on supplicant
+     *
+     * @return {@code true} if the operation succeeds, {@code false} otherwise
+     *
+     * TODO: deprecate this
+     */
+    public boolean syncSaveConfig(AsyncChannel channel) {
+        Message resultMsg = channel.sendMessageSynchronously(CMD_SAVE_CONFIG);
+        boolean result = (resultMsg.arg1 != FAILURE);
+        resultMsg.recycle();
+        return result;
+    }
+
+    public void updateBatteryWorkSource(WorkSource newSource) {
+        synchronized (mRunningWifiUids) {
+            try {
+                if (newSource != null) {
+                    mRunningWifiUids.set(newSource);
+                }
+                if (mIsRunning) {
+                    if (mReportedRunning) {
+                        // If the work source has changed since last time, need
+                        // to remove old work from battery stats.
+                        if (mLastRunningWifiUids.diff(mRunningWifiUids)) {
+                            mBatteryStats.noteWifiRunningChanged(mLastRunningWifiUids,
+                                    mRunningWifiUids);
+                            mLastRunningWifiUids.set(mRunningWifiUids);
+                        }
+                    } else {
+                        // Now being started, report it.
+                        mBatteryStats.noteWifiRunning(mRunningWifiUids);
+                        mLastRunningWifiUids.set(mRunningWifiUids);
+                        mReportedRunning = true;
+                    }
+                } else {
+                    if (mReportedRunning) {
+                        // Last reported we were running, time to stop.
+                        mBatteryStats.noteWifiStopped(mLastRunningWifiUids);
+                        mLastRunningWifiUids.clear();
+                        mReportedRunning = false;
+                    }
+                }
+                mWakeLock.setWorkSource(newSource);
+            } catch (RemoteException ignore) {
+            }
+        }
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        super.dump(fd, pw, args);
+        mSupplicantStateTracker.dump(fd, pw, args);
+        pw.println("mLinkProperties " + mLinkProperties);
+        pw.println("mWifiInfo " + mWifiInfo);
+        pw.println("mDhcpResults " + mDhcpResults);
+        pw.println("mNetworkInfo " + mNetworkInfo);
+        pw.println("mLastSignalLevel " + mLastSignalLevel);
+        pw.println("mLastBssid " + mLastBssid);
+        pw.println("mLastNetworkId " + mLastNetworkId);
+        pw.println("mOperationalMode " + mOperationalMode);
+        pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
+        pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
+        pw.println("Supplicant status " + mWifiNative.status(true));
+        pw.println("mEnableBackgroundScan " + mEnableBackgroundScan);
+        pw.println("mLastSetCountryCode " + mLastSetCountryCode);
+        pw.println("mPersistedCountryCode " + mPersistedCountryCode);
+        pw.println();
+        mWifiConfigStore.dump(fd, pw, args);
+    }
+
+    /*********************************************************
+     * Internal private functions
+     ********************************************************/
+
+    private void logStateAndMessage(Message message, String state) {
+        messageHandlingStatus = 0;
+        if (mLogMessages) {
+            //long now = SystemClock.elapsedRealtimeNanos();
+            //String ts = String.format("[%,d us]", now/1000);
+
+            loge( " " + state + " " + getLogRecString(message));
+        }
+    }
+
+    /**
+     * Return the additional string to be logged by LogRec, default
+     *
+     * @param msg that was processed
+     * @return information to be logged as a String
+     */
+    protected String getLogRecString(Message msg) {
+        WifiConfiguration config;
+        Long now;
+        long milli;
+        String report;
+        StringBuilder sb = new StringBuilder();
+        if (mScreenOn) {
+            sb.append("!");
+        }
+        if (messageHandlingStatus != MESSAGE_HANDLING_STATUS_UNKNOWN) {
+            sb.append("(").append(messageHandlingStatus).append(")");
+        }
+        sb.append(smToString(msg));
+        if (msg.sendingUid > 0 && msg.sendingUid != Process.WIFI_UID) {
+            sb.append(" uid=" + msg.sendingUid);
+        }
+        switch (msg.what) {
+            case CMD_START_SCAN:
+                now = System.currentTimeMillis();
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" ic=");
+                sb.append(Integer.toString(sScanAlarmIntentCount));
+                if (msg.obj != null) {
+                    Bundle bundle = (Bundle)msg.obj;
+                    Long request = bundle.getLong(SCAN_REQUEST_TIME, 0);
+                    if (request != 0) {
+                        sb.append(" proc(ms):").append(now - request);
+                    }
+                }
+                if (mIsScanOngoing) sb.append(" onGoing");
+                if (mIsFullScanOngoing) sb.append(" full");
+                if (lastStartScanTimeStamp != 0) {
+                    sb.append(" started:").append(lastStartScanTimeStamp);
+                    sb.append(",").append(now - lastStartScanTimeStamp);
+                }
+                if (lastScanDuration != 0) {
+                    sb.append(" dur:").append(lastScanDuration);
+                }
+                sb.append(" rssi=").append(mWifiInfo.getRssi());
+                sb.append(" f=").append(mWifiInfo.getFrequency());
+                sb.append(" sc=").append(mWifiInfo.score);
+                sb.append(" link=").append(mWifiInfo.getLinkSpeed());
+                sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
+                sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
+                sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
+                sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
+                if (lastScanFreqs != null) {
+                    sb.append(" list=").append(lastScanFreqs);
+                } else {
+                    sb.append(" fiv=").append(fullBandConnectedTimeIntervalMilli);
+                }
+                report = reportOnTime();
+                if (report != null) {
+                    sb.append(" ").append(report);
+                }
+                break;
+            case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" rt=").append(milli).append(" ");
+                StateChangeResult stateChangeResult = (StateChangeResult) msg.obj;
+                if (stateChangeResult != null) {
+                    sb.append(stateChangeResult.toString());
+                }
+                break;
+            case WifiManagerWAP.SAVE_NETWORK:
+            case WifiStateMachineWAP.CMD_AUTO_SAVE_NETWORK:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (lastSavedConfigurationAttempt != null) {
+                    sb.append(" ").append(lastSavedConfigurationAttempt.configKey());
+                    sb.append(" nid=").append(lastSavedConfigurationAttempt.networkId);
+                    if (lastSavedConfigurationAttempt.hiddenSSID) {
+                        sb.append(" hidden");
+                    }
+                    if (lastSavedConfigurationAttempt.preSharedKey != null
+                            && !lastSavedConfigurationAttempt.preSharedKey.equals("*")) {
+                        sb.append(" hasPSK");
+                    }
+                    if (lastSavedConfigurationAttempt.ephemeral) {
+                        sb.append(" ephemeral");
+                    }
+                    if (lastSavedConfigurationAttempt.selfAdded) {
+                        sb.append(" selfAdded");
+                    }
+                    sb.append(" cuid=").append(lastSavedConfigurationAttempt.creatorUid);
+                    sb.append(" suid=").append(lastSavedConfigurationAttempt.lastUpdateUid);
+                }
+                break;
+            case WifiManagerWAP.FORGET_NETWORK:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (lastForgetConfigurationAttempt != null) {
+                    sb.append(" ").append(lastForgetConfigurationAttempt.configKey());
+                    sb.append(" nid=").append(lastForgetConfigurationAttempt.networkId);
+                    if (lastForgetConfigurationAttempt.hiddenSSID) {
+                        sb.append(" hidden");
+                    }
+                    if (lastForgetConfigurationAttempt.preSharedKey != null) {
+                        sb.append(" hasPSK");
+                    }
+                    if (lastForgetConfigurationAttempt.ephemeral) {
+                        sb.append(" ephemeral");
+                    }
+                    if (lastForgetConfigurationAttempt.selfAdded) {
+                        sb.append(" selfAdded");
+                    }
+                    sb.append(" cuid=").append(lastForgetConfigurationAttempt.creatorUid);
+                    sb.append(" suid=").append(lastForgetConfigurationAttempt.lastUpdateUid);
+                    sb.append(" ajst=").append(lastForgetConfigurationAttempt.autoJoinStatus);
+                }
+                break;
+            case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                String bssid = (String)msg.obj;
+                if (bssid != null && bssid.length()>0) {
+                    sb.append(" ");
+                    sb.append(bssid);
+                }
+                sb.append(" blacklist=" + Boolean.toString(didBlackListBSSID));
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case WifiMonitor.SCAN_RESULTS_EVENT:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (mScanResults != null) {
+                    sb.append(" found=");
+                    sb.append(mScanResults.size());
+                }
+                sb.append(" known=").append(mNumScanResultsKnown);
+                sb.append(" got=").append(mNumScanResultsReturned);
+                if (lastScanDuration != 0) {
+                    sb.append(" dur:").append(lastScanDuration);
+                }
+                if (mOnTime != 0) {
+                    sb.append(" on:").append(mOnTimeThisScan).append(",").append(mOnTimeScan);
+                    sb.append(",").append(mOnTime);
+                }
+                if (mTxTime != 0) {
+                    sb.append(" tx:").append(mTxTimeThisScan).append(",").append(mTxTimeScan);
+                    sb.append(",").append(mTxTime);
+                }
+                if (mRxTime != 0) {
+                    sb.append(" rx:").append(mRxTimeThisScan).append(",").append(mRxTimeScan);
+                    sb.append(",").append(mRxTime);
+                }
+                sb.append(String.format(" bcn=%d", mRunningBeaconCount));
+                break;
+            case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" ").append(mLastBssid);
+                sb.append(" nid=").append(mLastNetworkId);
+                config = getCurrentWifiConfiguration();
+                if (config != null) {
+                    sb.append(" ").append(config.configKey());
+                }
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case CMD_TARGET_BSSID:
+            case CMD_ASSOCIATED_BSSID:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (msg.obj != null) {
+                    sb.append(" BSSID=").append((String)msg.obj);
+                }
+                if (mTargetRoamBSSID != null) {
+                    sb.append(" Target=").append(mTargetRoamBSSID);
+                }
+                sb.append(" roam=").append(Integer.toString(mAutoRoaming));
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                if (msg.obj != null) {
+                    sb.append(" ").append((String)msg.obj);
+                }
+                sb.append(" nid=").append(msg.arg1);
+                sb.append(" reason=").append(msg.arg2);
+                if (mLastBssid != null) {
+                    sb.append(" lastbssid=").append(mLastBssid);
+                }
+                if (mWifiInfo.getFrequency() != -1) {
+                    sb.append(" freq=").append(mWifiInfo.getFrequency());
+                    sb.append(" rssi=").append(mWifiInfo.getRssi());
+                }
+                if (linkDebouncing) {
+                    sb.append(" debounce");
+                }
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case WifiMonitor.SSID_TEMP_DISABLED:
+            case WifiMonitor.SSID_REENABLED:
+                sb.append(" nid=").append(msg.arg1);
+                if (msg.obj != null) {
+                    sb.append(" ").append((String)msg.obj);
+                }
+                config = getCurrentWifiConfiguration();
+                if (config != null) {
+                    sb.append(" cur=").append(config.configKey());
+                    sb.append(" ajst=").append(config.autoJoinStatus);
+                    if (config.selfAdded) {
+                        sb.append(" selfAdded");
+                    }
+                    if (config.status != 0) {
+                        sb.append(" st=").append(config.status);
+                        sb.append(" rs=").append(config.disableReason);
+                    }
+                    if (config.lastConnected != 0) {
+                        now = System.currentTimeMillis();
+                        sb.append(" lastconn=").append(now - config.lastConnected).append("(ms)");
+                    }
+                    if (mLastBssid != null) {
+                        sb.append(" lastbssid=").append(mLastBssid);
+                    }
+                    if (mWifiInfo.getFrequency() != -1) {
+                        sb.append(" freq=").append(mWifiInfo.getFrequency());
+                        sb.append(" rssi=").append(mWifiInfo.getRssi());
+                        sb.append(" bssid=").append(mWifiInfo.getBSSID());
+                    }
+                }
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case CMD_RSSI_POLL:
+            case CMD_UNWANTED_NETWORK:
+            case WifiManagerWAP.RSSI_PKTCNT_FETCH:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (mWifiInfo.getSSID() != null)
+                if (mWifiInfo.getSSID() != null)
+                    sb.append(" ").append(mWifiInfo.getSSID());
+                if (mWifiInfo.getBSSID() != null)
+                    sb.append(" ").append(mWifiInfo.getBSSID());
+                sb.append(" rssi=").append(mWifiInfo.getRssi());
+                sb.append(" f=").append(mWifiInfo.getFrequency());
+                sb.append(" sc=").append(mWifiInfo.score);
+                sb.append(" link=").append(mWifiInfo.getLinkSpeed());
+                sb.append(String.format(" tx=%.1f,", mWifiInfo.txSuccessRate));
+                sb.append(String.format(" %.1f,", mWifiInfo.txRetriesRate));
+                sb.append(String.format(" %.1f ", mWifiInfo.txBadRate));
+                sb.append(String.format(" rx=%.1f", mWifiInfo.rxSuccessRate));
+                sb.append(String.format(" bcn=%d", mRunningBeaconCount));
+                report = reportOnTime();
+                if (report != null) {
+                    sb.append(" ").append(report);
+                }
+                if (wifiScoringReport != null) {
+                    sb.append(wifiScoringReport);
+                }
+                break;
+            case CMD_AUTO_CONNECT:
+            case WifiManagerWAP.CONNECT_NETWORK:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                config = (WifiConfiguration) msg.obj;
+                if (config != null) {
+                    sb.append(" ").append(config.configKey());
+                    if (config.visibility != null) {
+                        sb.append(" [").append(config.visibility.num24);
+                        sb.append(" ,").append(config.visibility.rssi24);
+                        sb.append(" ;").append(config.visibility.num5);
+                        sb.append(" ,").append(config.visibility.rssi5).append("]");
+                    }
+                }
+                if (mTargetRoamBSSID != null) {
+                    sb.append(" ").append(mTargetRoamBSSID);
+                }
+                sb.append(" roam=").append(Integer.toString(mAutoRoaming));
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                config = getCurrentWifiConfiguration();
+                if (config != null) {
+                    sb.append(" ").append(config.configKey());
+                    if (config.visibility != null) {
+                        sb.append(" [").append(config.visibility.num24);
+                        sb.append(" ,").append(config.visibility.rssi24);
+                        sb.append(" ;").append(config.visibility.num5);
+                        sb.append(" ,").append(config.visibility.rssi5).append("]");
+                    }
+                }
+                break;
+            case CMD_AUTO_ROAM:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                ScanResult result = (ScanResult)msg.obj;
+                if (result != null) {
+                    now = System.currentTimeMillis();
+                    sb.append(" bssid=").append(result.BSSID);
+                    sb.append(" rssi=").append(result.level);
+                    sb.append(" freq=").append(result.frequency);
+                    if (result.seen > 0 && result.seen < now) {
+                        sb.append(" seen=").append(now - result.seen);
+                    } else {
+                        // Somehow the timestamp for this scan result is inconsistent
+                        sb.append(" !seen=").append(result.seen);
+                    }
+                }
+                if (mTargetRoamBSSID != null) {
+                    sb.append(" ").append(mTargetRoamBSSID);
+                }
+                sb.append(" roam=").append(Integer.toString(mAutoRoaming));
+                sb.append(" fail count=").append(Integer.toString(mRoamFailCount));
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                break;
+            case CMD_ADD_OR_UPDATE_NETWORK:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (msg.obj != null) {
+                    config = (WifiConfiguration)msg.obj;
+                    sb.append(" ").append(config.configKey());
+                    sb.append(" prio=").append(config.priority);
+                    sb.append(" status=").append(config.status);
+                    if (config.BSSID != null) {
+                        sb.append(" ").append(config.BSSID);
+                    }
+                    WifiConfiguration curConfig = getCurrentWifiConfiguration();
+                    if (curConfig != null) {
+                        if (curConfig.configKey().equals(config.configKey())) {
+                            sb.append(" is current");
+                        } else {
+                            sb.append(" current=").append(curConfig.configKey());
+                            sb.append(" prio=").append(curConfig.priority);
+                            sb.append(" status=").append(curConfig.status);
+                        }
+                    }
+                }
+                break;
+            case WifiManagerWAP.DISABLE_NETWORK:
+            case CMD_ENABLE_NETWORK:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                String key = mWifiConfigStore.getLastSelectedConfiguration();
+                if (key != null) {
+                    sb.append(" last=").append(key);
+                }
+                config = mWifiConfigStore.getWifiConfiguration(msg.arg1);
+                if (config != null && (key == null || !config.configKey().equals(key))) {
+                    sb.append(" target=").append(key);
+                }
+                break;
+            case CMD_GET_CONFIGURED_NETWORKS:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" num=").append(mWifiConfigStore.getConfiguredNetworksSize());
+                break;
+            case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" txpkts=").append(mWifiInfo.txSuccess);
+                sb.append(",").append(mWifiInfo.txBad);
+                sb.append(",").append(mWifiInfo.txRetries);
+                break;
+            case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (msg.arg1 == DhcpStateMachine.DHCP_SUCCESS) {
+                    sb.append(" OK ");
+                } else if (msg.arg1 == DhcpStateMachine.DHCP_FAILURE) {
+                    sb.append(" FAIL ");
+                }
+                if (mLinkProperties != null) {
+                    if (mLinkProperties.hasIPv4Address()) {
+                        sb.append(" v4");
+                    }
+                    if (mLinkProperties.hasGlobalIPv6Address()) {
+                        sb.append(" v6");
+                    }
+                    if (mLinkProperties.hasIPv4DefaultRoute()) {
+                        sb.append(" v4r");
+                    }
+                    if (mLinkProperties.hasIPv6DefaultRoute()) {
+                        sb.append(" v6r");
+                    }
+                    if (mLinkProperties.hasIPv4DnsServer()) {
+                        sb.append(" v4dns");
+                    }
+                    if (mLinkProperties.hasIPv6DnsServer()) {
+                        sb.append(" v6dns");
+                    }
+                }
+                break;
+            case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (msg.obj != null) {
+                    NetworkInfo info = (NetworkInfo)msg.obj;
+                    NetworkInfo.State state = info.getState();
+                    NetworkInfo.DetailedState detailedState = info.getDetailedState();
+                    if (state != null) {
+                        sb.append(" st=").append(state);
+                    }
+                    if (detailedState != null) {
+                        sb.append("/").append(detailedState);
+                    }
+                }
+                break;
+            case CMD_IP_CONFIGURATION_LOST:
+                int count = -1;
+                WifiConfiguration c = getCurrentWifiConfiguration();
+                if (c != null) count = c.numIpConfigFailures;
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" failures: ");
+                sb.append(Integer.toString(count));
+                sb.append("/");
+                sb.append(Integer.toString(mWifiConfigStore.getMaxDhcpRetries()));
+                if (mWifiInfo.getBSSID() != null) {
+                    sb.append(" ").append(mWifiInfo.getBSSID());
+                }
+                if (c != null) {
+                    if (c.scanResultCache != null) {
+                        for (ScanResult r : c.scanResultCache.values()) {
+                            if (r.BSSID.equals(mWifiInfo.getBSSID())) {
+                                sb.append(" ipfail=").append(r.numIpConfigFailures);
+                                sb.append(",st=").append(r.autoJoinStatus);
+                            }
+                        }
+                    }
+                    sb.append(" -> ajst=").append(c.autoJoinStatus);
+                    sb.append(" ").append(c.disableReason);
+                    sb.append(" txpkts=").append(mWifiInfo.txSuccess);
+                    sb.append(",").append(mWifiInfo.txBad);
+                    sb.append(",").append(mWifiInfo.txRetries);
+                }
+                milli = SystemClock.elapsedRealtime();
+                sb.append(" rt=").append(milli);
+                sb.append(String.format(" bcn=%d", mRunningBeaconCount));
+                break;
+            case CMD_UPDATE_LINKPROPERTIES:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (mLinkProperties != null) {
+                    if (mLinkProperties.hasIPv4Address()) {
+                        sb.append(" v4");
+                    }
+                    if (mLinkProperties.hasGlobalIPv6Address()) {
+                        sb.append(" v6");
+                    }
+                    if (mLinkProperties.hasIPv4DefaultRoute()) {
+                        sb.append(" v4r");
+                    }
+                    if (mLinkProperties.hasIPv6DefaultRoute()) {
+                        sb.append(" v6r");
+                    }
+                    if (mLinkProperties.hasIPv4DnsServer()) {
+                        sb.append(" v4dns");
+                    }
+                    if (mLinkProperties.hasIPv6DnsServer()) {
+                        sb.append(" v6dns");
+                    }
+                }
+                break;
+            case CMD_SET_COUNTRY_CODE:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                if (msg.obj != null) {
+                    sb.append(" ").append((String)msg.obj);
+                }
+                break;
+            case CMD_ROAM_WATCHDOG_TIMER:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" cur=").append(roamWatchdogCount);
+                break;
+            case CMD_DISCONNECTING_WATCHDOG_TIMER:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                sb.append(" cur=").append(disconnectingWatchdogCount);
+                break;
+            default:
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg1));
+                sb.append(" ");
+                sb.append(Integer.toString(msg.arg2));
+                break;
+        }
+
+        return sb.toString();
+    }
+
+    private void handleBSSIDBlacklist(boolean enable, String bssid, int reason) {
+        log("Blacklisting BSSID: " + bssid + ",reason:" + reason + ",enable:" + enable );
+        if (bssid != null) {
+            // Tell configStore to black list it
+            synchronized(mScanResultCache) {
+                mWifiAutoJoinController.handleBSSIDBlackList( enable, bssid, reason );
+                mWifiConfigStore.handleDisabledAPs( enable, bssid, reason );
+            }
+        }
+    }
+
+    private void handleStateChange(int state) {
+        int offset;
+        log("handle state change: " + state);
+        if(state == 0) {
+            // wifi is not good, reduce the score
+            mWifiInfo.score = 1;
+        } else {
+            // wifi is good, increase the score
+            mWifiInfo.score = NetworkAgent.WIFI_BASE_SCORE;
+        }
+        if(mNetworkAgent != null) {
+            mNetworkAgent.sendNetworkScore(mWifiInfo.score);
+        }
+    }
+
+    private void handlePrefChange(int featureId, int featureParam, int value) {
+        log("handle pref change : featurevalue: " + value);
+        if(featureId == FEATURE_ID && featureParam == FEATURE_PARAM) {
+            if(value == FEATURE_ON) {
+                DEFAULT_SCORE = 1;
+                isPropFeatureEnabled = true;
+            } else if(value == FEATURE_OFF) {
+                DEFAULT_SCORE = NetworkAgent.WIFI_BASE_SCORE;
+                isPropFeatureEnabled = false;
+            }
+        }
+    }
+
+    private void handleScreenStateChanged(boolean screenOn, boolean startBackgroundScanIfNeeded) {
+        mScreenOn = screenOn;
+        if (PDBG) {
+            loge(" handleScreenStateChanged Enter: screenOn=" + screenOn
+                    + " mCurrentScanAlarmMs = " + Long.toString(mCurrentScanAlarmMs)
+                    + " mUserWantsSuspendOpt=" + mUserWantsSuspendOpt
+                    + " state " + getCurrentState().getName()
+                    + " suppState:" + mSupplicantStateTracker.getSupplicantStateName());
+        }
+        enableRssiPolling(screenOn);
+        if (screenOn) enableAllNetworks();
+        if (mUserWantsSuspendOpt.get()) {
+            if (screenOn) {
+                sendMessage(CMD_SET_SUSPEND_OPT_ENABLED, 0, 0);
+            } else {
+                // Allow 2s for suspend optimizations to be set
+                mSuspendWakeLock.acquire(2000);
+                sendMessage(CMD_SET_SUSPEND_OPT_ENABLED, 1, 0);
+            }
+        }
+        mScreenBroadcastReceived.set(true);
+
+        getWifiLinkLayerStats(false);
+        mOnTimeScreenStateChange = mOnTime;
+        lastScreenStateChangeTimeStamp = lastLinkLayerStatsUpdate;
+
+        if (screenOn) {
+            clearBlacklist();
+
+            fullBandConnectedTimeIntervalMilli = mWifiConfigStore.associatedPartialScanPeriodMilli;
+            // Start the scan alarm so as to enable autojoin
+            if (getCurrentState() == mConnectedState
+                    && mWifiConfigStore.enableAutoJoinScanWhenAssociated) {
+                mCurrentScanAlarmMs = mWifiConfigStore.associatedPartialScanPeriodMilli;
+                // Scan after 200ms
+                setScanAlarm(true, 200);
+            } else if (getCurrentState() == mDisconnectedState) {
+
+                // Configure the scan alarm time to mFrameworkScanIntervalMs
+                // (5 minutes) if there are no saved profiles as there is
+                // already a periodic scan getting issued for every
+                // mSupplicantScanIntervalMs seconds. However keep the
+                // scan frequency by setting it to mDisconnectedScanPeriodMs
+                // (10 seconds) when there are configured profiles.
+                if (mWifiConfigStore.getConfiguredNetworks().size() != 0) {
+                    mCurrentScanAlarmMs = mDisconnectedScanPeriodMs;
+                } else {
+                    mCurrentScanAlarmMs = mFrameworkScanIntervalMs;
+                }
+
+                // Scan after 200ms
+                setScanAlarm(true, 200);
+            }
+        } else {
+            setScanAlarm(false, 0);
+        }
+
+        if (mBackgroundScanSupported) {
+            mEnableBackgroundScan = (screenOn == false);
+        }
+
+        if (DBG) logd("backgroundScan enabled=" + mEnableBackgroundScan
+                + " startBackgroundScanIfNeeded:" + startBackgroundScanIfNeeded);
+
+        if (startBackgroundScanIfNeeded) {
+            if (mEnableBackgroundScan) {
+                if (!mWifiNative.enableBackgroundScan(true)) {
+                    handlePnoFailError();
+                }
+            } else {
+               mWifiNative.enableBackgroundScan(false);
+            }
+        }
+
+        if (DBG) log("handleScreenStateChanged Exit: " + screenOn);
+    }
+
+    private void checkAndSetConnectivityInstance() {
+        if (mCm == null) {
+            mCm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        }
+    }
+
+    private boolean startTethering(ArrayList<String> available) {
+
+        boolean wifiAvailable = false;
+
+        checkAndSetConnectivityInstance();
+
+        String[] wifiRegexs = mCm.getTetherableWifiRegexs();
+
+        for (String intf : available) {
+            for (String regex : wifiRegexs) {
+                if (intf.matches(regex)) {
+
+                    InterfaceConfiguration ifcg = null;
+                    try {
+                        ifcg = mNwService.getInterfaceConfig(intf);
+                        if (ifcg != null) {
+                            /* IP/netmask: 192.168.43.1/255.255.255.0 */
+                            ifcg.setLinkAddress(new LinkAddress(
+                                    NetworkUtils.numericToInetAddress("10.9.8.101"), 24));
+                            ifcg.setInterfaceUp();
+
+                            mNwService.setInterfaceConfig(intf, ifcg);
+                        }
+                    } catch (Exception e) {
+                        loge("Error configuring interface " + intf + ", :" + e);
+                        return false;
+                    }
+
+                    if(mCm.tether(intf) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+                        loge("Error tethering on " + intf);
+                        return false;
+                    }
+                    mTetherInterfaceName = intf;
+                    return true;
+                }
+            }
+        }
+        // We found no interfaces to tether
+        return false;
+    }
+
+    private void stopTethering() {
+
+        checkAndSetConnectivityInstance();
+
+        /* Clear the interface config to allow dhcp correctly configure new
+           ip settings */
+        InterfaceConfiguration ifcg = null;
+        try {
+            ifcg = mNwService.getInterfaceConfig(mTetherInterfaceName);
+            if (ifcg != null) {
+                ifcg.setLinkAddress(
+                        new LinkAddress(NetworkUtils.numericToInetAddress("0.0.0.0"), 0));
+                mNwService.setInterfaceConfig(mTetherInterfaceName, ifcg);
+            }
+        } catch (Exception e) {
+            loge("Error resetting interface " + mTetherInterfaceName + ", :" + e);
+        }
+
+        if (mCm.untether(mTetherInterfaceName) != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
+            loge("Untether initiate failed!");
+        }
+    }
+
+    private boolean isWifiTethered(ArrayList<String> active) {
+
+        checkAndSetConnectivityInstance();
+
+        String[] wifiRegexs = mCm.getTetherableWifiRegexs();
+        for (String intf : active) {
+            for (String regex : wifiRegexs) {
+                if (intf.matches(regex)) {
+                    return true;
+                }
+            }
+        }
+        // We found no interfaces that are tethered
+        return false;
+    }
+
+    /**
+     * Set the country code from the system setting value, if any.
+     */
+    private void setCountryCode() {
+        String countryCode = Settings.Global.getString(mContext.getContentResolver(),
+                Settings.Global.WIFI_COUNTRY_CODE);
+        if (countryCode != null && !countryCode.isEmpty()) {
+            setCountryCode(countryCode, false);
+        } else {
+            //use driver default
+        }
+    }
+
+    /**
+     * Set the frequency band from the system setting value, if any.
+     */
+    private void setFrequencyBand() {
+        int band = Settings.Global.getInt(mContext.getContentResolver(),
+                Settings.Global.WIFI_FREQUENCY_BAND, WifiManagerWAP.WIFI_FREQUENCY_BAND_AUTO);
+        setFrequencyBand(band, false);
+    }
+
+    private void setSuspendOptimizationsNative(int reason, boolean enabled) {
+        if (DBG) {
+            log("setSuspendOptimizationsNative: " + reason + " " + enabled
+                    + " -want " + mUserWantsSuspendOpt.get()
+                    + " stack:" + Thread.currentThread().getStackTrace()[2].getMethodName()
+                    +" - "+ Thread.currentThread().getStackTrace()[3].getMethodName()
+                    +" - "+ Thread.currentThread().getStackTrace()[4].getMethodName()
+                    +" - "+ Thread.currentThread().getStackTrace()[5].getMethodName());
+        }
+        //mWifiNative.setSuspendOptimizations(enabled);
+
+        if (enabled) {
+            mSuspendOptNeedsDisabled &= ~reason;
+            /* None of dhcp, screen or highperf need it disabled and user wants it enabled */
+            if (mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get()) {
+                if (DBG) {
+                    log("setSuspendOptimizationsNative do it " + reason + " " + enabled
+                            + " stack:" + Thread.currentThread().getStackTrace()[2].getMethodName()
+                            +" - "+ Thread.currentThread().getStackTrace()[3].getMethodName()
+                            +" - "+ Thread.currentThread().getStackTrace()[4].getMethodName()
+                            +" - "+ Thread.currentThread().getStackTrace()[5].getMethodName());
+                }
+                mWifiNative.setSuspendOptimizations(true);
+            }
+        } else {
+            mSuspendOptNeedsDisabled |= reason;
+            mWifiNative.setSuspendOptimizations(false);
+        }
+    }
+
+    private void setSuspendOptimizations(int reason, boolean enabled) {
+        if (DBG) log("setSuspendOptimizations: " + reason + " " + enabled);
+        if (enabled) {
+            mSuspendOptNeedsDisabled &= ~reason;
+        } else {
+            mSuspendOptNeedsDisabled |= reason;
+        }
+        if (DBG) log("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
+    }
+
+    private void setWifiState(int wifiState) {
+        final int previousWifiState = mWifiState.get();
+
+        try {
+            if (wifiState == WIFI_STATE_ENABLED) {
+                mBatteryStats.noteWifiOn();
+            } else if (wifiState == WIFI_STATE_DISABLED) {
+                mBatteryStats.noteWifiOff();
+            }
+        } catch (RemoteException e) {
+            loge("Failed to note battery stats in wifi");
+        }
+
+        mWifiState.set(wifiState);
+
+        if (DBG) log("setWifiState: " + syncGetWifiStateByName());
+
+        final Intent intent = new Intent(WifiManagerWAP.WIFI_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_WIFI_STATE, wifiState);
+        intent.putExtra(WifiManagerWAP.EXTRA_PREVIOUS_WIFI_STATE, previousWifiState);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void setWifiApState(int wifiApState) {
+        final int previousWifiApState = mWifiApState.get();
+
+        try {
+            if (wifiApState == WIFI_AP_STATE_ENABLED) {
+                mBatteryStats.noteWifiOn();
+            } else if (wifiApState == WIFI_AP_STATE_DISABLED) {
+                mBatteryStats.noteWifiOff();
+            }
+        } catch (RemoteException e) {
+            loge("Failed to note battery stats in wifi");
+        }
+
+        // Update state
+        mWifiApState.set(wifiApState);
+
+        if (DBG) log("setWifiApState: " + syncGetWifiApStateByName());
+
+        final Intent intent = new Intent(WifiManagerWAP.WIFI_AP_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_WIFI_AP_STATE, wifiApState);
+        intent.putExtra(WifiManagerWAP.EXTRA_PREVIOUS_WIFI_AP_STATE, previousWifiApState);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    /*
+    void ageOutScanResults(int age) {
+        synchronized(mScanResultCache) {
+            // Trim mScanResults, which prevent WifiStateMachine to return
+            // obsolete scan results to queriers
+            long now = System.CurrentTimeMillis();
+            for (int i = 0; i < mScanResults.size(); i++) {
+                ScanResult result = mScanResults.get(i);
+                if ((result.seen > now || (now - result.seen) > age)) {
+                    mScanResults.remove(i);
+                }
+            }
+        }
+    }*/
+
+    private static final String ID_STR = "id=";
+    private static final String BSSID_STR = "bssid=";
+    private static final String FREQ_STR = "freq=";
+    private static final String LEVEL_STR = "level=";
+    private static final String TSF_STR = "tsf=";
+    private static final String FLAGS_STR = "flags=";
+    private static final String SSID_STR = "ssid=";
+    private static final String DELIMITER_STR = "====";
+    private static final String END_STR = "####";
+
+    int emptyScanResultCount = 0;
+
+    /**
+     * Format:
+     *
+     * id=1
+     * bssid=68:7f:76:d7:1a:6e
+     * freq=2412
+     * level=-44
+     * tsf=1344626243700342
+     * flags=[WPA2-PSK-CCMP][WPS][ESS]
+     * ssid=zfdy
+     * ====
+     * id=2
+     * bssid=68:5f:74:d7:1a:6f
+     * freq=5180
+     * level=-73
+     * tsf=1344626243700373
+     * flags=[WPA2-PSK-CCMP][WPS][ESS]
+     * ssid=zuby
+     * ====
+     */
+    private void setScanResults() {
+        mNumScanResultsKnown = 0;
+        mNumScanResultsReturned = 0;
+        String bssid = "";
+        int level = 0;
+        int freq = 0;
+        long tsf = 0;
+        String flags = "";
+        WifiSsid wifiSsid = null;
+        String scanResults;
+        String tmpResults;
+        StringBuffer scanResultsBuf = new StringBuffer();
+        int sid = 0;
+
+        while (true) {
+            tmpResults = mWifiNative.scanResults(sid);
+            if (TextUtils.isEmpty(tmpResults)) break;
+            scanResultsBuf.append(tmpResults);
+            scanResultsBuf.append("\n");
+            String[] lines = tmpResults.split("\n");
+            sid = -1;
+            for (int i=lines.length - 1; i >= 0; i--) {
+                if (lines[i].startsWith(END_STR)) {
+                    break;
+                } else if (lines[i].startsWith(ID_STR)) {
+                    try {
+                        sid = Integer.parseInt(lines[i].substring(ID_STR.length())) + 1;
+                    } catch (NumberFormatException e) {
+                        // Nothing to do
+                    }
+                    break;
+                }
+            }
+            if (sid == -1) break;
+        }
+
+        // Age out scan results, we return all scan results found in the last 12 seconds,
+        // and NOT all scan results since last scan.
+        // ageOutScanResults(12000);
+
+        scanResults = scanResultsBuf.toString();
+        if (TextUtils.isEmpty(scanResults)) {
+            emptyScanResultCount++;
+            if (emptyScanResultCount > 10) {
+                // If we got too many empty scan results, the current scan cache is stale,
+                // hence clear it.
+                mScanResults = new ArrayList<ScanResult>();
+            }
+           return;
+        }
+
+        emptyScanResultCount = 0;
+
+        // note that all these splits and substrings keep references to the original
+        // huge string buffer while the amount we really want is generally pretty small
+        // so make copies instead (one example b/11087956 wasted 400k of heap here).
+        synchronized(mScanResultCache) {
+            mScanResults = new ArrayList<ScanResult>();
+            String[] lines = scanResults.split("\n");
+            final int bssidStrLen = BSSID_STR.length();
+            final int flagLen = FLAGS_STR.length();
+
+            for (String line : lines) {
+                if (line.startsWith(BSSID_STR)) {
+                    bssid = new String(line.getBytes(), bssidStrLen, line.length() - bssidStrLen);
+                } else if (line.startsWith(FREQ_STR)) {
+                    try {
+                        freq = Integer.parseInt(line.substring(FREQ_STR.length()));
+                    } catch (NumberFormatException e) {
+                        freq = 0;
+                    }
+                } else if (line.startsWith(LEVEL_STR)) {
+                    try {
+                        level = Integer.parseInt(line.substring(LEVEL_STR.length()));
+                        /* some implementations avoid negative values by adding 256
+                         * so we need to adjust for that here.
+                         */
+                        if (level > 0) level -= 256;
+                    } catch(NumberFormatException e) {
+                        level = 0;
+                    }
+                } else if (line.startsWith(TSF_STR)) {
+                    try {
+                        tsf = Long.parseLong(line.substring(TSF_STR.length()));
+                    } catch (NumberFormatException e) {
+                        tsf = 0;
+                    }
+                } else if (line.startsWith(FLAGS_STR)) {
+                    flags = new String(line.getBytes(), flagLen, line.length() - flagLen);
+                } else if (line.startsWith(SSID_STR)) {
+                    wifiSsid = WifiSsid.createFromAsciiEncoded(
+                            line.substring(SSID_STR.length()));
+                } else if (line.startsWith(DELIMITER_STR) || line.startsWith(END_STR)) {
+                    if (bssid != null) {
+                        String ssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
+                        String key = bssid + ssid;
+                        ScanResult scanResult = mScanResultCache.get(key);
+                        if (scanResult != null) {
+                            // TODO: average the RSSI, instead of overwriting it
+                            scanResult.level = level;
+                            scanResult.wifiSsid = wifiSsid;
+                            // Keep existing API
+                            scanResult.SSID = (wifiSsid != null) ? wifiSsid.toString() :
+                                    WifiSsid.NONE;
+                            scanResult.capabilities = flags;
+                            scanResult.frequency = freq;
+                            scanResult.timestamp = tsf;
+                            scanResult.seen = System.currentTimeMillis();
+                        } else {
+                            scanResult =
+                                new ScanResult(
+                                        wifiSsid, bssid, flags, level, freq, tsf);
+                            scanResult.seen = System.currentTimeMillis();
+                            mScanResultCache.put(key, scanResult);
+                        }
+                        mNumScanResultsReturned ++; // Keep track of how many scan results we got
+                                                    // as part of this scan's processing
+                        mScanResults.add(scanResult);
+                    }
+                    bssid = null;
+                    level = 0;
+                    freq = 0;
+                    tsf = 0;
+                    flags = "";
+                    wifiSsid = null;
+                }
+            }
+        }
+        boolean attemptAutoJoin = true;
+        SupplicantState state = mWifiInfo.getSupplicantState();
+        if (getCurrentState() == mRoamingState
+                || getCurrentState() == mObtainingIpState
+                || getCurrentState() == mScanModeState
+                || getCurrentState() == mDisconnectingState
+                || (getCurrentState() == mConnectedState
+                && !mWifiConfigStore.enableAutoJoinWhenAssociated)
+                || linkDebouncing
+                || state == SupplicantState.ASSOCIATING
+                || state == SupplicantState.AUTHENTICATING
+                || state == SupplicantState.FOUR_WAY_HANDSHAKE
+                || state == SupplicantState.GROUP_HANDSHAKE) {
+            // Dont attempt auto-joining again while we are already attempting to join
+            // and/or obtaining Ip address
+            attemptAutoJoin = false;
+        }
+        if (DBG) {
+            loge("wifi setScanResults state" + getCurrentState()
+                    + " sup_state=" + state
+                    + " debouncing=" + linkDebouncing);
+        }
+        if (attemptAutoJoin) {
+            messageHandlingStatus = MESSAGE_HANDLING_STATUS_PROCESSED;
+        }
+        // Loose last selected configuration if we have been disconnected for 30 minutes
+        if (getDisconnectedTimeMilli() > 1000 * 60 * 30) {
+            mWifiConfigStore.setLastSelectedConfiguration(WifiConfiguration.INVALID_NETWORK_ID);
+        }
+
+        if (mWifiConfigStore.enableAutoJoinWhenAssociated) {
+            synchronized(mScanResultCache) {
+                // AutoJoincontroller will directly acces the scan result list and update it with
+                // ScanResult status
+                mNumScanResultsKnown = mWifiAutoJoinController.newSupplicantResults(attemptAutoJoin);
+            }
+        }
+        if (linkDebouncing) {
+            // If debouncing, we dont re-select a SSID or BSSID hence
+            // there is no need to call the network selection code
+            // in WifiAutoJoinController, instead,
+            // just try to reconnect to the same SSID by triggering a roam
+            sendMessage(CMD_AUTO_ROAM, mLastNetworkId, 1, null);
+        }
+    }
+
+    /*
+     * Fetch RSSI, linkspeed, and frequency on current connection
+     */
+    private void fetchRssiLinkSpeedAndFrequencyNative() {
+        int newRssi = -1;
+        int newLinkSpeed = -1;
+        int newFrequency = -1;
+
+        String signalPoll = mWifiNative.signalPoll();
+
+        if (signalPoll != null) {
+            String[] lines = signalPoll.split("\n");
+            for (String line : lines) {
+                String[] prop = line.split("=");
+                if (prop.length < 2) continue;
+                try {
+                    if (prop[0].equals("RSSI")) {
+                        newRssi = Integer.parseInt(prop[1]);
+                    } else if (prop[0].equals("LINKSPEED")) {
+                        newLinkSpeed = Integer.parseInt(prop[1]);
+                    } else if (prop[0].equals("FREQUENCY")) {
+                        newFrequency = Integer.parseInt(prop[1]);
+                    }
+                } catch (NumberFormatException e) {
+                    //Ignore, defaults on rssi and linkspeed are assigned
+                }
+            }
+        }
+
+        if (PDBG) {
+            loge("fetchRssiLinkSpeedAndFrequencyNative rssi="
+                    + Integer.toString(newRssi) + " linkspeed="
+                    + Integer.toString(newLinkSpeed));
+        }
+
+        if (newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
+        // screen out invalid values
+            /* some implementations avoid negative values by adding 256
+             * so we need to adjust for that here.
+             */
+            if (newRssi > 0) newRssi -= 256;
+            mWifiInfo.setRssi(newRssi);
+            /*
+             * Rather then sending the raw RSSI out every time it
+             * changes, we precalculate the signal level that would
+             * be displayed in the status bar, and only send the
+             * broadcast if that much more coarse-grained number
+             * changes. This cuts down greatly on the number of
+             * broadcasts, at the cost of not informing others
+             * interested in RSSI of all the changes in signal
+             * level.
+             */
+            int newSignalLevel = WifiManagerWAP.calculateSignalLevel(newRssi, WifiManagerWAP.RSSI_LEVELS);
+            if (newSignalLevel != mLastSignalLevel) {
+                sendRssiChangeBroadcast(newRssi);
+            }
+            mLastSignalLevel = newSignalLevel;
+        } else {
+            mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
+        }
+
+        if (newLinkSpeed != -1) {
+            mWifiInfo.setLinkSpeed(newLinkSpeed);
+        }
+        if (newFrequency > 0) {
+            if (ScanResult.is5GHz(newFrequency)) {
+                mWifiConnectionStatistics.num5GhzConnected++;
+            }
+            if (ScanResult.is24GHz(newFrequency)) {
+                mWifiConnectionStatistics.num24GhzConnected++;
+            }
+            mWifiInfo.setFrequency(newFrequency);
+        }
+        mWifiConfigStore.updateConfiguration(mWifiInfo);
+    }
+
+    /**
+     *  Determine if we need to switch network:
+     * - the delta determine the urgency to switch and/or or the expected evilness of the disruption
+     * - match the uregncy of the switch versus the packet usage at the interface
+     */
+    boolean shouldSwitchNetwork(int networkDelta) {
+        int delta;
+        if (networkDelta <= 0) {
+            return false;
+        }
+        delta = networkDelta;
+        if (mWifiInfo != null) {
+            if (!mWifiConfigStore.enableAutoJoinWhenAssociated
+                    && mWifiInfo.getNetworkId() != WifiConfiguration.INVALID_NETWORK_ID) {
+                // If AutoJoin while associated is not enabled,
+                // we should never switch network when already associated
+                delta = -1000;
+            } else {
+                // TODO: Look at per AC packet count, do not switch if VO/VI traffic is present
+                // TODO: at the interface. We should also discriminate between ucast and mcast,
+                // TODO: since the rxSuccessRate include all the bonjour and Ipv6
+                // TODO: broadcasts
+                if ((mWifiInfo.txSuccessRate > 20) || (mWifiInfo.rxSuccessRate > 80)) {
+                    delta -= 999;
+                } else if ((mWifiInfo.txSuccessRate > 5) || (mWifiInfo.rxSuccessRate > 30)) {
+                    delta -= 6;
+                }
+                loge("WifiStateMachineWAP shouldSwitchNetwork "
+                        + " txSuccessRate=" + String.format("%.2f", mWifiInfo.txSuccessRate)
+                        + " rxSuccessRate=" + String.format("%.2f", mWifiInfo.rxSuccessRate)
+                        + " delta " + networkDelta + " -> " + delta);
+            }
+        } else {
+            loge("WifiStateMachineWAP shouldSwitchNetwork "
+                    + " delta " + networkDelta + " -> " + delta);
+        }
+        if (delta > 0) {
+            return true;
+        }
+        return false;
+    }
+
+    // Polling has completed, hence we wont have a score anymore
+    private void cleanWifiScore() {
+        mWifiInfo.txBadRate = 0;
+        mWifiInfo.txSuccessRate = 0;
+        mWifiInfo.txRetriesRate = 0;
+        mWifiInfo.rxSuccessRate = 0;
+    }
+
+    int mBadLinkspeedcount = 0;
+
+    // For debug, provide information about the last scoring operation
+    String wifiScoringReport = null;
+    private void calculateWifiScore(WifiLinkLayerStats stats) {
+        StringBuilder sb = new StringBuilder();
+        if (stats == null || mWifiLinkLayerStatsSupported <= 0) {
+            long mTxPkts = TrafficStats.getTxPackets(mInterfaceName);
+            long mRxPkts = TrafficStats.getRxPackets(mInterfaceName);
+            mWifiInfo.updatePacketRates(mTxPkts, mRxPkts);
+        } else {
+            sb.append(" stats");
+            mWifiInfo.updatePacketRates(stats);
+        }
+        int score = 56; // Starting score, temporarily hardcoded in between 50 and 60
+        boolean isBadLinkspeed = (mWifiInfo.is24GHz()
+                && mWifiInfo.getLinkSpeed() < mWifiConfigStore.badLinkSpeed24)
+                || (mWifiInfo.is5GHz() && mWifiInfo.getLinkSpeed()
+                < mWifiConfigStore.badLinkSpeed5);
+        boolean isGoodLinkspeed = (mWifiInfo.is24GHz()
+                && mWifiInfo.getLinkSpeed() >= mWifiConfigStore.goodLinkSpeed24)
+                || (mWifiInfo.is5GHz() && mWifiInfo.getLinkSpeed()
+                >= mWifiConfigStore.goodLinkSpeed5);
+
+        if (isBadLinkspeed) {
+            if (mBadLinkspeedcount < 6)
+                mBadLinkspeedcount++;
+        } else {
+            if (mBadLinkspeedcount > 0)
+                mBadLinkspeedcount--;
+        }
+
+        if (isBadLinkspeed) sb.append(" bl(").append(mBadLinkspeedcount).append(")");
+        if (isGoodLinkspeed) sb.append(" gl");
+
+        /**
+         * We want to make sure that we use the 24GHz RSSI thresholds if
+         * there are 2.4GHz scan results
+         * otherwise we end up lowering the score based on 5GHz values
+         * which may cause a switch to LTE before roaming has a chance to try 2.4GHz
+         * We also might unblacklist the configuation based on 2.4GHz
+         * thresholds but joining 5GHz anyhow, and failing over to 2.4GHz because 5GHz is not good
+         */
+        boolean use24Thresholds = false;
+        boolean homeNetworkBoost = false;
+        WifiConfiguration currentConfiguration = getCurrentWifiConfiguration();
+        if (currentConfiguration != null
+                && currentConfiguration.scanResultCache != null) {
+            currentConfiguration.setVisibility(12000);
+            if (currentConfiguration.visibility != null) {
+                if (currentConfiguration.visibility.rssi24 != WifiConfiguration.INVALID_RSSI
+                        && currentConfiguration.visibility.rssi24
+                        >= (currentConfiguration.visibility.rssi5-2)) {
+                    use24Thresholds = true;
+                }
+            }
+            if (currentConfiguration.scanResultCache.size() <= 6
+                && currentConfiguration.allowedKeyManagement.cardinality() == 1
+                && currentConfiguration.allowedKeyManagement.
+                    get(WifiConfiguration.KeyMgmt.WPA_PSK) == true) {
+                // A PSK network with less than 6 known BSSIDs
+                // This is most likely a home network and thus we want to stick to wifi more
+                homeNetworkBoost = true;
+            }
+        }
+        if (homeNetworkBoost) sb.append(" hn");
+        if (use24Thresholds) sb.append(" u24");
+
+        int rssi = mWifiInfo.getRssi() - 6 * mAggressiveHandover
+                + (homeNetworkBoost ? WifiConfiguration.HOME_NETWORK_RSSI_BOOST : 0);
+        sb.append(String.format(" rssi=%d ag=%d", rssi, mAggressiveHandover));
+
+        boolean is24GHz = use24Thresholds || mWifiInfo.is24GHz();
+
+        boolean isBadRSSI = (is24GHz && rssi < mWifiConfigStore.thresholdBadRssi24)
+                || (!is24GHz && rssi < mWifiConfigStore.thresholdBadRssi5);
+        boolean isLowRSSI = (is24GHz && rssi < mWifiConfigStore.thresholdLowRssi24)
+                || (!is24GHz && mWifiInfo.getRssi() < mWifiConfigStore.thresholdLowRssi5);
+        boolean isHighRSSI = (is24GHz && rssi >= mWifiConfigStore.thresholdGoodRssi24)
+                || (!is24GHz && mWifiInfo.getRssi() >= mWifiConfigStore.thresholdGoodRssi5);
+
+        if (isBadRSSI) sb.append(" br");
+        if (isLowRSSI) sb.append(" lr");
+        if (isHighRSSI) sb.append(" hr");
+
+        int penalizedDueToUserTriggeredDisconnect = 0;        // For debug information
+        if (currentConfiguration!= null &&
+                (mWifiInfo.txSuccessRate > 5 || mWifiInfo.rxSuccessRate > 5)) {
+            if (isBadRSSI) {
+                currentConfiguration.numTicksAtBadRSSI++;
+                if (currentConfiguration.numTicksAtBadRSSI > 1000) {
+                    // We remained associated for a compound amount of time while passing
+                    // traffic, hence loose the corresponding user triggered disabled stats
+                    if (currentConfiguration.numUserTriggeredWifiDisableBadRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableBadRSSI--;
+                    }
+                    if (currentConfiguration.numUserTriggeredWifiDisableLowRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableLowRSSI--;
+                    }
+                    if (currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI--;
+                    }
+                    currentConfiguration.numTicksAtBadRSSI = 0;
+                }
+                if (mWifiConfigStore.enableWifiCellularHandoverUserTriggeredAdjustment &&
+                        (currentConfiguration.numUserTriggeredWifiDisableBadRSSI > 0
+                        || currentConfiguration.numUserTriggeredWifiDisableLowRSSI > 0
+                        || currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0)) {
+                    score = score -5;
+                    penalizedDueToUserTriggeredDisconnect = 1;
+                    sb.append(" p1");
+                }
+            } else if (isLowRSSI) {
+                currentConfiguration.numTicksAtLowRSSI++;
+                if (currentConfiguration.numTicksAtLowRSSI > 1000) {
+                    // We remained associated for a compound amount of time while passing
+                    // traffic, hence loose the corresponding user triggered disabled stats
+                    if (currentConfiguration.numUserTriggeredWifiDisableLowRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableLowRSSI--;
+                    }
+                    if (currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI--;
+                    }
+                    currentConfiguration.numTicksAtLowRSSI = 0;
+                }
+                if (mWifiConfigStore.enableWifiCellularHandoverUserTriggeredAdjustment &&
+                        (currentConfiguration.numUserTriggeredWifiDisableLowRSSI > 0
+                        || currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0)) {
+                    score = score -5;
+                    penalizedDueToUserTriggeredDisconnect = 2;
+                    sb.append(" p2");
+                }
+            } else if (!isHighRSSI) {
+                currentConfiguration.numTicksAtNotHighRSSI++;
+                if (currentConfiguration.numTicksAtNotHighRSSI > 1000) {
+                    // We remained associated for a compound amount of time while passing
+                    // traffic, hence loose the corresponding user triggered disabled stats
+                    if (currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0) {
+                        currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI--;
+                    }
+                    currentConfiguration.numTicksAtNotHighRSSI = 0;
+                }
+                if (mWifiConfigStore.enableWifiCellularHandoverUserTriggeredAdjustment &&
+                        currentConfiguration.numUserTriggeredWifiDisableNotHighRSSI > 0) {
+                    score = score -5;
+                    penalizedDueToUserTriggeredDisconnect = 3;
+                    sb.append(" p3");
+                }
+            }
+            sb.append(String.format(" ticks %d,%d,%d", currentConfiguration.numTicksAtBadRSSI,
+                    currentConfiguration.numTicksAtLowRSSI,
+                    currentConfiguration.numTicksAtNotHighRSSI));
+        }
+
+        if (PDBG) {
+            String rssiStatus = "";
+            if (isBadRSSI) rssiStatus += " badRSSI ";
+            else if (isHighRSSI) rssiStatus += " highRSSI ";
+            else if (isLowRSSI) rssiStatus += " lowRSSI ";
+            if (isBadLinkspeed) rssiStatus += " lowSpeed ";
+            loge("calculateWifiScore freq=" + Integer.toString(mWifiInfo.getFrequency())
+                            + " speed=" + Integer.toString(mWifiInfo.getLinkSpeed())
+                            + " score=" + Integer.toString(mWifiInfo.score)
+                            + rssiStatus
+                            + " -> txbadrate=" + String.format( "%.2f", mWifiInfo.txBadRate )
+                            + " txgoodrate=" + String.format("%.2f", mWifiInfo.txSuccessRate)
+                            + " txretriesrate=" + String.format("%.2f", mWifiInfo.txRetriesRate)
+                            + " rxrate=" + String.format("%.2f", mWifiInfo.rxSuccessRate)
+                            + " userTriggerdPenalty" + penalizedDueToUserTriggeredDisconnect);
+        }
+
+        if ((mWifiInfo.txBadRate >= 1) && (mWifiInfo.txSuccessRate < 3)
+                && (isBadRSSI || isLowRSSI)) {
+            // Link is stuck
+            if (mWifiInfo.linkStuckCount < 5)
+                mWifiInfo.linkStuckCount += 1;
+            sb.append(String.format(" ls+=%d", mWifiInfo.linkStuckCount));
+            if (PDBG) loge(" bad link -> stuck count ="
+                    + Integer.toString(mWifiInfo.linkStuckCount));
+        } else if (mWifiInfo.txSuccessRate > 2 || mWifiInfo.txBadRate < 0.1) {
+            if (mWifiInfo.linkStuckCount > 0)
+                mWifiInfo.linkStuckCount -= 1;
+            sb.append(String.format(" ls-=%d", mWifiInfo.linkStuckCount));
+            if (PDBG) loge(" good link -> stuck count ="
+                    + Integer.toString(mWifiInfo.linkStuckCount));
+        }
+
+        sb.append(String.format(" [%d", score));
+
+        if (mWifiInfo.linkStuckCount > 1) {
+            // Once link gets stuck for more than 3 seconds, start reducing the score
+            score = score - 2 * (mWifiInfo.linkStuckCount - 1);
+        }
+        sb.append(String.format(",%d", score));
+
+        if (isBadLinkspeed) {
+            score -= 4 ;
+            if (PDBG) {
+                loge(" isBadLinkspeed   ---> count=" + mBadLinkspeedcount
+                        + " score=" + Integer.toString(score));
+            }
+        } else if ((isGoodLinkspeed) && (mWifiInfo.txSuccessRate > 5)) {
+            score += 4; // So as bad rssi alone dont kill us
+        }
+        sb.append(String.format(",%d", score));
+
+        if (isBadRSSI) {
+            if (mWifiInfo.badRssiCount < 7)
+                mWifiInfo.badRssiCount += 1;
+        } else if (isLowRSSI) {
+            mWifiInfo.lowRssiCount = 1; // Dont increment the lowRssi count above 1
+            if (mWifiInfo.badRssiCount > 0) {
+                // Decrement bad Rssi count
+                mWifiInfo.badRssiCount -= 1;
+            }
+        } else {
+            mWifiInfo.badRssiCount = 0;
+            mWifiInfo.lowRssiCount = 0;
+        }
+
+        score -= mWifiInfo.badRssiCount * 2 +  mWifiInfo.lowRssiCount ;
+        sb.append(String.format(",%d", score));
+
+        if (PDBG) loge(" badRSSI count" + Integer.toString(mWifiInfo.badRssiCount)
+                     + " lowRSSI count" + Integer.toString(mWifiInfo.lowRssiCount)
+                        + " --> score " + Integer.toString(score));
+
+
+        if (isHighRSSI) {
+            score += 5;
+            if (PDBG) loge(" isHighRSSI       ---> score=" + Integer.toString(score));
+        }
+        sb.append(String.format(",%d]", score));
+
+        sb.append(String.format(" brc=%d lrc=%d", mWifiInfo.badRssiCount, mWifiInfo.lowRssiCount));
+
+        //sanitize boundaries
+        if (score > NetworkAgent.WIFI_BASE_SCORE)
+            score = NetworkAgent.WIFI_BASE_SCORE;
+        if (score < 0)
+            score = 0;
+
+        //report score
+        if (score != mWifiInfo.score) {
+            if (DBG) {
+                loge("calculateWifiScore() report new score " + Integer.toString(score));
+            }
+            if (!isPropFeatureEnabled) {
+                mWifiInfo.score = score;
+                if(mNetworkAgent != null) {
+                    mNetworkAgent.sendNetworkScore(score);
+                }
+            }
+        }
+        wifiScoringReport = sb.toString();
+    }
+
+    public double getTxPacketRate() {
+        if (mWifiInfo != null) {
+            return mWifiInfo.txSuccessRate;
+        }
+        return -1;
+    }
+
+    public double getRxPacketRate() {
+        if (mWifiInfo != null) {
+            return mWifiInfo.rxSuccessRate;
+        }
+        return -1;
+    }
+
+    /**
+     * Fetch TX packet counters on current connection
+     */
+    private void fetchPktcntNative(RssiPacketCountInfo info) {
+        String pktcntPoll = mWifiNative.pktcntPoll();
+
+        if (pktcntPoll != null) {
+            String[] lines = pktcntPoll.split("\n");
+            for (String line : lines) {
+                String[] prop = line.split("=");
+                if (prop.length < 2) continue;
+                try {
+                    if (prop[0].equals("TXGOOD")) {
+                        info.txgood = Integer.parseInt(prop[1]);
+                    } else if (prop[0].equals("TXBAD")) {
+                        info.txbad = Integer.parseInt(prop[1]);
+                    }
+                } catch (NumberFormatException e) {
+                    // Ignore
+                }
+            }
+        }
+    }
+
+    private boolean clearIPv4Address(String iface) {
+        try {
+            InterfaceConfiguration ifcg = new InterfaceConfiguration();
+            ifcg.setLinkAddress(new LinkAddress("0.0.0.0/0"));
+            mNwService.setInterfaceConfig(iface, ifcg);
+            return true;
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+
+    private boolean isProvisioned(LinkProperties lp) {
+        // LinkProperties#isProvisioned returns true even if all we have is an IPv4 address and no
+        // connectivity. This turns out not to be very useful, because we can't distinguish it from
+        // a state where we have an IPv4 address assigned to the interface but are still running
+        // DHCP.
+        // TODO: Fix LinkProperties and remove this function.
+        if (mWifiConfigStore.isUsingStaticIp(mLastNetworkId)) {
+            return lp.hasIPv4Address();
+        } else {
+            return (lp.hasIPv4Address() && lp.hasIPv4DefaultRoute() && lp.hasIPv4DnsServer()) ||
+                   (lp.hasGlobalIPv6Address() && lp.hasIPv6DefaultRoute() && lp.hasIPv6DnsServer());
+        }
+    }
+
+    /**
+     * Updates mLinkProperties by merging information from various sources.
+     *
+     * This is needed because the information in mLinkProperties comes from multiple sources (DHCP,
+     * netlink, static configuration, ...). When one of these sources of information has updated
+     * link properties, we can't just assign them to mLinkProperties or we'd lose track of the
+     * information that came from other sources. Instead, when one of those sources has new
+     * information, we update the object that tracks the information from that source and then
+     * call this method to apply the change to mLinkProperties.
+     *
+     * The information in mLinkProperties is currently obtained as follows:
+     * - Interface name: set in the constructor.
+     * - IPv4 and IPv6 addresses: netlink, passed in by mNetlinkTracker.
+     * - IPv4 routes, DNS servers, and domains: DHCP.
+     * - IPv6 routes and DNS servers: netlink, passed in by mNetlinkTracker.
+     * - HTTP proxy: the wifi config store.
+     */
+    private void updateLinkProperties(int reason, LinkProperties lp) {
+        LinkProperties newLp = new LinkProperties();
+
+        // Interface name and proxy are locally configured.
+        newLp.setInterfaceName(mInterfaceName);
+        newLp.setHttpProxy(mWifiConfigStore.getProxyProperties(mLastNetworkId));
+
+        // IPv4/v6 addresses, IPv6 routes and IPv6 DNS servers come from netlink.
+        newLp.setLinkAddresses(lp.getLinkAddresses());
+        for (RouteInfo route : lp.getRoutes()) {
+            newLp.addRoute(route);
+        }
+        for (InetAddress dns : lp.getDnsServers()) {
+            newLp.addDnsServer(dns);
+        }
+
+        // IPv4 routes, DNS servers and domains come from mDhcpResults.
+        synchronized (mDhcpResultsLock) {
+            // Even when we're using static configuration, we don't need to look at the config
+            // store, because static IP configuration also populates mDhcpResults.
+            if ((mDhcpResults != null) && lp.hasIPv4Address()) {
+                for (RouteInfo route : mDhcpResults.getRoutes(mInterfaceName)) {
+                    newLp.addRoute(route);
+                }
+                for (InetAddress dns : mDhcpResults.dnsServers) {
+                    newLp.addDnsServer(dns);
+                }
+                newLp.setDomains(mDhcpResults.domains);
+            }
+        }
+
+        final boolean linkChanged = !newLp.equals(mLinkProperties);
+        final boolean wasProvisioned = isProvisioned(mLinkProperties);
+        final boolean isProvisioned = isProvisioned(newLp);
+        final DetailedState detailedState = getNetworkDetailedState();
+
+        if (linkChanged) {
+            if (DBG) {
+                log("Link configuration changed for netId: " + mLastNetworkId
+                        + " old: " + mLinkProperties + " new: " + newLp);
+            }
+            mLinkProperties = newLp;
+            if (TextUtils.isEmpty(mTcpBufferSizes) == false) {
+                mLinkProperties.setTcpBufferSizes(mTcpBufferSizes);
+            }
+            if (mNetworkAgent != null) mNetworkAgent.sendLinkProperties(mLinkProperties);
+        }
+
+        if (DBG) {
+            StringBuilder sb = new StringBuilder();
+            sb.append("updateLinkProperties nid: " + mLastNetworkId);
+            sb.append(" state: " + detailedState);
+            sb.append(" reason: " + smToString(reason));
+
+            if (mLinkProperties != null) {
+                if (mLinkProperties.hasIPv4Address()) {
+                    sb.append(" v4");
+                }
+                if (mLinkProperties.hasGlobalIPv6Address()) {
+                    sb.append(" v6");
+                }
+                if (mLinkProperties.hasIPv4DefaultRoute()) {
+                    sb.append(" v4r");
+                }
+                if (mLinkProperties.hasIPv6DefaultRoute()) {
+                    sb.append(" v6r");
+                }
+                if (mLinkProperties.hasIPv4DnsServer()) {
+                    sb.append(" v4dns");
+                }
+                if (mLinkProperties.hasIPv6DnsServer()) {
+                    sb.append(" v6dns");
+                }
+                if (isProvisioned) {
+                    sb.append(" isprov");
+                }
+            }
+            loge(sb.toString());
+        }
+
+        // If we just configured or lost IP configuration, do the needful.
+        // We don't just call handleSuccessfulIpConfiguration() or handleIpConfigurationLost()
+        // here because those should only be called if we're attempting to connect or already
+        // connected, whereas updateLinkProperties can be called at any time.
+        switch (reason) {
+            case DhcpStateMachine.DHCP_SUCCESS:
+            case CMD_STATIC_IP_SUCCESS:
+                // IPv4 provisioning succeded. Advance to connected state.
+                sendMessage(CMD_IP_CONFIGURATION_SUCCESSFUL);
+                if (!isProvisioned) {
+                    // Can never happen unless DHCP reports success but isProvisioned thinks the
+                    // resulting configuration is invalid (e.g., no IPv4 address, or the state in
+                    // mLinkProperties is out of sync with reality, or there's a bug in this code).
+                    // TODO: disconnect here instead. If our configuration is not usable, there's no
+                    // point in staying connected, and if mLinkProperties is out of sync with
+                    // reality, that will cause problems in the future.
+                    loge("IPv4 config succeeded, but not provisioned");
+                }
+                break;
+
+            case DhcpStateMachine.DHCP_FAILURE:
+                // DHCP failed. If we're not already provisioned, give up and disconnect.
+                // If we're already provisioned (e.g., IPv6-only network), stay connected.
+                if (!isProvisioned) {
+                    sendMessage(CMD_IP_CONFIGURATION_LOST);
+                } else {
+                    // DHCP failed, but we're provisioned (e.g., if we're on an IPv6-only network).
+                    sendMessage(CMD_IP_CONFIGURATION_SUCCESSFUL);
+
+                    // To be sure we don't get stuck with a non-working network if all we had is
+                    // IPv4, remove the IPv4 address from the interface (since we're using DHCP,
+                    // and DHCP failed). If we had an IPv4 address before, the deletion of the
+                    // address  will cause a CMD_UPDATE_LINKPROPERTIES. If the IPv4 address was
+                    // necessary for provisioning, its deletion will cause us to disconnect.
+                    //
+                    // This shouldn't be needed, because on an IPv4-only network a DHCP failure will
+                    // have empty DhcpResults and thus empty LinkProperties, and isProvisioned will
+                    // not return true if we're using DHCP and don't have an IPv4 default route. So
+                    // for now it's only here for extra redundancy. However, it will increase
+                    // robustness if we move to getting IPv4 routes from netlink as well.
+                    loge("DHCP failure: provisioned, clearing IPv4 address.");
+                    if (!clearIPv4Address(mInterfaceName)) {
+                        sendMessage(CMD_IP_CONFIGURATION_LOST);
+                    }
+                }
+                break;
+
+            case CMD_STATIC_IP_FAILURE:
+                // Static configuration was invalid, or an error occurred in applying it. Give up.
+                sendMessage(CMD_IP_CONFIGURATION_LOST);
+                break;
+
+            case CMD_UPDATE_LINKPROPERTIES:
+                // IP addresses, DNS servers, etc. changed. Act accordingly.
+                boolean isStatic = mWifiConfigStore.isUsingStaticIp(mLastNetworkId);
+                if (wasProvisioned && !isProvisioned && !isStatic) {
+                    // We no longer have a usable network configuration. Disconnect.
+                    sendMessage(CMD_IP_CONFIGURATION_LOST);
+                } else if (!wasProvisioned && isProvisioned) {
+                    // We have a usable IPv6-only config. Advance to connected state.
+                    sendMessage(CMD_IP_CONFIGURATION_SUCCESSFUL);
+                }
+                if (linkChanged && getNetworkDetailedState() == DetailedState.CONNECTED) {
+                    // If anything has changed and we're already connected, send out a notification.
+                    sendLinkConfigurationChangedBroadcast();
+                }
+                break;
+        }
+    }
+
+    /**
+     * Clears all our link properties.
+     */
+     private void clearLinkProperties() {
+         // Clear the link properties obtained from DHCP and netlink.
+         synchronized (mDhcpResultsLock) {
+             if (mDhcpResults != null) {
+                 mDhcpResults.clear();
+             }
+         }
+         mNetlinkTracker.clearLinkProperties();
+
+         // Now clear the merged link properties.
+         mLinkProperties.clear();
+         if (mNetworkAgent != null) mNetworkAgent.sendLinkProperties(mLinkProperties);
+     }
+
+     /**
+      * try to update default route MAC address.
+      */
+      private String updateDefaultRouteMacAddress(int timeout) {
+          String address = null;
+          for (RouteInfo route : mLinkProperties.getRoutes()) {
+              if (route.isDefaultRoute() && route.hasGateway()) {
+                  InetAddress gateway = route.getGateway();
+                  if (gateway instanceof Inet4Address) {
+                      if (PDBG) {
+                          loge("updateDefaultRouteMacAddress found Ipv4 default :"
+                                  + gateway.getHostAddress());
+                      }
+                      address = macAddressFromRoute(gateway.getHostAddress());
+                     /* The gateway's MAC address is known */
+                      if ((address == null) && (timeout > 0)) {
+                          boolean reachable = false;
+                          try {
+                              reachable = gateway.isReachable(timeout);
+                          } catch (Exception e) {
+                              loge("updateDefaultRouteMacAddress exception reaching :"
+                                      + gateway.getHostAddress());
+
+                          } finally {
+                              if (reachable == true) {
+
+                                  address = macAddressFromRoute(gateway.getHostAddress());
+                                  if (PDBG) {
+                                      loge("updateDefaultRouteMacAddress reachable (tried again) :"
+                                              + gateway.getHostAddress() + " found " + address);
+                                  }
+                              }
+                          }
+                      }
+                      if (address != null) {
+                          mWifiConfigStore.setDefaultGwMacAddress(mLastNetworkId, address);
+                      }
+                  }
+              }
+          }
+          return address;
+      }
+
+    private void sendScanResultsAvailableBroadcast() {
+        Intent intent = new Intent(WifiManagerWAP.SCAN_RESULTS_AVAILABLE_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendRssiChangeBroadcast(final int newRssi) {
+        try {
+            mBatteryStats.noteWifiRssiChanged(newRssi);
+        } catch (RemoteException e) {
+            // Won't happen.
+        }
+        Intent intent = new Intent(WifiManagerWAP.RSSI_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_NEW_RSSI, newRssi);
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendNetworkStateChangeBroadcast(String bssid) {
+        Intent intent = new Intent(WifiManagerWAP.NETWORK_STATE_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_NETWORK_INFO, new NetworkInfo(mNetworkInfo));
+        intent.putExtra(WifiManagerWAP.EXTRA_LINK_PROPERTIES, new LinkProperties (mLinkProperties));
+        if (bssid != null)
+            intent.putExtra(WifiManagerWAP.EXTRA_BSSID, bssid);
+        if (mNetworkInfo.getDetailedState() == DetailedState.VERIFYING_POOR_LINK ||
+                mNetworkInfo.getDetailedState() == DetailedState.CONNECTED) {
+            intent.putExtra(WifiManagerWAP.EXTRA_WIFI_INFO, new WifiInfo(mWifiInfo));
+        }
+        mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendLinkConfigurationChangedBroadcast() {
+        Intent intent = new Intent(WifiManagerWAP.LINK_CONFIGURATION_CHANGED_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_LINK_PROPERTIES, new LinkProperties(mLinkProperties));
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    private void sendSupplicantConnectionChangedBroadcast(boolean connected) {
+        Intent intent = new Intent(WifiManagerWAP.SUPPLICANT_CONNECTION_CHANGE_ACTION);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        intent.putExtra(WifiManagerWAP.EXTRA_SUPPLICANT_CONNECTED, connected);
+        mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+    }
+
+    /**
+     * Record the detailed state of a network.
+     * @param state the new {@code DetailedState}
+     */
+    private boolean setNetworkDetailedState(NetworkInfo.DetailedState state) {
+        boolean hidden = false;
+
+        if (linkDebouncing || isRoaming()) {
+            // There is generally a confusion in the system about colluding
+            // WiFi Layer 2 state (as reported by supplicant) and the Network state
+            // which leads to multiple confusion.
+            //
+            // If link is de-bouncing or roaming, we already have an IP address
+            // as well we were connected and are doing L2 cycles of
+            // reconnecting or renewing IP address to check that we still have it
+            // This L2 link flapping should ne be reflected into the Network state
+            // which is the state of the WiFi Network visible to Layer 3 and applications
+            // Note that once debouncing and roaming are completed, we will
+            // set the Network state to where it should be, or leave it as unchanged
+            //
+            hidden = true;
+        }
+        if (DBG) {
+            log("setDetailed state, old ="
+                    + mNetworkInfo.getDetailedState() + " and new state=" + state
+                    + " hidden=" + hidden);
+        }
+        if (mNetworkInfo.getExtraInfo() != null && mWifiInfo.getSSID() != null) {
+            // Always indicate that SSID has changed
+            if (!mNetworkInfo.getExtraInfo().equals(mWifiInfo.getSSID())) {
+                if (DBG) {
+                    log("setDetailed state send new extra info"  + mWifiInfo.getSSID());
+                }
+                mNetworkInfo.setExtraInfo(mWifiInfo.getSSID());
+                sendNetworkStateChangeBroadcast(null);
+            }
+        }
+        if (hidden == true) {
+            return false;
+        }
+
+        if (state != mNetworkInfo.getDetailedState()) {
+            mNetworkInfo.setDetailedState(state, null, mWifiInfo.getSSID());
+            if (mNetworkAgent != null) {
+                mNetworkAgent.sendNetworkInfo(mNetworkInfo);
+            }
+            sendNetworkStateChangeBroadcast(null);
+            return true;
+        }
+        return false;
+    }
+
+    private DetailedState getNetworkDetailedState() {
+        return mNetworkInfo.getDetailedState();
+    }
+
+
+    private SupplicantState handleSupplicantStateChange(Message message) {
+        StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+        SupplicantState state = stateChangeResult.state;
+        // Supplicant state change
+        // [31-13] Reserved for future use
+        // [8 - 0] Supplicant state (as defined in SupplicantState.java)
+        // 50023 supplicant_state_changed (custom|1|5)
+        mWifiInfo.setSupplicantState(state);
+        // Network id is only valid when we start connecting
+        if (SupplicantState.isConnecting(state)) {
+            mWifiInfo.setNetworkId(stateChangeResult.networkId);
+        } else {
+            mWifiInfo.setNetworkId(WifiConfiguration.INVALID_NETWORK_ID);
+        }
+
+        mWifiInfo.setBSSID(stateChangeResult.BSSID);
+        mWifiInfo.setSSID(stateChangeResult.wifiSsid);
+
+        mSupplicantStateTracker.sendMessage(Message.obtain(message));
+
+        return state;
+    }
+
+    /**
+     * Resets the Wi-Fi Connections by clearing any state, resetting any sockets
+     * using the interface, stopping DHCP & disabling interface
+     */
+    private void handleNetworkDisconnect() {
+        if (DBG) log("handleNetworkDisconnect: Stopping DHCP and clearing IP"
+                + " stack:" + Thread.currentThread().getStackTrace()[2].getMethodName()
+                +" - "+ Thread.currentThread().getStackTrace()[3].getMethodName()
+                +" - "+ Thread.currentThread().getStackTrace()[4].getMethodName()
+                +" - "+ Thread.currentThread().getStackTrace()[5].getMethodName());
+
+
+        clearCurrentConfigBSSID("handleNetworkDisconnect");
+
+        stopDhcp();
+
+        try {
+            mNwService.clearInterfaceAddresses(mInterfaceName);
+            mNwService.disableIpv6(mInterfaceName);
+        } catch (Exception e) {
+            loge("Failed to clear addresses or disable ipv6" + e);
+        }
+
+        /* Reset data structures */
+        mBadLinkspeedcount = 0;
+        mWifiInfo.reset();
+        linkDebouncing = false;
+        /* Reset roaming parameters */
+        mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+        fullBandConnectedTimeIntervalMilli = 20 * 1000; // Start scans at 20 seconds interval
+
+        setNetworkDetailedState(DetailedState.DISCONNECTED);
+        if (mNetworkAgent != null) {
+            mNetworkAgent.sendNetworkInfo(mNetworkInfo);
+            mNetworkAgent = null;
+        }
+        mWifiConfigStore.updateStatus(mLastNetworkId, DetailedState.DISCONNECTED);
+
+        /* Clear network properties */
+        clearLinkProperties();
+
+        /* Cend event to CM & network change broadcast */
+        sendNetworkStateChangeBroadcast(mLastBssid);
+
+        /* Cancel auto roam requests */
+        autoRoamSetBSSID(mLastNetworkId, "any");
+
+        mLastBssid= null;
+        registerDisconnected();
+        mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
+    }
+
+    private void handleSupplicantConnectionLoss(boolean killSupplicant) {
+        /* Socket connection can be lost when we do a graceful shutdown
+        * or when the driver is hung. Ensure supplicant is stopped here.
+        */
+        if (killSupplicant) {
+            mWifiMonitor.killSupplicant(mP2pSupported);
+        }
+        mWifiNative.closeSupplicantConnection();
+        sendSupplicantConnectionChangedBroadcast(false);
+        setWifiState(WIFI_STATE_DISABLED);
+    }
+
+    void handlePreDhcpSetup() {
+        mDhcpActive = true;
+
+        // Disable power save and suspend optimizations during DHCP
+        // Note: The order here is important for now. Brcm driver changes
+        // power settings when we control suspend mode optimizations.
+        // TODO: Remove this comment when the driver is fixed.
+        setSuspendOptimizationsNative(SUSPEND_DUE_TO_DHCP, false);
+        mWifiNative.setPowerSave(false);
+
+        mWifiNative.setBluetoothCoexistenceMode(
+                 mWifiNative.BLUETOOTH_COEXISTENCE_MODE_DISABLED);
+
+        stopBatchedScan();
+        WifiNative.pauseScan();
+
+        /* P2p discovery breaks dhcp, shut it down in order to get through this */
+        Message msg = new Message();
+        msg.what = WifiP2pServiceImpl.BLOCK_DISCOVERY;
+        msg.arg1 = WifiP2pServiceImpl.ENABLED;
+        msg.arg2 = DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE;
+        msg.obj = mDhcpStateMachine;
+        mWifiP2pChannel.sendMessage(msg);
+    }
+
+
+    void startDhcp() {
+        if (mDhcpStateMachine == null) {
+            mDhcpStateMachine = DhcpStateMachine.makeDhcpStateMachine(
+                    mContext, WifiStateMachineWAP.this, mInterfaceName);
+
+        }
+        mDhcpStateMachine.registerForPreDhcpNotification();
+        mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_START_DHCP);
+    }
+
+    void renewDhcp() {
+        if (mDhcpStateMachine == null) {
+            mDhcpStateMachine = DhcpStateMachine.makeDhcpStateMachine(
+                    mContext, WifiStateMachineWAP.this, mInterfaceName);
+
+        }
+        mDhcpStateMachine.registerForPreDhcpNotification();
+        mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_RENEW_DHCP);
+    }
+
+    void stopDhcp() {
+        if (mDhcpStateMachine != null) {
+            /* In case we were in middle of DHCP operation restore back powermode */
+            handlePostDhcpSetup();
+            mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_STOP_DHCP);
+        }
+    }
+
+    void handlePostDhcpSetup() {
+        mWifiP2pChannel.sendMessage(WifiP2pServiceImpl.BLOCK_DISCOVERY, WifiP2pServiceImpl.DISABLED);
+
+        // Set the coexistence mode back to its default value
+        mWifiNative.setBluetoothCoexistenceMode(
+                mWifiNative.BLUETOOTH_COEXISTENCE_MODE_SENSE);
+
+        /* Restore power save and suspend optimizations */
+        setSuspendOptimizationsNative(SUSPEND_DUE_TO_DHCP, true);
+        mWifiNative.setPowerSave(true);
+
+        mDhcpActive = false;
+
+        startBatchedScan();
+        WifiNative.restartScan();
+    }
+
+    private void handleIPv4Success(DhcpResults dhcpResults, int reason) {
+
+        if (PDBG) {
+            loge("wifistatemachine handleIPv4Success <" + dhcpResults.toString() + ">");
+            loge("link address " + dhcpResults.ipAddress);
+        }
+
+        synchronized (mDhcpResultsLock) {
+            mDhcpResults = dhcpResults;
+        }
+
+        Inet4Address addr = (Inet4Address) dhcpResults.ipAddress.getAddress();
+        if (isRoaming()) {
+            if (addr instanceof Inet4Address) {
+                int previousAddress = mWifiInfo.getIpAddress();
+                int newAddress = NetworkUtils.inetAddressToInt(addr);
+                if (previousAddress != newAddress) {
+                    loge("handleIPv4Success, roaming and address changed" +
+                            mWifiInfo + " got: " + addr);
+                } else {
+
+                }
+            } else {
+                loge("handleIPv4Success, roaming and didnt get an IPv4 address" +
+                        addr.toString());
+            }
+        }
+        mWifiInfo.setInetAddress(addr);
+        mWifiInfo.setMeteredHint(dhcpResults.hasMeteredHint());
+        updateLinkProperties(reason, mNetlinkTracker.getLinkProperties());
+    }
+
+    private void handleSuccessfulIpConfiguration() {
+        mLastSignalLevel = -1; // Force update of signal strength
+        WifiConfiguration c = getCurrentWifiConfiguration();
+        // Reset IP failure tracking
+        if (c != null) {
+            c.numConnectionFailures = 0;
+        }
+        if (c != null) {
+            ScanResult result = getCurrentScanResult();
+            if (result == null) {
+                loge("WifiStateMachineWAP: handleSuccessfulIpConfiguration and no scan results" +
+                        c.configKey());
+            } else {
+                // Clear the per BSSID failure count
+                result.numIpConfigFailures = 0;
+                // Clear the WHOLE BSSID blacklist, which means supplicant is free to retry
+                // any BSSID, even though it may already have a non zero ip failure count,
+                // this will typically happen if the user walks away and come back to his arrea
+                // TODO: implement blacklisting based on a timer, i.e. keep BSSID blacklisted
+                // in supplicant for a couple of hours or a day
+                mWifiNative.clearBlacklist();
+            }
+        }
+    }
+
+    private void handleIPv4Failure(int reason) {
+        synchronized(mDhcpResultsLock) {
+             if (mDhcpResults != null) {
+                 mDhcpResults.clear();
+             }
+        }
+        if (PDBG) {
+            loge("wifistatemachine handleIPv4Failure");
+        }
+        updateLinkProperties(reason, mNetlinkTracker.getLinkProperties());
+    }
+
+    private void handleIpConfigurationLost() {
+        mWifiInfo.setInetAddress(null);
+        mWifiInfo.setMeteredHint(false);
+
+        mWifiConfigStore.handleSSIDStateChange(mLastNetworkId, false,
+                "DHCP FAILURE", mWifiInfo.getBSSID());
+
+        /* DHCP times out after about 30 seconds, we do a
+         * disconnect thru supplicant, we will let autojoin retry connecting to the network
+         */
+        mWifiNative.disconnect();
+    }
+
+    private int wifiFreq2ChanIndex(int freq) {
+        int chan = 1;
+        for(int i = 0; i < 11; i++) {
+            if(freq == (2412 + i*5)) {
+                chan = i + 1;
+                return chan;    
+            }
+        }
+        return 0;
+    }
+    
+    private int chooseApChan() {
+        List<ScanResult> scanResults = mWifiManager.getScanResults();
+        int maxLevel = -120;
+        int minChanCount = 20;
+        int maxSigChan = 0;
+        int chooseChan = 0;
+        int chan = 0;
+        int cleanChan = 0;
+        int chanDiff = 0;
+        String maxSigSSID = "";
+        int[] chanCount = new int[11];
+        for (ScanResult scanResult : scanResults) {
+            if (scanResult == null) {
+                continue;
+            }
+            chan = wifiFreq2ChanIndex(scanResult.frequency);
+            loge("qcomsoftap: ssid: " + scanResult.SSID + " " + "freq: " + Integer.toString(scanResult.frequency) + " " + "channel: " + Integer.toString(chan) + " " + "level: " + Integer.toString(scanResult.level));
+            if(chan != 0) {
+                chanCount[chan - 1]++;
+                if(scanResult.level > maxLevel) {
+                    maxSigChan = chan;
+                    maxSigSSID = scanResult.SSID;
+                    maxLevel = scanResult.level;
+                }
+            }
+        }
+        for(int i = 0; i < 11; i++) {
+            if(chanCount[i] < minChanCount) {
+                minChanCount = chanCount[i];
+                cleanChan = i + 1;
+            }
+        }
+        loge("qcomsoftap: max signal SSID: " + maxSigSSID + " ," + "channel: " + Integer.toString(maxSigChan) + " ,signal level: " + Integer.toString(maxLevel));
+        loge("qcomsoftap: cleanest channel: " + Integer.toString(cleanChan) + " ,ap number: " + Integer.toString(minChanCount));
+        chanDiff = (cleanChan > maxSigChan) ? (cleanChan - maxSigChan) : (maxSigChan - cleanChan);
+        if(chanDiff > 5) {
+            chooseChan = cleanChan;
+        }
+        else if(maxSigChan >= 6){
+            chooseChan = 1;
+        }
+        else {
+            chooseChan = 11;
+        }
+        loge("qcomsoftap: choose channel " + Integer.toString(chooseChan) + " for soft ap");
+        return chooseChan;
+    }
+
+    /* Current design is to not set the config on a running hostapd but instead
+     * stop and start tethering when user changes config on a running access point
+     *
+     * TODO: Add control channel setup through hostapd that allows changing config
+     * on a running daemon
+     */
+    private void startSoftApWithConfig(final WifiConfiguration config) {
+        // Start hostapd on a separate thread
+        new Thread(new Runnable() {
+            public void run() {
+                try {
+                    WifiServiceImplWAP apImpl;
+                    apImpl = (WifiServiceImplWAP)ServiceManager.getService(Context.WAP_SERVICE);
+                    if(apImpl.is1stTimeChooseChan()) {
+                        config.apchannel = chooseApChan();
+                        apImpl.clear1stTimeChooseChan();
+                    }
+                    mNwService.startAccessPoint(config, mInterfaceName);
+                    if(mWifiManager.isEthUp()) {
+                        mWifiManager.setWifiEnabled(false);
+                    }
+                } catch (Exception e) {
+                    loge("Exception in softap start " + e);
+                    try {
+                        mNwService.stopAccessPoint(mInterfaceName);
+                        mNwService.startAccessPoint(config, mInterfaceName);
+                    } catch (Exception e1) {
+                        loge("Exception in softap re-start " + e1);
+                        sendMessage(CMD_START_AP_FAILURE);
+                        return;
+                    }
+                }
+                if (DBG) log("Soft AP start successful");
+                sendMessage(CMD_START_AP_SUCCESS);
+            }
+        }).start();
+    }
+
+    /*
+     * Read a MAC address in /proc/arp/table, used by WifistateMachine
+     * so as to record MAC address of default gateway.
+     **/
+    private String macAddressFromRoute(String ipAddress) {
+        String macAddress = null;
+        BufferedReader reader = null;
+        try {
+            reader = new BufferedReader(new FileReader("/proc/net/arp"));
+
+            // Skip over the line bearing colum titles
+            String line = reader.readLine();
+
+            while ((line = reader.readLine()) != null) {
+                String[] tokens = line.split("[ ]+");
+                if (tokens.length < 6) {
+                    continue;
+                }
+
+                // ARP column format is
+                // Address HWType HWAddress Flags Mask IFace
+                String ip = tokens[0];
+                String mac = tokens[3];
+
+                if (ipAddress.equals(ip)) {
+                    macAddress = mac;
+                    break;
+                }
+            }
+
+            if (macAddress == null) {
+                loge("Did not find remoteAddress {" + ipAddress + "} in " +
+                        "/proc/net/arp");
+            }
+
+        } catch (FileNotFoundException e) {
+            loge("Could not open /proc/net/arp to lookup mac address");
+        } catch (IOException e) {
+            loge("Could not read /proc/net/arp to lookup mac address");
+        } finally {
+            try {
+                if (reader != null) {
+                    reader.close();
+                }
+            } catch (IOException e) {
+                // Do nothing
+            }
+        }
+        return macAddress;
+
+    }
+
+    private class WifiNetworkFactory extends NetworkFactory {
+        public WifiNetworkFactory(Looper l, Context c, String TAG, NetworkCapabilities f) {
+            super(l, c, TAG, f);
+        }
+        protected void startNetwork() {
+            // TODO
+            // Enter association mode.
+        }
+        protected void stopNetwork() {
+            // TODO
+            // Stop associating.
+        }
+    }
+    /********************************************************
+     * HSM states
+     *******************************************************/
+
+    class DefaultState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED: {
+                    AsyncChannel ac = (AsyncChannel) message.obj;
+                    if (ac == mWifiP2pChannel) {
+                        if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
+                            mWifiP2pChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
+                        } else {
+                            loge("WifiP2pService connection failure, error=" + message.arg1);
+                        }
+                    } else {
+                        loge("got HALF_CONNECTED for unknown channel");
+                    }
+                    break;
+                }
+                case AsyncChannel.CMD_CHANNEL_DISCONNECTED: {
+                    AsyncChannel ac = (AsyncChannel) message.obj;
+                    if (ac == mWifiP2pChannel) {
+                        loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
+                        //TODO: Re-establish connection to state machine after a delay
+                        // mWifiP2pChannel.connect(mContext, getHandler(),
+                        // mWifiP2pManager.getMessenger());
+                    }
+                    break;
+                }
+                case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
+                    mBluetoothConnectionActive = (message.arg1 !=
+                            BluetoothAdapter.STATE_DISCONNECTED);
+                    break;
+                    /* Synchronous call returns */
+                case CMD_PING_SUPPLICANT:
+                case CMD_ENABLE_NETWORK:
+                case CMD_ADD_OR_UPDATE_NETWORK:
+                case CMD_REMOVE_NETWORK:
+                case CMD_SAVE_CONFIG:
+                    replyToMessage(message, message.what, FAILURE);
+                    break;
+                case CMD_GET_CAPABILITY_FREQ:
+                    replyToMessage(message, message.what, null);
+                    break;
+                case CMD_GET_CONFIGURED_NETWORKS:
+                    replyToMessage(message, message.what, (List<WifiConfiguration>) null);
+                    break;
+                case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
+                    replyToMessage(message, message.what, (List<WifiConfiguration>) null);
+                    break;
+                case CMD_ENABLE_RSSI_POLL:
+                    mEnableRssiPolling = (message.arg1 == 1);
+                    break;
+                case CMD_SET_HIGH_PERF_MODE:
+                    if (message.arg1 == 1) {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
+                    } else {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
+                    }
+                    break;
+                case CMD_BOOT_COMPLETED:
+                    String countryCode = mPersistedCountryCode;
+                    if (TextUtils.isEmpty(countryCode) == false) {
+                        Settings.Global.putString(mContext.getContentResolver(),
+                                Settings.Global.WIFI_COUNTRY_CODE,
+                                countryCode);
+                        // It may be that the state transition that should send this info
+                        // to the driver happened between mPersistedCountryCode getting set
+                        // and now, so simply persisting it here would mean we have sent
+                        // nothing to the driver.  Send the cmd so it might be set now.
+                        int sequenceNum = mCountryCodeSequence.incrementAndGet();
+                        sendMessageAtFrontOfQueue(CMD_SET_COUNTRY_CODE,
+                                sequenceNum, 0, countryCode);
+                    }
+
+                    checkAndSetConnectivityInstance();
+                    mNetworkFactory = new WifiNetworkFactory(getHandler().getLooper(), mContext,
+                            NETWORKTYPE, mNetworkCapabilitiesFilter);
+                    mNetworkFactory.setScoreFilter(60);
+                    mCm.registerNetworkFactory(new Messenger(mNetworkFactory), NETWORKTYPE);
+                    break;
+                case CMD_SET_BATCHED_SCAN:
+                    recordBatchedScanSettings(message.arg1, message.arg2, (Bundle)message.obj);
+                    break;
+                case CMD_POLL_BATCHED_SCAN:
+                    handleBatchedScanPollRequest();
+                    break;
+                case CMD_START_NEXT_BATCHED_SCAN:
+                    startNextBatchedScan();
+                    break;
+                case CMD_SCREEN_STATE_CHANGED:
+                    handleScreenStateChanged(message.arg1 != 0,
+                            /* startBackgroundScanIfNeeded = */ false);
+                    break;
+                    /* Discard */
+                case CMD_START_SCAN:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    break;
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT_FAILED:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_DELAYED_STOP_DRIVER:
+                case CMD_DRIVER_START_TIMED_OUT:
+                case CMD_START_AP:
+                case CMD_START_AP_SUCCESS:
+                case CMD_START_AP_FAILURE:
+                case CMD_STOP_AP:
+                case CMD_TETHER_STATE_CHANGE:
+                case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                case CMD_DISCONNECT:
+                case CMD_RECONNECT:
+                case CMD_REASSOCIATE:
+                case CMD_RELOAD_TLS_AND_RECONNECT:
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case CMD_BLACKLIST_NETWORK:
+                case CMD_CLEAR_BLACKLIST:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_RSSI_POLL:
+                case CMD_ENABLE_ALL_NETWORKS:
+                case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                /* Handled by WifiApConfigStore */
+                case CMD_SET_AP_CONFIG:
+                case CMD_SET_AP_CONFIG_COMPLETED:
+                case CMD_REQUEST_AP_CONFIG:
+                case CMD_RESPONSE_AP_CONFIG:
+                case WifiWatchdogStateMachine.POOR_LINK_DETECTED:
+                case WifiWatchdogStateMachine.GOOD_LINK_DETECTED:
+                case CMD_NO_NETWORKS_PERIODIC_SCAN:
+                case CMD_DISABLE_P2P_RSP:
+                case WifiMonitor.SUP_REQUEST_IDENTITY:
+                case CMD_TEST_NETWORK_DISCONNECT:
+                case CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER:
+                case WifiMonitor.SUP_REQUEST_SIM_AUTH:
+                case CMD_TARGET_BSSID:
+                case CMD_AUTO_CONNECT:
+                case CMD_AUTO_ROAM:
+                case CMD_AUTO_SAVE_NETWORK:
+                case CMD_ASSOCIATED_BSSID:
+                case CMD_UNWANTED_NETWORK:
+                case CMD_DISCONNECTING_WATCHDOG_TIMER:
+                case CMD_ROAM_WATCHDOG_TIMER:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    break;
+                case DhcpStateMachine.CMD_ON_QUIT:
+                    mDhcpStateMachine = null;
+                    break;
+                case CMD_SET_SUSPEND_OPT_ENABLED:
+                    if (message.arg1 == 1) {
+                        mSuspendWakeLock.release();
+                        setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
+                    } else {
+                        setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
+                    }
+                    break;
+                case WifiMonitor.DRIVER_HUNG_EVENT:
+                    setSupplicantRunning(false);
+                    setSupplicantRunning(true);
+                    break;
+                case WifiManagerWAP.CONNECT_NETWORK:
+                    replyToMessage(message, WifiManagerWAP.CONNECT_NETWORK_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.FORGET_NETWORK:
+                    replyToMessage(message, WifiManagerWAP.FORGET_NETWORK_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.SAVE_NETWORK:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                    replyToMessage(message, WifiManagerWAP.SAVE_NETWORK_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.START_WPS:
+                    replyToMessage(message, WifiManagerWAP.WPS_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.CANCEL_WPS:
+                    replyToMessage(message, WifiManagerWAP.CANCEL_WPS_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.DISABLE_NETWORK:
+                    replyToMessage(message, WifiManagerWAP.DISABLE_NETWORK_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case WifiManagerWAP.RSSI_PKTCNT_FETCH:
+                    replyToMessage(message, WifiManagerWAP.RSSI_PKTCNT_FETCH_FAILED,
+                            WifiManagerWAP.BUSY);
+                    break;
+                case CMD_GET_SUPPORTED_FEATURES:
+                    if (WifiNative.startHal()) {
+                        int featureSet = WifiNative.getSupportedFeatureSet();
+                        replyToMessage(message, message.what, featureSet);
+                    } else {
+                        replyToMessage(message, message.what, 0);
+                    }
+                    break;
+                case CMD_GET_LINK_LAYER_STATS:
+                    // Not supported hence reply with error message
+                    replyToMessage(message, message.what, null);
+                    break;
+                case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
+                    NetworkInfo info = (NetworkInfo) message.obj;
+                    mP2pConnected.set(info.isConnected());
+                    break;
+                case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
+                    mTemporarilyDisconnectWifi = (message.arg1 == 1);
+                    replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
+                    break;
+                case WifiP2pServiceImpl.P2P_MIRACAST_MODE_CHANGED:
+                    break;
+                /* Link configuration (IP address, DNS, ...) changes notified via netlink */
+                case CMD_UPDATE_LINKPROPERTIES:
+                    updateLinkProperties(CMD_UPDATE_LINKPROPERTIES, (LinkProperties)message.obj);
+                    break;
+                case CMD_IP_CONFIGURATION_SUCCESSFUL:
+                case CMD_IP_CONFIGURATION_LOST:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    break;
+                case CMD_GET_CONNECTION_STATISTICS:
+                    replyToMessage(message, message.what, mWifiConnectionStatistics);
+                    break;
+                default:
+                    loge("Error! unhandled message" + message);
+                    break;
+            }
+            return HANDLED;
+        }
+    }
+
+    class InitialState extends State {
+        @Override
+        public void enter() {
+            mWifiNative.unloadApDriver();
+          /*if (mWifiP2pChannel == null) {
+                mWifiP2pChannel = new AsyncChannel();
+                mWifiP2pChannel.connect(mContext, getHandler(),
+                    mWifiP2pServiceImpl.getP2pStateMachineMessenger());
+            }*/
+            if (mWifiApConfigChannel == null) {
+                mWifiApConfigChannel = new AsyncChannel();
+                WifiApConfigStore wifiApConfigStore = WifiApConfigStore.makeWifiApConfigStore(
+                        mContext, getHandler());
+                wifiApConfigStore.loadApConfiguration();
+                mWifiApConfigChannel.connectSync(mContext, getHandler(),
+                        wifiApConfigStore.getMessenger());
+            }
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+            switch (message.what) {
+                case CMD_START_SUPPLICANT:
+                    if (mWifiNative.loadDriver()) {
+                        try {
+                            mNwService.wifiFirmwareReload(mInterfaceName, "STA");
+                        } catch (Exception e) {
+                            loge("Failed to reload STA firmware " + e);
+                            // Continue
+                        }
+
+                        try {
+                            // A runtime crash can leave the interface up and
+                            // IP addresses configured, and this affects
+                            // connectivity when supplicant starts up.
+                            // Ensure interface is down and we have no IP
+                            // addresses before a supplicant start.
+                            mNwService.setInterfaceDown(mInterfaceName);
+                            mNwService.clearInterfaceAddresses(mInterfaceName);
+
+                            // Set privacy extensions
+                            mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
+
+                           // IPv6 is enabled only as long as access point is connected since:
+                           // - IPv6 addresses and routes stick around after disconnection
+                           // - kernel is unaware when connected and fails to start IPv6 negotiation
+                           // - kernel can start autoconfiguration when 802.1x is not complete
+                            mNwService.disableIpv6(mInterfaceName);
+                        } catch (RemoteException re) {
+                            loge("Unable to change interface settings: " + re);
+                        } catch (IllegalStateException ie) {
+                            loge("Unable to change interface settings: " + ie);
+                        }
+
+                       /* Stop a running supplicant after a runtime restart
+                        * Avoids issues with drivers that do not handle interface down
+                        * on a running supplicant properly.
+                        */
+                        mWifiMonitor.killSupplicant(mP2pSupported);
+                        if(mWifiNative.startSupplicant(mP2pSupported)) {
+                            setWifiState(WIFI_STATE_ENABLING);
+                            if (DBG) log("Supplicant start successful");
+                            mWifiMonitor.startMonitoring();
+                            transitionTo(mSupplicantStartingState);
+                        } else {
+                            loge("Failed to start supplicant!");
+                        }
+                    } else {
+                        loge("Failed to load driver");
+                    }
+                    break;
+                case CMD_START_AP:
+                    if (mWifiNative.loadApDriver()) {
+                        setWifiApState(WIFI_AP_STATE_ENABLING);
+                        transitionTo(mSoftApStartingState);
+                    } else {
+                        loge("Failed to load driver for softap");
+                    }
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class SupplicantStartingState extends State {
+        private void initializeWpsDetails() {
+            String detail;
+            detail = SystemProperties.get("ro.product.name", "");
+            if (!mWifiNative.setDeviceName(detail)) {
+                loge("Failed to set device name " +  detail);
+            }
+            detail = SystemProperties.get("ro.product.manufacturer", "");
+            if (!mWifiNative.setManufacturer(detail)) {
+                loge("Failed to set manufacturer " + detail);
+            }
+            detail = SystemProperties.get("ro.product.model", "");
+            if (!mWifiNative.setModelName(detail)) {
+                loge("Failed to set model name " + detail);
+            }
+            detail = SystemProperties.get("ro.product.model", "");
+            if (!mWifiNative.setModelNumber(detail)) {
+                loge("Failed to set model number " + detail);
+            }
+            detail = SystemProperties.get("ro.serialno", "");
+            if (!mWifiNative.setSerialNumber(detail)) {
+                loge("Failed to set serial number " + detail);
+            }
+            if (!mWifiNative.setConfigMethods("physical_display virtual_push_button")) {
+                loge("Failed to set WPS config methods");
+            }
+            if (!mWifiNative.setDeviceType(mPrimaryDeviceType)) {
+                loge("Failed to set primary device type " + mPrimaryDeviceType);
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                    if (DBG) log("Supplicant connection established");
+                    setWifiState(WIFI_STATE_ENABLED);
+                    mSupplicantRestartCount = 0;
+                    /* Reset the supplicant state to indicate the supplicant
+                     * state is not known at this time */
+                    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
+                    /* Initialize data structures */
+                    mLastBssid = null;
+                    mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
+                    mLastSignalLevel = -1;
+
+                    mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
+                    mWifiNative.enableSaveConfig();
+                    mWifiConfigStore.loadAndEnableAllNetworks();
+                    if (mWifiConfigStore.enableVerboseLogging > 0) {
+                        enableVerboseLogging(mWifiConfigStore.enableVerboseLogging);
+                    }
+                    if (mWifiConfigStore.associatedPartialScanPeriodMilli < 0) {
+                        mWifiConfigStore.associatedPartialScanPeriodMilli = 0;
+                    }
+                    initializeWpsDetails();
+
+                    sendSupplicantConnectionChangedBroadcast(true);
+                    transitionTo(mDriverStartedState);
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
+                        loge("Failed to setup control channel, restart supplicant");
+                        mWifiMonitor.killSupplicant(mP2pSupported);
+                        transitionTo(mInitialState);
+                        sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
+                    } else {
+                        loge("Failed " + mSupplicantRestartCount +
+                                " times to start supplicant, unload driver");
+                        mSupplicantRestartCount = 0;
+                        setWifiState(WIFI_STATE_UNKNOWN);
+                        transitionTo(mInitialState);
+                    }
+                    break;
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class SupplicantStartedState extends State {
+        @Override
+        public void enter() {
+            /* Wifi is available as long as we have a connection to supplicant */
+            mNetworkInfo.setIsAvailable(true);
+            if (mNetworkAgent != null) mNetworkAgent.sendNetworkInfo(mNetworkInfo);
+
+            int defaultInterval = mContext.getResources().getInteger(
+                    R.integer.config_wifi_supplicant_scan_interval);
+
+            mSupplicantScanIntervalMs = Settings.Global.getLong(mContext.getContentResolver(),
+                    Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS,
+                    defaultInterval);
+
+            mWifiNative.setScanInterval((int)mSupplicantScanIntervalMs / 1000);
+            mWifiNative.setExternalSim(true);
+
+            setRandomMacOui();
+            if (mWifiConfigStore.enableAutoJoinWhenAssociated) {
+                mWifiNative.enableAutoConnect(false);
+            } else {
+                if (DBG) {
+                    log("Autojoin is disabled, keep autoconnect enabled in supplicant");
+                }
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_STOP_SUPPLICANT:   /* Supplicant stopped by user */
+                    if (mP2pSupported) {
+                        transitionTo(mWaitForP2pDisableState);
+                    } else {
+                        transitionTo(mSupplicantStoppingState);
+                    }
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:  /* Supplicant connection lost */
+                    loge("Connection lost, restart supplicant");
+                    handleSupplicantConnectionLoss(true);
+                    handleNetworkDisconnect();
+                    mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
+                    if (mP2pSupported) {
+                        transitionTo(mWaitForP2pDisableState);
+                    } else {
+                        transitionTo(mInitialState);
+                    }
+                    sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
+                    break;
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                    closeRadioScanStats();
+                    noteScanEnd();
+                    setScanResults();
+                    if (mIsFullScanOngoing) {
+                        /* Just updated results from full scan, let apps know about this */
+                        sendScanResultsAvailableBroadcast();
+                    }
+                    mIsScanOngoing = false;
+                    mIsFullScanOngoing = false;
+                    if (mBufferedScanMsg.size() > 0)
+                        sendMessage(mBufferedScanMsg.remove());
+                    break;
+                case CMD_PING_SUPPLICANT:
+                    boolean ok = mWifiNative.ping();
+                    replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
+                    break;
+                case CMD_GET_CAPABILITY_FREQ:
+                    String freqs = mWifiNative.getFreqCapability();
+                    replyToMessage(message, message.what, freqs);
+                    break;
+                case CMD_START_AP:
+                    /* Cannot start soft AP while in client mode */
+                    loge("Failed to start soft AP with a running supplicant");
+                    setWifiApState(WIFI_AP_STATE_FAILED);
+                    break;
+                case CMD_SET_OPERATIONAL_MODE:
+                    mOperationalMode = message.arg1;
+                    break;
+                case CMD_TARGET_BSSID:
+                    // Trying to associate to this BSSID
+                    if (message.obj != null) {
+                        mTargetRoamBSSID = (String) message.obj;
+                    }
+                    break;
+                case CMD_GET_LINK_LAYER_STATS:
+                    WifiLinkLayerStats stats = getWifiLinkLayerStats(DBG);
+                    if (stats == null) {
+                        // When firmware doesnt support link layer stats, return an empty object
+                        stats = new WifiLinkLayerStats();
+                    }
+                    replyToMessage(message, message.what, stats);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            mNetworkInfo.setIsAvailable(false);
+            if (mNetworkAgent != null) mNetworkAgent.sendNetworkInfo(mNetworkInfo);
+        }
+    }
+
+    class SupplicantStoppingState extends State {
+        @Override
+        public void enter() {
+            /* Send any reset commands to supplicant before shutting it down */
+            handleNetworkDisconnect();
+            if (mDhcpStateMachine != null) {
+                mDhcpStateMachine.doQuit();
+            }
+
+            if (DBG) log("stopping supplicant");
+            mWifiMonitor.stopSupplicant();
+
+            /* Send ourselves a delayed message to indicate failure after a wait time */
+            sendMessageDelayed(obtainMessage(CMD_STOP_SUPPLICANT_FAILED,
+                    ++mSupplicantStopFailureToken, 0), SUPPLICANT_RESTART_INTERVAL_MSECS);
+            setWifiState(WIFI_STATE_DISABLING);
+            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case WifiMonitor.SUP_CONNECTION_EVENT:
+                    loge("Supplicant connection received while stopping");
+                    break;
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    if (DBG) log("Supplicant connection lost");
+                    handleSupplicantConnectionLoss(false);
+                    transitionTo(mInitialState);
+                    break;
+                case CMD_STOP_SUPPLICANT_FAILED:
+                    if (message.arg1 == mSupplicantStopFailureToken) {
+                        loge("Timed out on a supplicant stop, kill and proceed");
+                        handleSupplicantConnectionLoss(true);
+                        transitionTo(mInitialState);
+                    }
+                    break;
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverStartingState extends State {
+        private int mTries;
+        @Override
+        public void enter() {
+            mTries = 1;
+            /* Send ourselves a delayed message to start driver a second time */
+            sendMessageDelayed(obtainMessage(CMD_DRIVER_START_TIMED_OUT,
+                        ++mDriverStartToken, 0), DRIVER_START_TIME_OUT_MSECS);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+               case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    SupplicantState state = handleSupplicantStateChange(message);
+                    /* If suplicant is exiting out of INTERFACE_DISABLED state into
+                     * a state that indicates driver has started, it is ready to
+                     * receive driver commands
+                     */
+                    if (SupplicantState.isDriverActive(state)) {
+                        transitionTo(mDriverStartedState);
+                    }
+                    break;
+                case CMD_DRIVER_START_TIMED_OUT:
+                    if (message.arg1 == mDriverStartToken) {
+                        if (mTries >= 2) {
+                            loge("Failed to start driver after " + mTries);
+                            transitionTo(mDriverStoppedState);
+                        } else {
+                            loge("Driver start failed, retrying");
+                            mWakeLock.acquire();
+                            mWifiNative.startDriver();
+                            mWakeLock.release();
+
+                            ++mTries;
+                            /* Send ourselves a delayed message to start driver again */
+                            sendMessageDelayed(obtainMessage(CMD_DRIVER_START_TIMED_OUT,
+                                        ++mDriverStartToken, 0), DRIVER_START_TIME_OUT_MSECS);
+                        }
+                    }
+                    break;
+                    /* Queue driver commands & connection events */
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                case CMD_START_SCAN:
+                case CMD_DISCONNECT:
+                case CMD_REASSOCIATE:
+                case CMD_RECONNECT:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                    deferMessage(message);
+                    break;
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                    // Loose scan results obtained in Driver Starting state, they can only confuse
+                    // the state machine
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverStartedState extends State {
+        @Override
+        public void enter() {
+
+            if (PDBG) {
+                loge("Driverstarted State enter");
+            }
+            mIsRunning = true;
+            mInDelayedStop = false;
+            mDelayedStopCounter++;
+            updateBatteryWorkSource(null);
+            /**
+             * Enable bluetooth coexistence scan mode when bluetooth connection is active.
+             * When this mode is on, some of the low-level scan parameters used by the
+             * driver are changed to reduce interference with bluetooth
+             */
+            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
+            /* set country code */
+            setCountryCode();
+            /* set frequency band of operation */
+            setFrequencyBand();
+            /* initialize network state */
+            setNetworkDetailedState(DetailedState.DISCONNECTED);
+
+            /* Remove any filtering on Multicast v6 at start */
+            mWifiNative.stopFilteringMulticastV6Packets();
+
+            /* Reset Multicast v4 filtering state */
+            if (mFilteringMulticastV4Packets.get()) {
+                mWifiNative.startFilteringMulticastV4Packets();
+            } else {
+                mWifiNative.stopFilteringMulticastV4Packets();
+            }
+
+            mDhcpActive = false;
+
+            startBatchedScan();
+
+            if (mOperationalMode != CONNECT_MODE) {
+                mWifiNative.disconnect();
+                mWifiConfigStore.disableAllNetworks();
+                if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
+                    setWifiState(WIFI_STATE_DISABLED);
+                }
+                transitionTo(mScanModeState);
+            } else {
+
+                // Status pulls in the current supplicant state and network connection state
+                // events over the monitor connection. This helps framework sync up with
+                // current supplicant state
+                // TODO: actually check th supplicant status string and make sure the supplicant
+                // is in disconnecte4d state.
+                mWifiNative.status();
+                // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
+                transitionTo(mDisconnectedState);
+            }
+
+            // We may have missed screen update at boot
+            if (mScreenBroadcastReceived.get() == false) {
+                PowerManager powerManager = (PowerManager)mContext.getSystemService(
+                        Context.POWER_SERVICE);
+                handleScreenStateChanged(powerManager.isScreenOn(),
+                        /* startBackgroundScanIfNeeded = */ false);
+            } else {
+                // Set the right suspend mode settings
+                mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0
+                        && mUserWantsSuspendOpt.get());
+            }
+            mWifiNative.setPowerSave(true);
+
+            if (mP2pSupported) {
+                if (mOperationalMode == CONNECT_MODE) {
+                    mWifiP2pChannel.sendMessage(WifiStateMachineWAP.CMD_ENABLE_P2P);
+                } else {
+                    // P2P statemachine starts in disabled state, and is not enabled until
+                    // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
+                    // keep it disabled.
+                }
+            }
+
+            final Intent intent = new Intent(WifiManagerWAP.WIFI_SCAN_AVAILABLE);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            intent.putExtra(WifiManagerWAP.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
+            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+
+            if (PDBG) {
+                loge("Driverstarted State enter done");
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_START_SCAN:
+                    handleScanRequest(WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, message);
+                    break;
+                case CMD_SET_BATCHED_SCAN:
+                    if (recordBatchedScanSettings(message.arg1, message.arg2,
+                            (Bundle)message.obj)) {
+                        if (mBatchedScanSettings != null) {
+                            startBatchedScan();
+                        } else {
+                            stopBatchedScan();
+                        }
+                    }
+                    break;
+                case CMD_SET_COUNTRY_CODE:
+                    String country = (String) message.obj;
+                    final boolean persist = (message.arg2 == 1);
+                    final int sequence = message.arg1;
+                    if (sequence != mCountryCodeSequence.get()) {
+                        if (DBG) log("set country code ignored due to sequnce num");
+                        break;
+                    }
+                    if (DBG) log("set country code " + country);
+                    if (persist) {
+                        mPersistedCountryCode = country;
+                        Settings.Global.putString(mContext.getContentResolver(),
+                                Settings.Global.WIFI_COUNTRY_CODE,
+                                country);
+                    }
+                    country = country.toUpperCase(Locale.ROOT);
+                    if (mLastSetCountryCode == null
+                            || country.equals(mLastSetCountryCode) == false) {
+                        if (mWifiNative.setCountryCode(country)) {
+                            mLastSetCountryCode = country;
+                        } else {
+                            loge("Failed to set country code " + country);
+                        }
+                    }
+                    mWifiP2pChannel.sendMessage(WifiP2pServiceImpl.SET_COUNTRY_CODE, country);
+                    break;
+                case CMD_SET_FREQUENCY_BAND:
+                    int band =  message.arg1;
+                    if (DBG) log("set frequency band " + band);
+                    if (mWifiNative.setBand(band)) {
+
+                        if (PDBG)  loge("did set frequency band " + band);
+
+                        mFrequencyBand.set(band);
+                        // Flush old data - like scan results
+                        mWifiNative.bssFlush();
+                        if (mFrequencyBand.get() == WifiManagerWAP.WIFI_FREQUENCY_BAND_2GHZ) {
+                            mWifiNative.disable5GHzFrequencies(true);
+                            mDisabled5GhzFrequencies = true;
+                        } else if ((mFrequencyBand.get() != WifiManagerWAP.WIFI_FREQUENCY_BAND_2GHZ)
+                           && (mDisabled5GhzFrequencies)) {
+                            mWifiNative.disable5GHzFrequencies(false);
+                            mDisabled5GhzFrequencies = false;
+                        }
+                        // Fetch the latest scan results when frequency band is set
+                        startScanNative(WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, null);
+
+                        if (PDBG)  loge("done set frequency band " + band);
+
+                    } else {
+                        loge("Failed to set frequency band " + band);
+                    }
+                    break;
+                case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
+                    mBluetoothConnectionActive = (message.arg1 !=
+                            BluetoothAdapter.STATE_DISCONNECTED);
+                    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
+                    break;
+                case CMD_STOP_DRIVER:
+                    int mode = message.arg1;
+
+                    /* Already doing a delayed stop */
+                    if (mInDelayedStop) {
+                        if (DBG) log("Already in delayed stop");
+                        break;
+                    }
+                    /* disconnect right now, but leave the driver running for a bit */
+                    mWifiConfigStore.disableAllNetworks();
+
+                    mInDelayedStop = true;
+                    mDelayedStopCounter++;
+                    if (DBG) log("Delayed stop message " + mDelayedStopCounter);
+
+                    /* send regular delayed shut down */
+                    Intent driverStopIntent = new Intent(ACTION_DELAYED_DRIVER_STOP, null);
+                    driverStopIntent.putExtra(DELAYED_STOP_COUNTER, mDelayedStopCounter);
+                    mDriverStopIntent = PendingIntent.getBroadcast(mContext,
+                            DRIVER_STOP_REQUEST, driverStopIntent,
+                            PendingIntent.FLAG_UPDATE_CURRENT);
+
+                    mAlarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis()
+                            + mDriverStopDelayMs, mDriverStopIntent);
+                    break;
+                case CMD_START_DRIVER:
+                    if (mInDelayedStop) {
+                        mInDelayedStop = false;
+                        mDelayedStopCounter++;
+                        mAlarmManager.cancel(mDriverStopIntent);
+                        if (DBG) log("Delayed stop ignored due to start");
+                        if (mOperationalMode == CONNECT_MODE) {
+                            mWifiConfigStore.enableAllNetworks();
+                        }
+                    }
+                    break;
+                case CMD_DELAYED_STOP_DRIVER:
+                    if (DBG) log("delayed stop " + message.arg1 + " " + mDelayedStopCounter);
+                    if (message.arg1 != mDelayedStopCounter) break;
+                    if (getCurrentState() != mDisconnectedState) {
+                        mWifiNative.disconnect();
+                        handleNetworkDisconnect();
+                    }
+                    mWakeLock.acquire();
+                    mWifiNative.stopDriver();
+                    mWakeLock.release();
+                    if (mP2pSupported) {
+                        transitionTo(mWaitForP2pDisableState);
+                    } else {
+                        transitionTo(mDriverStoppingState);
+                    }
+                    break;
+                case CMD_START_PACKET_FILTERING:
+                    if (message.arg1 == MULTICAST_V6) {
+                        mWifiNative.startFilteringMulticastV6Packets();
+                    } else if (message.arg1 == MULTICAST_V4) {
+                        mWifiNative.startFilteringMulticastV4Packets();
+                    } else {
+                        loge("Illegal arugments to CMD_START_PACKET_FILTERING");
+                    }
+                    break;
+                case CMD_STOP_PACKET_FILTERING:
+                    if (message.arg1 == MULTICAST_V6) {
+                        mWifiNative.stopFilteringMulticastV6Packets();
+                    } else if (message.arg1 == MULTICAST_V4) {
+                        mWifiNative.stopFilteringMulticastV4Packets();
+                    } else {
+                        loge("Illegal arugments to CMD_STOP_PACKET_FILTERING");
+                    }
+                    break;
+                case CMD_SET_SUSPEND_OPT_ENABLED:
+                    if (message.arg1 == 1) {
+                        setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
+                        mSuspendWakeLock.release();
+                    } else {
+                        setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
+                    }
+                    break;
+                case CMD_SET_HIGH_PERF_MODE:
+                    if (message.arg1 == 1) {
+                        setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
+                    } else {
+                        setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
+                    }
+                    break;
+                case CMD_ENABLE_TDLS:
+                    if (message.obj != null) {
+                        String remoteAddress = (String) message.obj;
+                        boolean enable = (message.arg1 == 1);
+                        mWifiNative.startTdls(remoteAddress, enable);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+        @Override
+        public void exit() {
+            mIsRunning = false;
+            updateBatteryWorkSource(null);
+            mScanResults = new ArrayList<ScanResult>();
+
+            stopBatchedScan();
+
+            final Intent intent = new Intent(WifiManagerWAP.WIFI_SCAN_AVAILABLE);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            intent.putExtra(WifiManagerWAP.EXTRA_SCAN_AVAILABLE, WIFI_STATE_DISABLED);
+            mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
+            noteScanEnd(); // wrap up any pending request.
+            mBufferedScanMsg.clear();
+
+            mLastSetCountryCode = null;
+        }
+    }
+
+    class WaitForP2pDisableState extends State {
+        private State mTransitionToState;
+        @Override
+        public void enter() {
+            switch (getCurrentMessage().what) {
+                case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                    mTransitionToState = mInitialState;
+                    break;
+                case CMD_DELAYED_STOP_DRIVER:
+                    mTransitionToState = mDriverStoppingState;
+                    break;
+                case CMD_STOP_SUPPLICANT:
+                    mTransitionToState = mSupplicantStoppingState;
+                    break;
+                default:
+                    mTransitionToState = mDriverStoppingState;
+                    break;
+            }
+            mWifiP2pChannel.sendMessage(WifiStateMachineWAP.CMD_DISABLE_P2P_REQ);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case WifiStateMachineWAP.CMD_DISABLE_P2P_RSP:
+                    transitionTo(mTransitionToState);
+                    break;
+                /* Defer wifi start/shut and driver commands */
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                case CMD_START_SCAN:
+                case CMD_DISCONNECT:
+                case CMD_REASSOCIATE:
+                case CMD_RECONNECT:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverStoppingState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    SupplicantState state = handleSupplicantStateChange(message);
+                    if (state == SupplicantState.INTERFACE_DISABLED) {
+                        transitionTo(mDriverStoppedState);
+                    }
+                    break;
+                    /* Queue driver commands */
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                case CMD_START_SCAN:
+                case CMD_DISCONNECT:
+                case CMD_REASSOCIATE:
+                case CMD_RECONNECT:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class DriverStoppedState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+            switch (message.what) {
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    SupplicantState state = stateChangeResult.state;
+                    // A WEXT bug means that we can be back to driver started state
+                    // unexpectedly
+                    if (SupplicantState.isDriverActive(state)) {
+                        transitionTo(mDriverStartedState);
+                    }
+                    break;
+                case CMD_START_DRIVER:
+                    mWakeLock.acquire();
+                    mWifiNative.startDriver();
+                    mWakeLock.release();
+                    transitionTo(mDriverStartingState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class ScanModeState extends State {
+        private int mLastOperationMode;
+        @Override
+        public void enter() {
+            mLastOperationMode = mOperationalMode;
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_SET_OPERATIONAL_MODE:
+                    if (message.arg1 == CONNECT_MODE) {
+
+                        if (mLastOperationMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
+                            setWifiState(WIFI_STATE_ENABLED);
+                            // Load and re-enable networks when going back to enabled state
+                            // This is essential for networks to show up after restore
+                            mWifiConfigStore.loadAndEnableAllNetworks();
+                            mWifiP2pChannel.sendMessage(CMD_ENABLE_P2P);
+                        } else {
+                            mWifiConfigStore.enableAllNetworks();
+                        }
+
+                        mWifiNative.reconnect();
+
+                        mOperationalMode = CONNECT_MODE;
+                        transitionTo(mDisconnectedState);
+                    } else {
+                        // Nothing to do
+                        return HANDLED;
+                    }
+                    break;
+                // Handle scan. All the connection related commands are
+                // handled only in ConnectModeState
+                case CMD_START_SCAN:
+                    handleScanRequest(WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+
+    String smToString(Message message) {
+        return smToString(message.what);
+    }
+
+    String smToString(int what) {
+        String s = "unknown";
+        switch (what) {
+            case WifiMonitor.DRIVER_HUNG_EVENT:
+                s = "DRIVER_HUNG_EVENT";
+                break;
+            case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
+                s = "AsyncChannel.CMD_CHANNEL_HALF_CONNECTED";
+                break;
+            case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
+                s = "AsyncChannel.CMD_CHANNEL_DISCONNECTED";
+                break;
+            case CMD_SET_FREQUENCY_BAND:
+                s = "CMD_SET_FREQUENCY_BAND";
+                break;
+            case CMD_DELAYED_NETWORK_DISCONNECT:
+                s = "CMD_DELAYED_NETWORK_DISCONNECT";
+                break;
+            case CMD_TEST_NETWORK_DISCONNECT:
+                s = "CMD_TEST_NETWORK_DISCONNECT";
+                break;
+            case CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER:
+                s = "CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER";
+                break;
+            case CMD_START_DRIVER:
+                s = "CMD_START_DRIVER";
+                break;
+            case CMD_STOP_DRIVER:
+                s = "CMD_STOP_DRIVER";
+                break;
+            case CMD_STOP_SUPPLICANT:
+                s = "CMD_STOP_SUPPLICANT";
+                break;
+            case CMD_STOP_SUPPLICANT_FAILED:
+                s = "CMD_STOP_SUPPLICANT_FAILED";
+                break;
+            case CMD_START_SUPPLICANT:
+                s = "CMD_START_SUPPLICANT";
+                break;
+            case CMD_REQUEST_AP_CONFIG:
+                s = "CMD_REQUEST_AP_CONFIG";
+                break;
+            case CMD_RESPONSE_AP_CONFIG:
+                s = "CMD_RESPONSE_AP_CONFIG";
+                break;
+            case CMD_TETHER_STATE_CHANGE:
+                s = "CMD_TETHER_STATE_CHANGE";
+                break;
+            case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                s = "CMD_TETHER_NOTIFICATION_TIMED_OUT";
+                break;
+            case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
+                s = "CMD_BLUETOOTH_ADAPTER_STATE_CHANGE";
+                break;
+            case CMD_ADD_OR_UPDATE_NETWORK:
+                s = "CMD_ADD_OR_UPDATE_NETWORK";
+                break;
+            case CMD_REMOVE_NETWORK:
+                s = "CMD_REMOVE_NETWORK";
+                break;
+            case CMD_ENABLE_NETWORK:
+                s = "CMD_ENABLE_NETWORK";
+                break;
+            case CMD_ENABLE_ALL_NETWORKS:
+                s = "CMD_ENABLE_ALL_NETWORKS";
+                break;
+            case CMD_AUTO_CONNECT:
+                s = "CMD_AUTO_CONNECT";
+                break;
+            case CMD_AUTO_ROAM:
+                s = "CMD_AUTO_ROAM";
+                break;
+            case CMD_AUTO_SAVE_NETWORK:
+                s = "CMD_AUTO_SAVE_NETWORK";
+                break;
+            case CMD_BOOT_COMPLETED:
+                s = "CMD_BOOT_COMPLETED";
+                break;
+            case DhcpStateMachine.CMD_START_DHCP:
+                s = "CMD_START_DHCP";
+                break;
+            case DhcpStateMachine.CMD_STOP_DHCP:
+                s = "CMD_STOP_DHCP";
+                break;
+            case DhcpStateMachine.CMD_RENEW_DHCP:
+                s = "CMD_RENEW_DHCP";
+                break;
+            case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                s = "CMD_PRE_DHCP_ACTION";
+                break;
+            case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                s = "CMD_POST_DHCP_ACTION";
+                break;
+            case DhcpStateMachine.CMD_PRE_DHCP_ACTION_COMPLETE:
+                s = "CMD_PRE_DHCP_ACTION_COMPLETE";
+                break;
+            case DhcpStateMachine.CMD_ON_QUIT:
+                s = "CMD_ON_QUIT";
+                break;
+            case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
+                s = "WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST";
+                break;
+            case WifiManagerWAP.DISABLE_NETWORK:
+                s = "WifiManagerWAP.DISABLE_NETWORK";
+                break;
+            case CMD_BLACKLIST_NETWORK:
+                s = "CMD_BLACKLIST_NETWORK";
+                break;
+            case CMD_CLEAR_BLACKLIST:
+                s = "CMD_CLEAR_BLACKLIST";
+                break;
+            case CMD_SAVE_CONFIG:
+                s = "CMD_SAVE_CONFIG";
+                break;
+            case CMD_GET_CONFIGURED_NETWORKS:
+                s = "CMD_GET_CONFIGURED_NETWORKS";
+                break;
+            case CMD_GET_SUPPORTED_FEATURES:
+                s = "CMD_GET_ADAPTORS";
+                break;
+            case CMD_UNWANTED_NETWORK:
+                s = "CMD_UNWANTED_NETWORK";
+                break;
+            case CMD_GET_LINK_LAYER_STATS:
+                s = "CMD_GET_LINK_LAYER_STATS";
+                break;
+            case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
+                s = "CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS";
+                break;
+            case CMD_DISCONNECT:
+                s = "CMD_DISCONNECT";
+                break;
+            case CMD_RECONNECT:
+                s = "CMD_RECONNECT";
+                break;
+            case CMD_REASSOCIATE:
+                s = "CMD_REASSOCIATE";
+                break;
+            case CMD_GET_CONNECTION_STATISTICS:
+                s = "CMD_GET_CONNECTION_STATISTICS";
+                break;
+            case CMD_SET_HIGH_PERF_MODE:
+                s = "CMD_SET_HIGH_PERF_MODE";
+                break;
+            case CMD_SET_COUNTRY_CODE:
+                s = "CMD_SET_COUNTRY_CODE";
+                break;
+            case CMD_ENABLE_RSSI_POLL:
+                s = "CMD_ENABLE_RSSI_POLL";
+                break;
+            case CMD_RSSI_POLL:
+                s = "CMD_RSSI_POLL";
+                break;
+            case CMD_START_PACKET_FILTERING:
+                s = "CMD_START_PACKET_FILTERING";
+                break;
+            case CMD_STOP_PACKET_FILTERING:
+                s = "CMD_STOP_PACKET_FILTERING";
+                break;
+            case CMD_SET_SUSPEND_OPT_ENABLED:
+                s = "CMD_SET_SUSPEND_OPT_ENABLED";
+                break;
+            case CMD_NO_NETWORKS_PERIODIC_SCAN:
+                s = "CMD_NO_NETWORKS_PERIODIC_SCAN";
+                break;
+            case CMD_SET_BATCHED_SCAN:
+                s = "CMD_SET_BATCHED_SCAN";
+                break;
+            case CMD_START_NEXT_BATCHED_SCAN:
+                s = "CMD_START_NEXT_BATCHED_SCAN";
+                break;
+            case CMD_POLL_BATCHED_SCAN:
+                s = "CMD_POLL_BATCHED_SCAN";
+                break;
+            case CMD_UPDATE_LINKPROPERTIES:
+                s = "CMD_UPDATE_LINKPROPERTIES";
+                break;
+            case CMD_RELOAD_TLS_AND_RECONNECT:
+                s = "CMD_RELOAD_TLS_AND_RECONNECT";
+                break;
+            case WifiManagerWAP.CONNECT_NETWORK:
+                s = "CONNECT_NETWORK";
+                break;
+            case WifiManagerWAP.SAVE_NETWORK:
+                s = "SAVE_NETWORK";
+                break;
+            case WifiManagerWAP.FORGET_NETWORK:
+                s = "FORGET_NETWORK";
+                break;
+            case WifiMonitor.SUP_CONNECTION_EVENT:
+                s = "SUP_CONNECTION_EVENT";
+                break;
+            case WifiMonitor.SUP_DISCONNECTION_EVENT:
+                s = "SUP_DISCONNECTION_EVENT";
+                break;
+            case WifiMonitor.SCAN_RESULTS_EVENT:
+                s = "SCAN_RESULTS_EVENT";
+                break;
+            case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                s = "SUPPLICANT_STATE_CHANGE_EVENT";
+                break;
+            case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                s = "AUTHENTICATION_FAILURE_EVENT";
+                break;
+            case WifiMonitor.SSID_TEMP_DISABLED:
+                s = "SSID_TEMP_DISABLED";
+                break;
+            case WifiMonitor.SSID_REENABLED:
+                s = "SSID_REENABLED";
+                break;
+            case WifiMonitor.WPS_SUCCESS_EVENT:
+                s = "WPS_SUCCESS_EVENT";
+                break;
+            case WifiMonitor.WPS_FAIL_EVENT:
+                s = "WPS_FAIL_EVENT";
+                break;
+            case WifiMonitor.SUP_REQUEST_IDENTITY:
+                s = "SUP_REQUEST_IDENTITY";
+                break;
+            case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                s = "NETWORK_CONNECTION_EVENT";
+                break;
+            case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                s = "NETWORK_DISCONNECTION_EVENT";
+                break;
+            case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                s = "ASSOCIATION_REJECTION_EVENT";
+                break;
+            case CMD_SET_OPERATIONAL_MODE:
+                s = "CMD_SET_OPERATIONAL_MODE";
+                break;
+            case CMD_START_SCAN:
+                s = "CMD_START_SCAN";
+                break;
+            case CMD_DISABLE_P2P_RSP:
+                s = "CMD_DISABLE_P2P_RSP";
+                break;
+            case CMD_DISABLE_P2P_REQ:
+                s = "CMD_DISABLE_P2P_REQ";
+                break;
+            case WifiWatchdogStateMachine.GOOD_LINK_DETECTED:
+                s = "GOOD_LINK_DETECTED";
+                break;
+            case WifiWatchdogStateMachine.POOR_LINK_DETECTED:
+                s = "POOR_LINK_DETECTED";
+                break;
+            case WifiP2pServiceImpl.GROUP_CREATING_TIMED_OUT:
+                s = "GROUP_CREATING_TIMED_OUT";
+                break;
+            case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
+                s = "P2P_CONNECTION_CHANGED";
+                break;
+            case WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE:
+                s = "P2P.DISCONNECT_WIFI_RESPONSE";
+                break;
+            case WifiP2pServiceImpl.SET_MIRACAST_MODE:
+                s = "P2P.SET_MIRACAST_MODE";
+                break;
+            case WifiP2pServiceImpl.BLOCK_DISCOVERY:
+                s = "P2P.BLOCK_DISCOVERY";
+                break;
+            case WifiP2pServiceImpl.SET_COUNTRY_CODE:
+                s = "P2P.SET_COUNTRY_CODE";
+                break;
+            case WifiManagerWAP.CANCEL_WPS:
+                s = "CANCEL_WPS";
+                break;
+            case WifiManagerWAP.CANCEL_WPS_FAILED:
+                s = "CANCEL_WPS_FAILED";
+                break;
+            case WifiManagerWAP.CANCEL_WPS_SUCCEDED:
+                s = "CANCEL_WPS_SUCCEDED";
+                break;
+            case WifiManagerWAP.START_WPS:
+                s = "START_WPS";
+                break;
+            case WifiManagerWAP.START_WPS_SUCCEEDED:
+                s = "START_WPS_SUCCEEDED";
+                break;
+            case WifiManagerWAP.WPS_FAILED:
+                s = "WPS_FAILED";
+                break;
+            case WifiManagerWAP.WPS_COMPLETED:
+                s = "WPS_COMPLETED";
+                break;
+            case WifiManagerWAP.RSSI_PKTCNT_FETCH:
+                s = "RSSI_PKTCNT_FETCH";
+                break;
+            case CMD_IP_CONFIGURATION_LOST:
+                s = "CMD_IP_CONFIGURATION_LOST";
+                break;
+            case CMD_IP_CONFIGURATION_SUCCESSFUL:
+                s = "CMD_IP_CONFIGURATION_SUCCESSFUL";
+                break;
+            case CMD_STATIC_IP_SUCCESS:
+                s = "CMD_STATIC_IP_SUCCESSFUL";
+                break;
+            case CMD_STATIC_IP_FAILURE:
+                s = "CMD_STATIC_IP_FAILURE";
+                break;
+            case DhcpStateMachine.DHCP_SUCCESS:
+                s = "DHCP_SUCCESS";
+                break;
+            case DhcpStateMachine.DHCP_FAILURE:
+                s = "DHCP_FAILURE";
+                break;
+            case CMD_TARGET_BSSID:
+                s = "CMD_TARGET_BSSID";
+                break;
+            case CMD_ASSOCIATED_BSSID:
+                s = "CMD_ASSOCIATED_BSSID";
+                break;
+            case CMD_ROAM_WATCHDOG_TIMER:
+                s = "CMD_ROAM_WATCHDOG_TIMER";
+                break;
+            case CMD_SCREEN_STATE_CHANGED:
+                s = "CMD_SCREEN_STATE_CHANGED";
+                break;
+            case CMD_DISCONNECTING_WATCHDOG_TIMER:
+                s = "CMD_DISCONNECTING_WATCHDOG_TIMER";
+                break;
+            case CMD_TARGET_SSID:
+                s = "CMD_TARGET_SSID";
+                break;
+            default:
+                s = "what:" + Integer.toString(what);
+                break;
+        }
+        return s;
+    }
+
+    void registerConnected() {
+       if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
+           long now_ms = System.currentTimeMillis();
+           // We are switching away from this configuration,
+           // hence record the time we were connected last
+           WifiConfiguration config = mWifiConfigStore.getWifiConfiguration(mLastNetworkId);
+           if (config != null) {
+               config.lastConnected = System.currentTimeMillis();
+               config.autoJoinBailedDueToLowRssi = false;
+               config.setAutoJoinStatus(WifiConfiguration.AUTO_JOIN_ENABLED);
+               config.numConnectionFailures = 0;
+               config.numIpConfigFailures = 0;
+               config.numAuthFailures = 0;
+               config.numAssociation++;
+           }
+           mBadLinkspeedcount = 0;
+       }
+    }
+
+    void registerDisconnected() {
+        if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
+            long now_ms = System.currentTimeMillis();
+            // We are switching away from this configuration,
+            // hence record the time we were connected last
+            WifiConfiguration config = mWifiConfigStore.getWifiConfiguration(mLastNetworkId);
+            if (config != null) {
+                config.lastDisconnected = System.currentTimeMillis();
+            }
+        }
+    }
+
+    void noteWifiDisabledWhileAssociated() {
+        // We got disabled by user while we were associated, make note of it
+        int rssi = mWifiInfo.getRssi();
+        WifiConfiguration config = getCurrentWifiConfiguration();
+        if (getCurrentState() == mConnectedState
+                && rssi != WifiInfo.INVALID_RSSI
+                && config != null) {
+            boolean is24GHz = mWifiInfo.is24GHz();
+            boolean isBadRSSI = (is24GHz && rssi < mWifiConfigStore.thresholdBadRssi24)
+                    || (!is24GHz && rssi < mWifiConfigStore.thresholdBadRssi5);
+            boolean isLowRSSI = (is24GHz && rssi < mWifiConfigStore.thresholdLowRssi24)
+                    || (!is24GHz && mWifiInfo.getRssi() < mWifiConfigStore.thresholdLowRssi5);
+            boolean isHighRSSI = (is24GHz && rssi >= mWifiConfigStore.thresholdGoodRssi24)
+                    || (!is24GHz && mWifiInfo.getRssi() >= mWifiConfigStore.thresholdGoodRssi5);
+            if (isBadRSSI) {
+                // Take note that we got disabled while RSSI was Bad
+                config.numUserTriggeredWifiDisableLowRSSI++;
+            } else if (isLowRSSI) {
+                // Take note that we got disabled while RSSI was Low
+                config.numUserTriggeredWifiDisableBadRSSI++;
+            } else if (!isHighRSSI) {
+                // Take note that we got disabled while RSSI was Not high
+                config.numUserTriggeredWifiDisableNotHighRSSI++;
+            }
+        }
+    }
+
+    void setInternetAccessState(boolean enabled) {
+        WifiConfiguration config = getCurrentWifiConfiguration();
+        if (config != null) {
+            config.noInternetAccess = enabled;
+        }
+    }
+
+    WifiConfiguration getCurrentWifiConfiguration() {
+        if (mLastNetworkId == WifiConfiguration.INVALID_NETWORK_ID) {
+            return null;
+        }
+        return mWifiConfigStore.getWifiConfiguration(mLastNetworkId);
+    }
+
+    ScanResult getCurrentScanResult() {
+        WifiConfiguration config = getCurrentWifiConfiguration();
+        if (config == null) {
+            return null;
+        }
+        String BSSID = mWifiInfo.getBSSID();
+        if (BSSID == null) {
+            BSSID = mTargetRoamBSSID;
+        }
+        if (config.scanResultCache == null) {
+            return null;
+        }
+        return config.scanResultCache.get(BSSID);
+    }
+
+    String getCurrentBSSID() {
+        if (linkDebouncing) {
+            return null;
+        }
+        return mLastBssid;
+    }
+
+    class ConnectModeState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            WifiConfiguration config;
+            int netId;
+            boolean ok;
+            boolean didDisconnect;
+            String bssid;
+            String ssid;
+            NetworkUpdateResult result;
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                    didBlackListBSSID = false;
+                    bssid = (String) message.obj;
+                    if (bssid == null || TextUtils.isEmpty(bssid)) {
+                        // If BSSID is null, use the target roam BSSID
+                        bssid = mTargetRoamBSSID;
+                    }
+                    if (bssid != null) {
+                        // If we have a BSSID, tell configStore to black list it
+                        synchronized(mScanResultCache) {
+                            didBlackListBSSID = mWifiConfigStore.handleBSSIDBlackList
+                                    (mLastNetworkId, bssid, false);
+                        }
+                    }
+                    mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
+                    break;
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                    mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
+                    break;
+                case WifiMonitor.SSID_TEMP_DISABLED:
+                case WifiMonitor.SSID_REENABLED:
+                    String substr = (String) message.obj;
+                    String en = message.what == WifiMonitor.SSID_TEMP_DISABLED ?
+                            "temp-disabled" : "re-enabled";
+                    loge("ConnectModeState SSID state=" + en + " nid="
+                            + Integer.toString(message.arg1) + " [" + substr + "]");
+                    synchronized(mScanResultCache) {
+                        mWifiConfigStore.handleSSIDStateChange(message.arg1, message.what ==
+                                WifiMonitor.SSID_REENABLED, substr, mWifiInfo.getBSSID());
+                    }
+                    break;
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    SupplicantState state = handleSupplicantStateChange(message);
+                    // A driver/firmware hang can now put the interface in a down state.
+                    // We detect the interface going down and recover from it
+                    if (!SupplicantState.isDriverActive(state)) {
+                        if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
+                            handleNetworkDisconnect();
+                        }
+                        log("Detected an interface down, restart driver");
+                        transitionTo(mDriverStoppedState);
+                        sendMessage(CMD_START_DRIVER);
+                        break;
+                    }
+
+                    // Supplicant can fail to report a NETWORK_DISCONNECTION_EVENT
+                    // when authentication times out after a successful connection,
+                    // we can figure this from the supplicant state. If supplicant
+                    // state is DISCONNECTED, but the mNetworkInfo says we are not
+                    // disconnected, we need to handle a disconnection
+                    if (!linkDebouncing && state == SupplicantState.DISCONNECTED &&
+                            mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
+                        if (DBG) log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
+                        handleNetworkDisconnect();
+                        transitionTo(mDisconnectedState);
+                    }
+                    break;
+                case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
+                    if (message.arg1 == 1) {
+                        mWifiNative.disconnect();
+                        mTemporarilyDisconnectWifi = true;
+                    } else {
+                        mWifiNative.reconnect();
+                        mTemporarilyDisconnectWifi = false;
+                    }
+                    break;
+                case CMD_ADD_OR_UPDATE_NETWORK:
+                    config = (WifiConfiguration) message.obj;
+                    int res = mWifiConfigStore.addOrUpdateNetwork(config, message.sendingUid);
+                    if (res < 0) {
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                    } else {
+                        WifiConfiguration curConfig = getCurrentWifiConfiguration();
+                        if (curConfig != null && config != null) {
+                            if (curConfig.priority < config.priority
+                                    && config.status == WifiConfiguration.Status.ENABLED) {
+                                // Interpret this as a connect attempt
+                                // Set the last selected configuration so as to allow the system to
+                                // stick the last user choice without persisting the choice
+                                mWifiConfigStore.setLastSelectedConfiguration(res);
+
+                                // Remember time of last connection attempt
+                                lastConnectAttempt = System.currentTimeMillis();
+
+                                mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
+
+                                // As a courtesy to the caller, trigger a scan now
+                                startScan(ADD_OR_UPDATE_SOURCE, 0, null, null);
+                            }
+                        }
+                    }
+                    replyToMessage(message, CMD_ADD_OR_UPDATE_NETWORK, res);
+                    break;
+                case CMD_REMOVE_NETWORK:
+                    ok = mWifiConfigStore.removeNetwork(message.arg1);
+                    if (!ok) {
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                    }
+                    replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
+                    break;
+                case CMD_ENABLE_NETWORK:
+                    boolean others = message.arg2 == 1;
+                    // Tell autojoin the user did try to select to that network
+                    // However, do NOT persist the choice by bumping the priority of the network
+                    if (others) {
+                        mWifiAutoJoinController.
+                                updateConfigurationHistory(message.arg1, true, false);
+                        // Set the last selected configuration so as to allow the system to
+                        // stick the last user choice without persisting the choice
+                        mWifiConfigStore.setLastSelectedConfiguration(message.arg1);
+
+                        // Remember time of last connection attempt
+                        lastConnectAttempt = System.currentTimeMillis();
+
+                        mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
+                    }
+                    // Cancel auto roam requests
+                    autoRoamSetBSSID(message.arg1, "any");
+
+                    ok = mWifiConfigStore.enableNetwork(message.arg1, message.arg2 == 1);
+                    if (!ok) {
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                    }
+                    replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
+                    break;
+                case CMD_ENABLE_ALL_NETWORKS:
+                    long time = android.os.SystemClock.elapsedRealtime();
+                    if (time - mLastEnableAllNetworksTime > MIN_INTERVAL_ENABLE_ALL_NETWORKS_MS) {
+                        mWifiConfigStore.enableAllNetworks();
+                        mLastEnableAllNetworksTime = time;
+                    }
+                    break;
+                case WifiManagerWAP.DISABLE_NETWORK:
+                    if (mWifiConfigStore.disableNetwork(message.arg1,
+                            WifiConfiguration.DISABLED_BY_WIFI_MANAGER) == true) {
+                        replyToMessage(message, WifiManagerWAP.DISABLE_NETWORK_SUCCEEDED);
+                    } else {
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                        replyToMessage(message, WifiManagerWAP.DISABLE_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                    }
+                    break;
+                case CMD_BLACKLIST_NETWORK:
+                    mWifiNative.addToBlacklist((String) message.obj);
+                    break;
+                case CMD_CLEAR_BLACKLIST:
+                    mWifiNative.clearBlacklist();
+                    break;
+                case CMD_SAVE_CONFIG:
+                    ok = mWifiConfigStore.saveConfig();
+
+                    if (DBG) loge("wifistatemachine did save config " + ok);
+                    replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
+
+                    // Inform the backup manager about a data change
+                    IBackupManager ibm = IBackupManager.Stub.asInterface(
+                            ServiceManager.getService(Context.BACKUP_SERVICE));
+                    if (ibm != null) {
+                        try {
+                            ibm.dataChanged("com.android.providers.settings");
+                        } catch (Exception e) {
+                            // Try again later
+                        }
+                    }
+                    break;
+                case CMD_GET_CONFIGURED_NETWORKS:
+                    replyToMessage(message, message.what,
+                            mWifiConfigStore.getConfiguredNetworks());
+                    break;
+                case WifiMonitor.SUP_REQUEST_IDENTITY:
+                    // Supplicant lacks credentials to connect to that network, hence black list
+                    ssid = (String) message.obj;
+
+                    if (targetWificonfiguration != null && ssid != null
+                            && targetWificonfiguration.SSID != null
+                            && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
+                        mWifiConfigStore.handleSSIDStateChange(targetWificonfiguration.networkId,
+                                false, "AUTH_FAILED no identity", null);
+                    }
+                    // Disconnect now, as we don't have any way to fullfill the  supplicant request.
+                    mWifiConfigStore.setLastSelectedConfiguration
+                            (WifiConfiguration.INVALID_NETWORK_ID);
+                    mWifiNative.disconnect();
+                    break;
+                case WifiMonitor.SUP_REQUEST_SIM_AUTH:
+                    logd("Received SUP_REQUEST_SIM_AUTH");
+                    SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
+                    if (requestData != null) {
+                        if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
+                            handleGsmAuthRequest(requestData);
+                        } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA) {
+                            handle3GAuthRequest(requestData);
+                        }
+                    } else {
+                        loge("Invalid sim auth request");
+                    }
+                    break;
+                case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
+                    replyToMessage(message, message.what,
+                            mWifiConfigStore.getPrivilegedConfiguredNetworks());
+                    break;
+                    /* Do a redundant disconnect without transition */
+                case CMD_DISCONNECT:
+                    mWifiConfigStore.setLastSelectedConfiguration
+                            (WifiConfiguration.INVALID_NETWORK_ID);
+                    mWifiNative.disconnect();
+                    break;
+                case CMD_RECONNECT:
+                    lastConnectAttempt = System.currentTimeMillis();
+                    mWifiNative.reconnect();
+                    break;
+                case CMD_REASSOCIATE:
+                    lastConnectAttempt = System.currentTimeMillis();
+                    mWifiNative.reassociate();
+                    break;
+                case CMD_RELOAD_TLS_AND_RECONNECT:
+                    if (mWifiConfigStore.needsUnlockedKeyStore()) {
+                        logd("Reconnecting to give a chance to un-connected TLS networks");
+                        mWifiNative.disconnect();
+                        lastConnectAttempt = System.currentTimeMillis();
+                        mWifiNative.reconnect();
+                    }
+                    break;
+                case CMD_AUTO_ROAM:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    return HANDLED;
+                case CMD_AUTO_CONNECT:
+                    /* Work Around: wpa_supplicant can get in a bad state where it returns a non
+                     * associated status to the STATUS command but somehow-someplace still thinks
+                     * it is associated and thus will ignore select/reconnect command with
+                     * following message:
+                     * "Already associated with the selected network - do nothing"
+                     *
+                     * Hence, sends a disconnect to supplicant first.
+                     */
+                    didDisconnect = false;
+                    if (getCurrentState() != mDisconnectedState) {
+                        /** Supplicant will ignore the reconnect if we are currently associated,
+                         * hence trigger a disconnect
+                         */
+                        didDisconnect = true;
+                        mWifiNative.disconnect();
+                    }
+
+                    /* connect command coming from auto-join */
+                    config = (WifiConfiguration) message.obj;
+                    netId = message.arg1;
+                    int roam = message.arg2;
+                    loge("CMD_AUTO_CONNECT sup state "
+                            + mSupplicantStateTracker.getSupplicantStateName()
+                            + " my state " + getCurrentState().getName()
+                            + " nid=" + Integer.toString(netId)
+                            + " roam=" + Integer.toString(roam));
+                    if (config == null) {
+                        loge("AUTO_CONNECT and no config, bail out...");
+                        break;
+                    }
+
+                    /* Make sure we cancel any previous roam request */
+                    autoRoamSetBSSID(netId, config.BSSID);
+
+                    /* Save the network config */
+                    loge("CMD_AUTO_CONNECT will save config -> " + config.SSID
+                            + " nid=" + Integer.toString(netId));
+                    result = mWifiConfigStore.saveNetwork(config, -1);
+                    netId = result.getNetworkId();
+                    loge("CMD_AUTO_CONNECT did save config -> "
+                            + " nid=" + Integer.toString(netId));
+
+                    // Make sure the network is enabled, since supplicant will not reenable it
+                    mWifiConfigStore.enableNetworkWithoutBroadcast(netId, false);
+
+                    if (mWifiConfigStore.selectNetwork(netId) &&
+                            mWifiNative.reconnect()) {
+                        lastConnectAttempt = System.currentTimeMillis();
+                        targetWificonfiguration = mWifiConfigStore.getWifiConfiguration(netId);
+                        // We selected a better config,
+                        // maybe because we could not see the last user
+                        // selection, then forget it. We will remember the selection
+                        // only if it was persisted.
+                        mWifiConfigStore.
+                                setLastSelectedConfiguration(WifiConfiguration.INVALID_NETWORK_ID);
+
+                        mAutoRoaming = roam;
+                        if (isRoaming() || linkDebouncing) {
+                            transitionTo(mRoamingState);
+                        } else if (didDisconnect) {
+                            transitionTo(mDisconnectingState);
+                        } else {
+                            transitionTo(mDisconnectedState);
+                        }
+                    } else {
+                        loge("Failed to connect config: " + config + " netId: " + netId);
+                        replyToMessage(message, WifiManagerWAP.CONNECT_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                        break;
+                    }
+                    break;
+                case WifiManagerWAP.CONNECT_NETWORK:
+                    /**
+                     *  The connect message can contain a network id passed as arg1 on message or
+                     * or a config passed as obj on message.
+                     * For a new network, a config is passed to create and connect.
+                     * For an existing network, a network id is passed
+                     */
+                    netId = message.arg1;
+                    config = (WifiConfiguration) message.obj;
+                    mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
+
+                    /* Save the network config */
+                    if (config != null) {
+                        result = mWifiConfigStore.saveNetwork(config, message.sendingUid);
+                        netId = result.getNetworkId();
+                    }
+                    config = mWifiConfigStore.getWifiConfiguration(netId);
+
+                    if (config == null) {
+                        loge("CONNECT_NETWORK id=" + Integer.toString(netId) + " "
+                                + mSupplicantStateTracker.getSupplicantStateName() + " my state "
+                                + getCurrentState().getName());
+                    } else {
+                        String wasSkipped = config.autoJoinBailedDueToLowRssi ? " skipped" : "";
+                        loge("CONNECT_NETWORK id=" + Integer.toString(netId)
+                                + " config=" + config.SSID
+                                + " cnid=" + config.networkId
+                                + " supstate=" + mSupplicantStateTracker.getSupplicantStateName()
+                                + " my state " + getCurrentState().getName()
+                                + " uid = " + message.sendingUid
+                                + wasSkipped);
+                    }
+
+                    autoRoamSetBSSID(netId, "any");
+
+                    if (message.sendingUid == Process.WIFI_UID
+                        || message.sendingUid == Process.SYSTEM_UID) {
+                        // As a sanity measure, clear the BSSID in the supplicant network block.
+                        // If system or Wifi Settings want to connect, they will not
+                        // specify the BSSID.
+                        // If an app however had added a BSSID to this configuration, and the BSSID
+                        // was wrong, Then we would forever fail to connect until that BSSID
+                        // is cleaned up.
+                        clearConfigBSSID(config, "CONNECT_NETWORK");
+                    }
+
+                    mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+
+                    /* Tell autojoin the user did try to connect to that network */
+                    mWifiAutoJoinController.updateConfigurationHistory(netId, true, true);
+
+                    mWifiConfigStore.setLastSelectedConfiguration(netId);
+
+                    didDisconnect = false;
+                    if (mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID
+                            && mLastNetworkId != netId) {
+                        /** Supplicant will ignore the reconnect if we are currently associated,
+                         * hence trigger a disconnect
+                         */
+                        didDisconnect = true;
+                        mWifiNative.disconnect();
+                    }
+
+                    // Make sure the network is enabled, since supplicant will not reenable it
+                    mWifiConfigStore.enableNetworkWithoutBroadcast(netId, false);
+
+                    if (mWifiConfigStore.selectNetwork(netId) &&
+                            mWifiNative.reconnect()) {
+                        lastConnectAttempt = System.currentTimeMillis();
+                        targetWificonfiguration = mWifiConfigStore.getWifiConfiguration(netId);
+
+                        /* The state tracker handles enabling networks upon completion/failure */
+                        mSupplicantStateTracker.sendMessage(WifiManagerWAP.CONNECT_NETWORK);
+                        replyToMessage(message, WifiManagerWAP.CONNECT_NETWORK_SUCCEEDED);
+                        if (didDisconnect) {
+                            /* Expect a disconnection from the old connection */
+                            transitionTo(mDisconnectingState);
+                        } else {
+                            /**
+                             *  Directly go to disconnected state where we
+                             * process the connection events from supplicant
+                             **/
+                            transitionTo(mDisconnectedState);
+                        }
+                    } else {
+                        loge("Failed to connect config: " + config + " netId: " + netId);
+                        replyToMessage(message, WifiManagerWAP.CONNECT_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                        break;
+                    }
+                    break;
+                case WifiManagerWAP.SAVE_NETWORK:
+                    mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
+                    // Fall thru
+                case WifiStateMachineWAP.CMD_AUTO_SAVE_NETWORK:
+                    lastSavedConfigurationAttempt = null; // Used for debug
+                    config = (WifiConfiguration) message.obj;
+                    if (config == null) {
+                        loge("ERROR: SAVE_NETWORK with null configuration"
+                                + mSupplicantStateTracker.getSupplicantStateName()
+                                + " my state " + getCurrentState().getName());
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                        replyToMessage(message, WifiManagerWAP.SAVE_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                        break;
+                    }
+                    lastSavedConfigurationAttempt = new WifiConfiguration(config);
+                    int nid = config.networkId;
+                    loge("SAVE_NETWORK id=" + Integer.toString(nid)
+                                + " config=" + config.SSID
+                                + " nid=" + config.networkId
+                                + " supstate=" + mSupplicantStateTracker.getSupplicantStateName()
+                                + " my state " + getCurrentState().getName());
+
+                    result = mWifiConfigStore.saveNetwork(config, -1);
+                    if (result.getNetworkId() != WifiConfiguration.INVALID_NETWORK_ID) {
+                        if (mWifiInfo.getNetworkId() == result.getNetworkId()) {
+                            if (result.hasIpChanged()) {
+                                // The currently connection configuration was changed
+                                // We switched from DHCP to static or from static to DHCP, or the
+                                // static IP address has changed.
+                                log("Reconfiguring IP on connection");
+                                // TODO: clear addresses and disable IPv6
+                                // to simplify obtainingIpState.
+                                transitionTo(mObtainingIpState);
+                            }
+                            if (result.hasProxyChanged()) {
+                                log("Reconfiguring proxy on connection");
+                                updateLinkProperties(CMD_UPDATE_LINKPROPERTIES,
+                                        mNetlinkTracker.getLinkProperties());
+                            }
+                        }
+                        replyToMessage(message, WifiManagerWAP.SAVE_NETWORK_SUCCEEDED);
+                        if (VDBG) {
+                           loge("Success save network nid="
+                                        + Integer.toString(result.getNetworkId()));
+                        }
+
+                        synchronized(mScanResultCache) {
+                            /**
+                             * If the command comes from WifiManager, then
+                             * tell autojoin the user did try to modify and save that network,
+                             * and interpret the SAVE_NETWORK as a request to connect
+                             */
+                            boolean user = message.what == WifiManagerWAP.SAVE_NETWORK;
+                            mWifiAutoJoinController.updateConfigurationHistory(result.getNetworkId()
+                                    , user, true);
+                            mWifiAutoJoinController.attemptAutoJoin();
+                        }
+                    } else {
+                        loge("Failed to save network");
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                        replyToMessage(message, WifiManagerWAP.SAVE_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                    }
+                    break;
+                case WifiManagerWAP.FORGET_NETWORK:
+                    // Debug only, remember last configuration that was forgotten
+                    WifiConfiguration toRemove
+                            = mWifiConfigStore.getWifiConfiguration(message.arg1);
+                    if (toRemove == null) {
+                        lastForgetConfigurationAttempt = null;
+                    } else {
+                        lastForgetConfigurationAttempt = new WifiConfiguration(toRemove);
+                    }
+                    if (mWifiConfigStore.forgetNetwork(message.arg1)) {
+                        replyToMessage(message, WifiManagerWAP.FORGET_NETWORK_SUCCEEDED);
+                    } else {
+                        loge("Failed to forget network");
+                        replyToMessage(message, WifiManagerWAP.FORGET_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                    }
+                    break;
+                case WifiManagerWAP.START_WPS:
+                    WpsInfo wpsInfo = (WpsInfo) message.obj;
+                    WpsResult wpsResult;
+                    switch (wpsInfo.setup) {
+                        case WpsInfo.PBC:
+                            wpsResult = mWifiConfigStore.startWpsPbc(wpsInfo);
+                            break;
+                        case WpsInfo.KEYPAD:
+                            wpsResult = mWifiConfigStore.startWpsWithPinFromAccessPoint(wpsInfo);
+                            break;
+                        case WpsInfo.DISPLAY:
+                            wpsResult = mWifiConfigStore.startWpsWithPinFromDevice(wpsInfo);
+                            break;
+                        default:
+                            wpsResult = new WpsResult(Status.FAILURE);
+                            loge("Invalid setup for WPS");
+                            break;
+                    }
+                    mWifiConfigStore.setLastSelectedConfiguration
+                            (WifiConfiguration.INVALID_NETWORK_ID);
+                    if (wpsResult.status == Status.SUCCESS) {
+                        replyToMessage(message, WifiManagerWAP.START_WPS_SUCCEEDED, wpsResult);
+                        transitionTo(mWpsRunningState);
+                    } else {
+                        loge("Failed to start WPS with config " + wpsInfo.toString());
+                        replyToMessage(message, WifiManagerWAP.WPS_FAILED, WifiManagerWAP.ERROR);
+                    }
+                    break;
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                    if (DBG) log("Network connection established");
+                    mLastNetworkId = message.arg1;
+                    mLastBssid = (String) message.obj;
+
+                    mWifiInfo.setBSSID(mLastBssid);
+                    mWifiInfo.setNetworkId(mLastNetworkId);
+                    // Send event to CM & network change broadcast
+                    setNetworkDetailedState(DetailedState.OBTAINING_IPADDR);
+                    sendNetworkStateChangeBroadcast(mLastBssid);
+                    transitionTo(mObtainingIpState);
+                    break;
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                    // Calling handleNetworkDisconnect here is redundant because we might already
+                    // have called it when leaving L2ConnectedState to go to disconnecting state
+                    // or thru other path
+                    // We should normally check the mWifiInfo or mLastNetworkId so as to check
+                    // if they are valid, and only in this case call handleNEtworkDisconnect,
+                    // TODO: this should be fixed for a L MR release
+                    // The side effect of calling handleNetworkDisconnect twice is that a bunch of
+                    // idempotent commands are executed twice (stopping Dhcp, enabling the SPS mode
+                    // at the chip etc...
+                    if (DBG) log("ConnectModeState: Network connection lost ");
+                    handleNetworkDisconnect();
+                    transitionTo(mDisconnectedState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private class WifiNetworkAgent extends NetworkAgent {
+        public WifiNetworkAgent(Looper l, Context c, String TAG, NetworkInfo ni,
+                NetworkCapabilities nc, LinkProperties lp, int score) {
+            super(l, c, TAG, ni, nc, lp, score);
+        }
+        protected void unwanted() {
+            // Ignore if we're not the current networkAgent.
+            if (this != mNetworkAgent) return;
+            if (DBG) log("WifiNetworkAgent -> Wifi unwanted score "
+                    + Integer.toString(mWifiInfo.score));
+            unwantedNetwork(network_status_unwanted_disconnect);
+        }
+
+        protected void networkStatus(int status) {
+            if (status == NetworkAgent.INVALID_NETWORK) {
+                if (DBG) log("WifiNetworkAgent -> Wifi networkStatus invalid score "
+                        + Integer.toString(mWifiInfo.score));
+                unwantedNetwork(network_status_unwanted_disable_autojoin);
+            }
+        }
+    }
+
+    void unwantedNetwork(int reason) {
+        sendMessage(CMD_UNWANTED_NETWORK, reason);
+    }
+
+
+    boolean startScanForConfiguration(WifiConfiguration config, boolean restrictChannelList) {
+        if (config == null)
+            return false;
+
+        // We are still seeing a fairly high power consumption triggered by autojoin scans
+        // Hence do partial scans only for PSK configuration that are roamable since the
+        // primary purpose of the partial scans is roaming.
+        // Full badn scans with exponential backoff for the purpose or extended roaming and
+        // network switching are performed unconditionally.
+        if (config.scanResultCache == null
+                || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)
+                || config.scanResultCache.size() > 6) {
+            //return true but to not trigger the scan
+            return true;
+        }
+        HashSet<Integer> channels
+                = mWifiConfigStore.makeChannelList(config,
+                ONE_HOUR_MILLI, restrictChannelList);
+        if (channels != null && channels.size() != 0) {
+            StringBuilder freqs = new StringBuilder();
+            boolean first = true;
+            for (Integer channel : channels) {
+                if (!first)
+                    freqs.append(",");
+                freqs.append(channel.toString());
+                first = false;
+            }
+            //if (DBG) {
+            loge("WifiStateMachineWAP starting scan for " + config.configKey() + " with " + freqs);
+            //}
+            // Call wifi native to start the scan
+            if (startScanNative(
+                    WifiNative.SCAN_WITHOUT_CONNECTION_SETUP,
+                    freqs.toString())) {
+                // Only count battery consumption if scan request is accepted
+                noteScanStart(SCAN_ALARM_SOURCE, null);
+                messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
+            } else {
+                // used for debug only, mark scan as failed
+                messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
+            }
+            return true;
+        } else {
+            if (DBG) loge("WifiStateMachineWAP no channels for " + config.configKey());
+            return false;
+        }
+    }
+
+    void clearCurrentConfigBSSID(String dbg) {
+        // Clear the bssid in the current config's network block
+        WifiConfiguration config = getCurrentWifiConfiguration();
+        if (config == null)
+            return;
+        clearConfigBSSID(config, dbg);
+    }
+    void clearConfigBSSID(WifiConfiguration config, String dbg) {
+        if (config == null)
+            return;
+        if (DBG) {
+            loge(dbg + " " + mTargetRoamBSSID + " config " + config.configKey()
+                    + " config.bssid " + config.BSSID);
+        }
+        config.autoJoinBSSID = "any";
+
+        // If an app specified a BSSID then dont over-write it
+        if ( !mWifiAutoJoinController.isBlacklistedBSSID(config.BSSID) ) {
+            config.BSSID = "any";
+        }
+
+        if (DBG) {
+           loge(dbg + " " + config.SSID
+                    + " nid=" + Integer.toString(config.networkId));
+        }
+        mWifiConfigStore.saveWifiConfigBSSID(config);
+    }
+
+    class L2ConnectedState extends State {
+        @Override
+        public void enter() {
+            mRssiPollToken++;
+            if (mEnableRssiPolling) {
+                sendMessage(CMD_RSSI_POLL, mRssiPollToken, 0);
+            }
+            if (mNetworkAgent != null) {
+                loge("Have NetworkAgent when entering L2Connected");
+                setNetworkDetailedState(DetailedState.DISCONNECTED);
+            }
+            setNetworkDetailedState(DetailedState.CONNECTING);
+
+            if (TextUtils.isEmpty(mTcpBufferSizes) == false) {
+                mLinkProperties.setTcpBufferSizes(mTcpBufferSizes);
+            }
+            mNetworkAgent = new WifiNetworkAgent(getHandler().getLooper(), mContext,
+                    "WifiNetworkAgent", mNetworkInfo, mNetworkCapabilitiesFilter,
+                    mLinkProperties, DEFAULT_SCORE);
+
+            // We must clear the config BSSID, as the wifi chipset may decide to roam
+            // from this point on and having the BSSID specified in the network block would
+            // cause the roam to faile and the device to disconnect
+            clearCurrentConfigBSSID("L2ConnectedState");
+        }
+
+        @Override
+        public void exit() {
+            // This is handled by receiving a NETWORK_DISCONNECTION_EVENT in ConnectModeState
+            // Bug: 15347363
+            // For paranoia's sake, call handleNetworkDisconnect
+            // only if BSSID is null or last networkId
+            // is not invalid.
+            if (DBG) {
+                StringBuilder sb = new StringBuilder();
+                sb.append("leaving L2ConnectedState state nid=" + Integer.toString(mLastNetworkId));
+                if (mLastBssid !=null) {
+                    sb.append(" ").append(mLastBssid);
+                }
+            }
+            if (mLastBssid != null || mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
+                handleNetworkDisconnect();
+            }
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+              case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
+                  handlePreDhcpSetup();
+                  break;
+              case DhcpStateMachine.CMD_POST_DHCP_ACTION:
+                  handlePostDhcpSetup();
+                  if (message.arg1 == DhcpStateMachine.DHCP_SUCCESS) {
+                      if (DBG) log("WifiStateMachineWAP DHCP successful");
+                      handleIPv4Success((DhcpResults) message.obj, DhcpStateMachine.DHCP_SUCCESS);
+                      // We advance to mVerifyingLinkState because handleIPv4Success will call
+                      // updateLinkProperties, which then sends CMD_IP_CONFIGURATION_SUCCESSFUL.
+                  } else if (message.arg1 == DhcpStateMachine.DHCP_FAILURE) {
+                      if (DBG) {
+                          int count = -1;
+                          WifiConfiguration config = getCurrentWifiConfiguration();
+                          if (config != null) {
+                              count = config.numConnectionFailures;
+                          }
+                          log("WifiStateMachineWAP DHCP failure count=" + count);
+                      }
+                      handleIPv4Failure(DhcpStateMachine.DHCP_FAILURE);
+                      // As above, we transition to mDisconnectingState via updateLinkProperties.
+                  }
+                  break;
+                case CMD_IP_CONFIGURATION_SUCCESSFUL:
+                    handleSuccessfulIpConfiguration();
+                    sendConnectedState();
+                    transitionTo(mConnectedState);
+                    break;
+                case CMD_IP_CONFIGURATION_LOST:
+                    handleIpConfigurationLost();
+                    transitionTo(mDisconnectingState);
+                    break;
+                case CMD_DISCONNECT:
+                    mWifiNative.disconnect();
+                    transitionTo(mDisconnectingState);
+                    break;
+                case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
+                    if (message.arg1 == 1) {
+                        mWifiNative.disconnect();
+                        mTemporarilyDisconnectWifi = true;
+                        transitionTo(mDisconnectingState);
+                    }
+                    break;
+                case CMD_SET_OPERATIONAL_MODE:
+                    if (message.arg1 != CONNECT_MODE) {
+                        sendMessage(CMD_DISCONNECT);
+                        deferMessage(message);
+                        if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
+                            noteWifiDisabledWhileAssociated();
+                        }
+                    }
+                    break;
+                case CMD_SET_COUNTRY_CODE:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                    deferMessage(message);
+                    break;
+                case CMD_START_SCAN:
+                    if (!isScanAllowed(message.arg1)) {
+                        // Ignore the scan request
+                        if (VDBG) logd("L2ConnectedState: ignore scan");
+                        return HANDLED;
+                    }
+                    //if (DBG) {
+                        loge("WifiStateMachineWAP CMD_START_SCAN source " + message.arg1
+                              + " txSuccessRate="+String.format( "%.2f", mWifiInfo.txSuccessRate)
+                              + " rxSuccessRate="+String.format( "%.2f", mWifiInfo.rxSuccessRate)
+                              + " targetRoamBSSID=" + mTargetRoamBSSID
+                              + " RSSI=" + mWifiInfo.getRssi());
+                    //}
+                    if (message.arg1 == SCAN_ALARM_SOURCE) {
+                        boolean tryFullBandScan = false;
+                        boolean restrictChannelList = false;
+                        long now_ms = System.currentTimeMillis();
+                        if (DBG) {
+                            loge("WifiStateMachineWAP CMD_START_SCAN with age="
+                                    + Long.toString(now_ms - lastFullBandConnectedTimeMilli)
+                                    + " interval=" + fullBandConnectedTimeIntervalMilli
+                                    + " maxinterval=" + maxFullBandConnectedTimeIntervalMilli);
+                        }
+                        if (mWifiInfo != null) {
+                            if (mWifiConfigStore.enableFullBandScanWhenAssociated &&
+                                    (now_ms - lastFullBandConnectedTimeMilli)
+                                    > fullBandConnectedTimeIntervalMilli) {
+                                if (DBG) {
+                                    loge("WifiStateMachineWAP CMD_START_SCAN try full band scan age="
+                                         + Long.toString(now_ms - lastFullBandConnectedTimeMilli)
+                                         + " interval=" + fullBandConnectedTimeIntervalMilli
+                                         + " maxinterval=" + maxFullBandConnectedTimeIntervalMilli);
+                                }
+                                tryFullBandScan = true;
+                            }
+
+                            if (mWifiInfo.txSuccessRate >
+                                    mWifiConfigStore.maxTxPacketForFullScans
+                                    || mWifiInfo.rxSuccessRate >
+                                    mWifiConfigStore.maxRxPacketForFullScans) {
+                                // Too much traffic at the interface, hence no full band scan
+                                if (DBG) {
+                                    loge("WifiStateMachineWAP CMD_START_SCAN " +
+                                            "prevent full band scan due to pkt rate");
+                                }
+                                tryFullBandScan = false;
+                            }
+
+                            if (mWifiInfo.txSuccessRate >
+                                    mWifiConfigStore.maxTxPacketForPartialScans
+                                    || mWifiInfo.rxSuccessRate >
+                                    mWifiConfigStore.maxRxPacketForPartialScans) {
+                                // Don't scan if lots of packets are being sent
+                                restrictChannelList = true;
+                                if (mWifiConfigStore.alwaysEnableScansWhileAssociated == 0) {
+                                    if (DBG) {
+                                     loge("WifiStateMachineWAP CMD_START_SCAN source " + message.arg1
+                                        + " ...and ignore scans"
+                                        + " tx=" + String.format("%.2f", mWifiInfo.txSuccessRate)
+                                        + " rx=" + String.format("%.2f", mWifiInfo.rxSuccessRate));
+                                    }
+                                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
+                                    return HANDLED;
+                                }
+                            }
+                        }
+
+                        WifiConfiguration currentConfiguration = getCurrentWifiConfiguration();
+                        if (DBG) {
+                            loge("WifiStateMachineWAP CMD_START_SCAN full=" +
+                                    tryFullBandScan);
+                        }
+                        if (currentConfiguration != null) {
+                            if (fullBandConnectedTimeIntervalMilli
+                                    < mWifiConfigStore.associatedPartialScanPeriodMilli) {
+                                // Sanity
+                                fullBandConnectedTimeIntervalMilli
+                                        = mWifiConfigStore.associatedPartialScanPeriodMilli;
+                            }
+                            if (tryFullBandScan) {
+                                lastFullBandConnectedTimeMilli = now_ms;
+                                if (fullBandConnectedTimeIntervalMilli
+                                        < mWifiConfigStore.associatedFullScanMaxIntervalMilli) {
+                                    // Increase the interval
+                                    fullBandConnectedTimeIntervalMilli
+                                            = fullBandConnectedTimeIntervalMilli
+                                            * mWifiConfigStore.associatedFullScanBackoff / 8;
+
+                                    if (DBG) {
+                                        loge("WifiStateMachineWAP CMD_START_SCAN bump interval ="
+                                        + fullBandConnectedTimeIntervalMilli);
+                                    }
+                                }
+                                handleScanRequest(
+                                        WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, message);
+                            } else {
+                                if (!startScanForConfiguration(
+                                        currentConfiguration, restrictChannelList)) {
+                                    if (DBG) {
+                                        loge("WifiStateMachineWAP starting scan, " +
+                                                " did not find channels -> full");
+                                    }
+                                    lastFullBandConnectedTimeMilli = now_ms;
+                                    if (fullBandConnectedTimeIntervalMilli
+                                            < mWifiConfigStore.associatedFullScanMaxIntervalMilli) {
+                                        // Increase the interval
+                                        fullBandConnectedTimeIntervalMilli
+                                                = fullBandConnectedTimeIntervalMilli
+                                                * mWifiConfigStore.associatedFullScanBackoff / 8;
+
+                                        if (DBG) {
+                                            loge("WifiStateMachineWAP CMD_START_SCAN bump interval ="
+                                                    + fullBandConnectedTimeIntervalMilli);
+                                        }
+                                    }
+                                    handleScanRequest(
+                                                WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, message);
+                                }
+                            }
+                        } else {
+                            loge("CMD_START_SCAN : connected mode and no configuration");
+                            messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
+                        }
+                    } else {
+                        // Not scan alarm source
+                        handleScanRequest(WifiNative.SCAN_WITHOUT_CONNECTION_SETUP, message);
+                    }
+                    break;
+                    /* Ignore connection to same network */
+                case WifiManagerWAP.CONNECT_NETWORK:
+                    int netId = message.arg1;
+                    if (mWifiInfo.getNetworkId() == netId) {
+                        break;
+                    }
+                    return NOT_HANDLED;
+                    /* Ignore */
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                    break;
+                case CMD_RSSI_POLL:
+                    if (message.arg1 == mRssiPollToken) {
+                        if (mWifiConfigStore.enableChipWakeUpWhenAssociated) {
+                            if (VVDBG) log(" get link layer stats " + mWifiLinkLayerStatsSupported);
+                            WifiLinkLayerStats stats = getWifiLinkLayerStats(VDBG);
+                            if (stats != null) {
+                                // Sanity check the results provided by driver
+                                if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI
+                                        && (stats.rssi_mgmt == 0
+                                        || stats.beacon_rx == 0)) {
+                                    stats = null;
+                                }
+                            }
+                            // Get Info and continue polling
+                            fetchRssiLinkSpeedAndFrequencyNative();
+                            calculateWifiScore(stats);
+                        }
+                        sendMessageDelayed(obtainMessage(CMD_RSSI_POLL,
+                                mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
+
+                        if (DBG) sendRssiChangeBroadcast(mWifiInfo.getRssi());
+                    } else {
+                        // Polling has completed
+                    }
+                    break;
+                case CMD_ENABLE_RSSI_POLL:
+                    if (mWifiConfigStore.enableRssiPollWhenAssociated) {
+                        mEnableRssiPolling = (message.arg1 == 1);
+                    } else {
+                        mEnableRssiPolling = false;
+                    }
+                    mRssiPollToken++;
+                    if (mEnableRssiPolling) {
+                        // First poll
+                        fetchRssiLinkSpeedAndFrequencyNative();
+                        sendMessageDelayed(obtainMessage(CMD_RSSI_POLL,
+                                mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
+                    } else {
+                        cleanWifiScore();
+                    }
+                    break;
+                case WifiManagerWAP.RSSI_PKTCNT_FETCH:
+                    RssiPacketCountInfo info = new RssiPacketCountInfo();
+                    fetchRssiLinkSpeedAndFrequencyNative();
+                    info.rssi = mWifiInfo.getRssi();
+                    fetchPktcntNative(info);
+                    replyToMessage(message, WifiManagerWAP.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
+                    break;
+                case CMD_DELAYED_NETWORK_DISCONNECT:
+                    if (!linkDebouncing && mWifiConfigStore.enableLinkDebouncing) {
+
+                        // Ignore if we are not debouncing
+                        loge("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore "
+                                + message.arg1);
+                        return HANDLED;
+                    } else {
+                        loge("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect "
+                                + message.arg1);
+
+                        linkDebouncing = false;
+                        // If we are still debouncing while this message comes,
+                        // it means we were not able to reconnect within the alloted time
+                        // = LINK_FLAPPING_DEBOUNCE_MSEC
+                        // and thus, trigger a real disconnect
+                        handleNetworkDisconnect();
+                        transitionTo(mDisconnectedState);
+                    }
+                    break;
+                case CMD_ASSOCIATED_BSSID:
+                    if ((String) message.obj == null) {
+                        loge("Associated command w/o BSSID");
+                        break;
+                    }
+                    mLastBssid = (String) message.obj;
+                    mWifiInfo.setBSSID((String) message.obj);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+
+            return HANDLED;
+        }
+    }
+
+    class ObtainingIpState extends State {
+        @Override
+        public void enter() {
+            if (DBG) {
+                String key = "";
+                if (getCurrentWifiConfiguration() != null) {
+                    key = getCurrentWifiConfiguration().configKey();
+                }
+                log("enter ObtainingIpState netId=" + Integer.toString(mLastNetworkId)
+                        + " " + key + " "
+                        + " roam=" + mAutoRoaming
+                        + " static=" + mWifiConfigStore.isUsingStaticIp(mLastNetworkId)
+                        + " watchdog= " + obtainingIpWatchdogCount);
+            }
+
+            // Reset link Debouncing, indicating we have successfully re-connected to the AP
+            // We might still be roaming
+            linkDebouncing = false;
+
+            // We must clear the config BSSID, as the wifi chipset may decide to roam
+            // from this point on and having the BSSID specified in the network block would
+            // cause the roam to faile and the device to disconnect
+            clearCurrentConfigBSSID("ObtainingIpAddress");
+
+            try {
+                mNwService.enableIpv6(mInterfaceName);
+            } catch (RemoteException re) {
+                loge("Failed to enable IPv6: " + re);
+            } catch (IllegalStateException e) {
+                loge("Failed to enable IPv6: " + e);
+            }
+
+            if (!mWifiConfigStore.isUsingStaticIp(mLastNetworkId)) {
+                if (isRoaming()) {
+                    renewDhcp();
+                } else {
+                    // Remove any IP address on the interface in case we're switching from static
+                    // IP configuration to DHCP. This is safe because if we get here when not
+                    // roaming, we don't have a usable address.
+                    clearIPv4Address(mInterfaceName);
+                    startDhcp();
+                }
+                obtainingIpWatchdogCount++;
+                loge("Start Dhcp Watchdog " + obtainingIpWatchdogCount);
+                sendMessageDelayed(obtainMessage(CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER,
+                        obtainingIpWatchdogCount, 0), OBTAINING_IP_ADDRESS_GUARD_TIMER_MSEC);
+            } else {
+                // stop any running dhcp before assigning static IP
+                stopDhcp();
+                StaticIpConfiguration config = mWifiConfigStore.getStaticIpConfiguration(
+                        mLastNetworkId);
+                if (config.ipAddress == null) {
+                    loge("Static IP lacks address");
+                    sendMessage(CMD_STATIC_IP_FAILURE);
+                } else {
+                    InterfaceConfiguration ifcg = new InterfaceConfiguration();
+                    ifcg.setLinkAddress(config.ipAddress);
+                    ifcg.setInterfaceUp();
+                    try {
+                        mNwService.setInterfaceConfig(mInterfaceName, ifcg);
+                        if (DBG) log("Static IP configuration succeeded");
+                        DhcpResults dhcpResults = new DhcpResults(config);
+                        sendMessage(CMD_STATIC_IP_SUCCESS, dhcpResults);
+                    } catch (RemoteException re) {
+                        loge("Static IP configuration failed: " + re);
+                        sendMessage(CMD_STATIC_IP_FAILURE);
+                    } catch (IllegalStateException e) {
+                        loge("Static IP configuration failed: " + e);
+                        sendMessage(CMD_STATIC_IP_FAILURE);
+                    }
+                }
+            }
+        }
+      @Override
+      public boolean processMessage(Message message) {
+          logStateAndMessage(message, getClass().getSimpleName());
+
+          switch(message.what) {
+              case CMD_STATIC_IP_SUCCESS:
+                  handleIPv4Success((DhcpResults) message.obj, CMD_STATIC_IP_SUCCESS);
+                  break;
+              case CMD_STATIC_IP_FAILURE:
+                  handleIPv4Failure(CMD_STATIC_IP_FAILURE);
+                  break;
+              case CMD_AUTO_CONNECT:
+              case CMD_AUTO_ROAM:
+                  messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                  break;
+              case WifiManagerWAP.SAVE_NETWORK:
+              case WifiStateMachineWAP.CMD_AUTO_SAVE_NETWORK:
+                  messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                  deferMessage(message);
+                  break;
+                  /* Defer any power mode changes since we must keep active power mode at DHCP */
+              case CMD_SET_HIGH_PERF_MODE:
+                  messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                  deferMessage(message);
+                  break;
+                  /* Defer scan request since we should not switch to other channels at DHCP */
+              case CMD_START_SCAN:
+                  messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
+                  deferMessage(message);
+                  break;
+              case CMD_OBTAINING_IP_ADDRESS_WATCHDOG_TIMER:
+                  if (message.arg1 == obtainingIpWatchdogCount) {
+                      loge("ObtainingIpAddress: Watchdog Triggered, count="
+                              + obtainingIpWatchdogCount);
+                      handleIpConfigurationLost();
+                      transitionTo(mDisconnectingState);
+                      break;
+                  }
+                  messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                  break;
+              default:
+                  return NOT_HANDLED;
+          }
+          return HANDLED;
+      }
+    }
+
+    class VerifyingLinkState extends State {
+        @Override
+        public void enter() {
+            log(getName() + " enter");
+            setNetworkDetailedState(DetailedState.VERIFYING_POOR_LINK);
+            mWifiConfigStore.updateStatus(mLastNetworkId, DetailedState.VERIFYING_POOR_LINK);
+            sendNetworkStateChangeBroadcast(mLastBssid);
+            // End roaming
+            mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case WifiWatchdogStateMachine.POOR_LINK_DETECTED:
+                    // Stay here
+                    log(getName() + " POOR_LINK_DETECTED: no transition");
+                    break;
+                case WifiWatchdogStateMachine.GOOD_LINK_DETECTED:
+                    log(getName() + " GOOD_LINK_DETECTED: transition to captive portal check");
+
+                    log(getName() + " GOOD_LINK_DETECTED: transition to CONNECTED");
+                    sendConnectedState();
+                    transitionTo(mConnectedState);
+                    break;
+                default:
+                    if (DBG) log(getName() + " what=" + message.what + " NOT_HANDLED");
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    private void sendConnectedState() {
+        // Send out a broadcast with the CAPTIVE_PORTAL_CHECK to preserve
+        // existing behaviour. The captive portal check really happens after we
+        // transition into DetailedState.CONNECTED.
+        setNetworkDetailedState(DetailedState.CAPTIVE_PORTAL_CHECK);
+        mWifiConfigStore.updateStatus(mLastNetworkId,
+        DetailedState.CAPTIVE_PORTAL_CHECK);
+        sendNetworkStateChangeBroadcast(mLastBssid);
+
+        if (mWifiConfigStore.getLastSelectedConfiguration() != null) {
+            if (mNetworkAgent != null) mNetworkAgent.explicitlySelected();
+        }
+
+        setNetworkDetailedState(DetailedState.CONNECTED);
+        mWifiConfigStore.updateStatus(mLastNetworkId, DetailedState.CONNECTED);
+        sendNetworkStateChangeBroadcast(mLastBssid);
+    }
+
+    class RoamingState extends State {
+        boolean mAssociated;
+        @Override
+        public void enter() {
+            if (DBG) {
+                log("RoamingState Enter"
+                        + " mScreenOn=" + mScreenOn );
+            }
+            setScanAlarm(false, 0);
+
+            // Make sure we disconnect if roaming fails
+            roamWatchdogCount++;
+            loge("Start Roam Watchdog " + roamWatchdogCount);
+            sendMessageDelayed(obtainMessage(CMD_ROAM_WATCHDOG_TIMER,
+                    roamWatchdogCount, 0), ROAM_GUARD_TIMER_MSEC);
+            mAssociated = false;
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+               case WifiWatchdogStateMachine.POOR_LINK_DETECTED:
+                    if (DBG) log("Roaming and Watchdog reports poor link -> ignore");
+                    return HANDLED;
+               case CMD_UNWANTED_NETWORK:
+                    if (DBG) log("Roaming and CS doesnt want the network -> ignore");
+                    return HANDLED;
+               case CMD_SET_OPERATIONAL_MODE:
+                    if (message.arg1 != CONNECT_MODE) {
+                        deferMessage(message);
+                    }
+                    break;
+               case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    /**
+                     * If we get a SUPPLICANT_STATE_CHANGE_EVENT indicating a DISCONNECT
+                     * before NETWORK_DISCONNECTION_EVENT
+                     * And there is an associated BSSID corresponding to our target BSSID, then
+                     * we have missed the network disconnection, transition to mDisconnectedState
+                     * and handle the rest of the events there.
+                     */
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    if (stateChangeResult.state == SupplicantState.DISCONNECTED
+                            || stateChangeResult.state == SupplicantState.INACTIVE
+                            || stateChangeResult.state == SupplicantState.INTERFACE_DISABLED) {
+                        if (DBG) {
+                            log("STATE_CHANGE_EVENT in roaming state "
+                                    + stateChangeResult.toString() );
+                        }
+                        if (stateChangeResult.BSSID != null
+                                && stateChangeResult.BSSID.equals(mTargetRoamBSSID)) {
+                            handleNetworkDisconnect();
+                            transitionTo(mDisconnectedState);
+                        }
+                    }
+                    if (stateChangeResult.state == SupplicantState.ASSOCIATED) {
+                        // We completed the layer2 roaming part
+                        mAssociated = true;
+                        if (stateChangeResult.BSSID != null) {
+                            mTargetRoamBSSID = (String) stateChangeResult.BSSID;
+                        }
+                    }
+                    break;
+                case CMD_ROAM_WATCHDOG_TIMER:
+                    if (roamWatchdogCount == message.arg1) {
+                        if (DBG) log("roaming watchdog! -> disconnect");
+                        mRoamFailCount++;
+                        handleNetworkDisconnect();
+                        mWifiNative.disconnect();
+                        transitionTo(mDisconnectedState);
+                    }
+                    break;
+               case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                   if (mAssociated) {
+                       if (DBG) log("roaming and Network connection established");
+                       mLastNetworkId = message.arg1;
+                       mLastBssid = (String) message.obj;
+                       mWifiInfo.setBSSID(mLastBssid);
+                       mWifiInfo.setNetworkId(mLastNetworkId);
+                       mWifiConfigStore.handleBSSIDBlackList(mLastNetworkId, mLastBssid, true);
+                       transitionTo(mObtainingIpState);
+                   } else {
+                       messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                   }
+                   break;
+               case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                   // Throw away but only if it corresponds to the network we're roaming to
+                   String bssid = (String)message.obj;
+                   if (true) {
+                       String target = "";
+                       if (mTargetRoamBSSID != null) target = mTargetRoamBSSID;
+                       log("NETWORK_DISCONNECTION_EVENT in roaming state"
+                               + " BSSID=" + bssid
+                               + " target=" + target);
+                   }
+                   if (bssid != null && bssid.equals(mTargetRoamBSSID)) {
+                       handleNetworkDisconnect();
+                       transitionTo(mDisconnectedState);
+                   }
+                   break;
+                case WifiMonitor.SSID_TEMP_DISABLED:
+                    // Auth error while roaming
+                    loge("SSID_TEMP_DISABLED nid=" + Integer.toString(mLastNetworkId)
+                            + " id=" + Integer.toString(message.arg1)
+                            + " isRoaming=" + isRoaming()
+                            + " roam=" + Integer.toString(mAutoRoaming));
+                    if (message.arg1 == mLastNetworkId) {
+                        handleNetworkDisconnect();
+                        transitionTo(mDisconnectingState);
+                    }
+                    return NOT_HANDLED;
+                case CMD_START_SCAN:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            loge("WifiStateMachineWAP: Leaving Roaming state");
+        }
+    }
+
+    class ConnectedState extends State {
+        @Override
+        public void enter() {
+            String address;
+            updateDefaultRouteMacAddress(1000);
+            if (DBG) {
+                log("ConnectedState Enter "
+                        + " mScreenOn=" + mScreenOn
+                        + " scanperiod="
+                        + Integer.toString(mWifiConfigStore.associatedPartialScanPeriodMilli) );
+            }
+            if (mScreenOn
+                    && mWifiConfigStore.enableAutoJoinScanWhenAssociated) {
+                mCurrentScanAlarmMs = mWifiConfigStore.associatedPartialScanPeriodMilli;
+                // Scan after 200ms
+                setScanAlarm(true, 200);
+            } else {
+                mCurrentScanAlarmMs = 0;
+            }
+            registerConnected();
+            lastConnectAttempt = 0;
+            targetWificonfiguration = null;
+            // Paranoia
+            linkDebouncing = false;
+
+            // Not roaming anymore
+            mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+
+            if (testNetworkDisconnect) {
+                testNetworkDisconnectCounter++;
+                loge("ConnectedState Enter start disconnect test " +
+                        testNetworkDisconnectCounter);
+                sendMessageDelayed(obtainMessage(CMD_TEST_NETWORK_DISCONNECT,
+                        testNetworkDisconnectCounter, 0), 15000);
+            }
+
+            // Reenable all networks, allow for hidden networks to be scanned
+            mWifiConfigStore.enableAllNetworks();
+
+            mLastDriverRoamAttempt = 0;
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            WifiConfiguration config = null;
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case WifiWatchdogStateMachine.POOR_LINK_DETECTED:
+                    if (DBG) log("Watchdog reports poor link");
+                    transitionTo(mVerifyingLinkState);
+                    break;
+                case CMD_UNWANTED_NETWORK:
+                    if (message.arg1 == network_status_unwanted_disconnect) {
+                        mWifiConfigStore.handleBadNetworkDisconnectReport(mLastNetworkId, mWifiInfo);
+                        mWifiNative.disconnect();
+                        transitionTo(mDisconnectingState);
+                    } else if (message.arg1 == network_status_unwanted_disconnect) {
+                        config = getCurrentWifiConfiguration();
+                        if (config != null) {
+                            // Disable autojoin
+                            config.noInternetAccess = true;
+                        }
+                    }
+                    return HANDLED;
+                case CMD_TEST_NETWORK_DISCONNECT:
+                    // Force a disconnect
+                    if (message.arg1 == testNetworkDisconnectCounter) {
+                        mWifiNative.disconnect();
+                    }
+                    break;
+                case CMD_ASSOCIATED_BSSID:
+                    // ASSOCIATING to a new BSSID while already connected, indicates
+                    // that driver is roaming
+                    mLastDriverRoamAttempt = System.currentTimeMillis();
+                    String toBSSID = (String)message.obj;
+                    if (toBSSID != null && !toBSSID.equals(mWifiInfo.getBSSID())) {
+                        mWifiConfigStore.driverRoamedFrom(mWifiInfo);
+                    }
+                    return NOT_HANDLED;
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                    long lastRoam = 0;
+                    if (mLastDriverRoamAttempt != 0) {
+                        // Calculate time since last driver roam attempt
+                        lastRoam = System.currentTimeMillis() - mLastDriverRoamAttempt;
+                        mLastDriverRoamAttempt = 0;
+                    }
+                    config = getCurrentWifiConfiguration();
+                    if (mScreenOn
+                            && !linkDebouncing
+                            && config != null
+                            && config.autoJoinStatus == WifiConfiguration.AUTO_JOIN_ENABLED
+                            && !mWifiConfigStore.isLastSelectedConfiguration(config)
+                            && (message.arg2 != 3 /* reason cannot be 3, i.e. locally generated */
+                                || (lastRoam > 0 && lastRoam < 2000) /* unless driver is roaming */)
+                            && ((ScanResult.is24GHz(mWifiInfo.getFrequency())
+                                    && mWifiInfo.getRssi() >
+                                    WifiConfiguration.BAD_RSSI_24)
+                                    || (ScanResult.is5GHz(mWifiInfo.getFrequency())
+                                    && mWifiInfo.getRssi() >
+                                    WifiConfiguration.BAD_RSSI_5))) {
+                        // Start de-bouncing the L2 disconnection:
+                        // this L2 disconnection might be spurious.
+                        // Hence we allow 7 seconds for the state machine to try
+                        // to reconnect, go thru the
+                        // roaming cycle and enter Obtaining IP address
+                        // before signalling the disconnect to ConnectivityService and L3
+                        startScanForConfiguration(getCurrentWifiConfiguration(), false);
+                        linkDebouncing = true;
+
+                        sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT,
+                                0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
+                        if (DBG) {
+                            log("NETWORK_DISCONNECTION_EVENT in connected state"
+                                    + " BSSID=" + mWifiInfo.getBSSID()
+                                    + " RSSI=" + mWifiInfo.getRssi()
+                                    + " freq=" + mWifiInfo.getFrequency()
+                                    + " reason=" + message.arg2
+                                    + " -> debounce");
+                        }
+                        return HANDLED;
+                    } else {
+                        if (DBG) {
+                            int ajst = -1;
+                            if (config != null) ajst = config.autoJoinStatus;
+                            log("NETWORK_DISCONNECTION_EVENT in connected state"
+                                    + " BSSID=" + mWifiInfo.getBSSID()
+                                    + " RSSI=" + mWifiInfo.getRssi()
+                                    + " freq=" + mWifiInfo.getFrequency()
+                                    + " was debouncing=" + linkDebouncing
+                                    + " reason=" + message.arg2
+                                    + " ajst=" + ajst);
+                        }
+                    }
+                    break;
+                case CMD_AUTO_ROAM:
+                    // Clear the driver roam indication since we are attempting a framerwork roam
+                    mLastDriverRoamAttempt = 0;
+
+                    /* Connect command coming from auto-join */
+                    ScanResult candidate = (ScanResult)message.obj;
+                    String bssid = "any";
+                    if (candidate != null && candidate.is5GHz()) {
+                        // Only lock BSSID for 5GHz networks
+                        bssid = candidate.BSSID;
+                    }
+                    int netId = mLastNetworkId;
+                    config = getCurrentWifiConfiguration();
+
+
+                    if (config == null) {
+                        loge("AUTO_ROAM and no config, bail out...");
+                        break;
+                    }
+
+                    loge("CMD_AUTO_ROAM sup state "
+                            + mSupplicantStateTracker.getSupplicantStateName()
+                            + " my state " + getCurrentState().getName()
+                            + " nid=" + Integer.toString(netId)
+                            + " config " + config.configKey()
+                            + " roam=" + Integer.toString(message.arg2)
+                            + " to " + bssid
+                            + " targetRoamBSSID " + mTargetRoamBSSID);
+
+                    /* Save the BSSID so as to lock it @ firmware */
+                    if (!autoRoamSetBSSID(config, bssid) && !linkDebouncing) {
+                        loge("AUTO_ROAM nothing to do");
+                        // Same BSSID, nothing to do
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                        break;
+                    };
+
+                    // Make sure the network is enabled, since supplicant will not reenable it
+                    mWifiConfigStore.enableNetworkWithoutBroadcast(netId, false);
+
+                    boolean ret = false;
+                    if (mLastNetworkId != netId) {
+                       if (mWifiConfigStore.selectNetwork(netId) &&
+                           mWifiNative.reconnect()) {
+                           ret = true;
+                       }
+                    } else {
+                         ret = mWifiNative.reassociate();
+                    }
+                    if (ret) {
+                        lastConnectAttempt = System.currentTimeMillis();
+                        targetWificonfiguration = mWifiConfigStore.getWifiConfiguration(netId);
+
+                        // replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
+                        mAutoRoaming = message.arg2;
+                        transitionTo(mRoamingState);
+
+                    } else {
+                        loge("Failed to connect config: " + config + " netId: " + netId);
+                        replyToMessage(message, WifiManagerWAP.CONNECT_NETWORK_FAILED,
+                                WifiManagerWAP.ERROR);
+                        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
+                        break;
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            loge("WifiStateMachineWAP: Leaving Connected state");
+            setScanAlarm(false, 0);
+            mLastDriverRoamAttempt = 0;
+        }
+    }
+
+    class DisconnectingState extends State {
+
+        @Override
+        public void enter() {
+            mCurrentScanAlarmMs = mDisconnectedScanPeriodMs;
+
+            if (PDBG) {
+                loge(" Enter DisconnectingState State scan interval " + mFrameworkScanIntervalMs
+                        + " mEnableBackgroundScan= " + mEnableBackgroundScan
+                        + " screenOn=" + mScreenOn);
+            }
+
+            // Make sure we disconnect: we enter this state prior connecting to a new
+            // network, waiting for either a DISCONECT event or a SUPPLICANT_STATE_CHANGE
+            // event which in this case will be indicating that supplicant started to associate.
+            // In some cases supplicant doesn't ignore the connect requests (it might not
+            // find the target SSID in its cache),
+            // Therefore we end up stuck that state, hence the need for the watchdog.
+            disconnectingWatchdogCount++;
+            loge("Start Disconnecting Watchdog " + disconnectingWatchdogCount);
+            sendMessageDelayed(obtainMessage(CMD_DISCONNECTING_WATCHDOG_TIMER,
+                    disconnectingWatchdogCount, 0), DISCONNECTING_GUARD_TIMER_MSEC);
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+            switch (message.what) {
+                case CMD_SET_OPERATIONAL_MODE:
+                    if (message.arg1 != CONNECT_MODE) {
+                        deferMessage(message);
+                    }
+                    break;
+                case CMD_START_SCAN:
+                    // Ignore scans while disconnecting
+                    return HANDLED;
+                case CMD_DISCONNECTING_WATCHDOG_TIMER:
+                    if (disconnectingWatchdogCount == message.arg1) {
+                        if (DBG) log("disconnecting watchdog! -> disconnect");
+                        handleNetworkDisconnect();
+                        transitionTo(mDisconnectedState);
+                    }
+                    break;
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    /**
+                     * If we get a SUPPLICANT_STATE_CHANGE_EVENT before NETWORK_DISCONNECTION_EVENT
+                     * we have missed the network disconnection, transition to mDisconnectedState
+                     * and handle the rest of the events there
+                     */
+                    deferMessage(message);
+                    handleNetworkDisconnect();
+                    transitionTo(mDisconnectedState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            mCurrentScanAlarmMs = 0;
+        }
+    }
+
+    class DisconnectedState extends State {
+        @Override
+        public void enter() {
+            // We dont scan frequently if this is a temporary disconnect
+            // due to p2p
+            if (mTemporarilyDisconnectWifi) {
+                mWifiP2pChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
+                return;
+            }
+
+            // Loose the last selection choice
+            // mWifiAutoJoinController.setLastSelectedConfiguration
+            // (WifiConfiguration.INVALID_NETWORK_ID);
+
+            mFrameworkScanIntervalMs = Settings.Global.getLong(mContext.getContentResolver(),
+                    Settings.Global.WIFI_FRAMEWORK_SCAN_INTERVAL_MS,
+                    mDefaultFrameworkScanIntervalMs);
+
+            // Configure the scan alarm time to mFrameworkScanIntervalMs
+            // (5 minutes) if there are no saved profiles as there is
+            // already a periodic scan getting issued for every
+            // mSupplicantScanIntervalMs seconds. However keep the
+            // scan frequency by setting it to mDisconnectedScanPeriodMs
+            // (10 seconds) when there are configured profiles.
+            if (mScreenOn) {
+                if (mWifiConfigStore.getConfiguredNetworks().size() != 0) {
+                    mCurrentScanAlarmMs = mDisconnectedScanPeriodMs;
+                } else {
+                    mCurrentScanAlarmMs = mFrameworkScanIntervalMs;
+                }
+            }
+            if (PDBG) {
+                loge(" Enter disconnected State scan interval " + mFrameworkScanIntervalMs
+                        + " mEnableBackgroundScan= " + mEnableBackgroundScan
+                        + " screenOn=" + mScreenOn);
+            }
+
+            /** clear the roaming state, if we were roaming, we failed */
+            mAutoRoaming = WifiAutoJoinControllerWAP.AUTO_JOIN_IDLE;
+
+            // Reenable all networks, allow for hidden networks to be scanned
+            mWifiConfigStore.enableAllNetworks();
+
+            /**
+             * - screen dark and PNO supported => scan alarm disabled
+             * - everything else => scan alarm enabled with mDefaultFrameworkScanIntervalMs period
+             */
+            if ((mScreenOn == false) && mEnableBackgroundScan) { //mEnableBackgroundScan)
+                /* If a regular scan result is pending, do not initiate background
+                 * scan until the scan results are returned. This is needed because
+                 * initiating a background scan will cancel the regular scan and
+                 * scan results will not be returned until background scanning is
+                 * cleared
+                 */
+                if (!mIsScanOngoing) {
+                    if (!mWifiNative.enableBackgroundScan(true)) {
+                        handlePnoFailError();
+                    }
+                }
+            } else {
+                setScanAlarm(true, 200);
+            }
+
+            /**
+             * If we have no networks saved, the supplicant stops doing the periodic scan.
+             * The scans are useful to notify the user of the presence of an open network.
+             * Note that these are not wake up scans.
+             */
+            if (!mP2pConnected.get() && mWifiConfigStore.getConfiguredNetworks().size() == 0) {
+                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN,
+                        ++mPeriodicScanToken, 0), mSupplicantScanIntervalMs);
+            }
+
+            mDisconnectedTimeStamp = System.currentTimeMillis();
+
+        }
+
+        @Override
+        public boolean processMessage(Message message) {
+            boolean ret = HANDLED;
+
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case CMD_NO_NETWORKS_PERIODIC_SCAN:
+                    if (mP2pConnected.get()) break;
+                    if (message.arg1 == mPeriodicScanToken &&
+                            mWifiConfigStore.getConfiguredNetworks().size() == 0) {
+                        startScan(UNKNOWN_SCAN_SOURCE, -1, null, null);
+                        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN,
+                                    ++mPeriodicScanToken, 0), mSupplicantScanIntervalMs);
+                    }
+                    break;
+                case CMD_PNO_PERIODIC_SCAN:
+                     if ((mBackgroundScanConfigured == false) &&
+                         (message.arg1 == mPnoPeriodicScanToken) &&
+                         (mEnableBackgroundScan)) {
+                         startScan(UNKNOWN_SCAN_SOURCE, -1, null, null);
+                         sendMessageDelayed(obtainMessage(CMD_PNO_PERIODIC_SCAN,
+                                             ++mPnoPeriodicScanToken, 0),
+                                             mDefaultFrameworkScanIntervalMs);
+                     }
+                     break;
+                case WifiManagerWAP.FORGET_NETWORK:
+                case CMD_REMOVE_NETWORK:
+                    // Set up a delayed message here. After the forget/remove is handled
+                    // the handled delayed message will determine if there is a need to
+                    // scan and continue
+                    sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN,
+                                ++mPeriodicScanToken, 0), mSupplicantScanIntervalMs);
+                    ret = NOT_HANDLED;
+                    break;
+                case CMD_SET_OPERATIONAL_MODE:
+                    if (message.arg1 != CONNECT_MODE) {
+                        mOperationalMode = message.arg1;
+
+                        mWifiConfigStore.disableAllNetworks();
+                        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
+                            mWifiP2pChannel.sendMessage(CMD_DISABLE_P2P_REQ);
+                            setWifiState(WIFI_STATE_DISABLED);
+                        }
+
+                        transitionTo(mScanModeState);
+                    }
+                    break;
+                    /* Ignore network disconnect */
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                    break;
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
+                    if (DBG) {
+                        loge("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state +
+                                " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state)
+                                + " debouncing=" + linkDebouncing);
+                    }
+                    setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
+                    /* ConnectModeState does the rest of the handling */
+                    ret = NOT_HANDLED;
+                    break;
+                case CMD_START_SCAN:
+                    if (!isScanAllowed(message.arg1)) {
+                        // Ignore the scan request
+                        if (VDBG) logd("DisconnectedState: ignore scan");
+                        return HANDLED;
+                    }
+                    /* Disable background scan temporarily during a regular scan */
+                    if (mEnableBackgroundScan) {
+                        mWifiNative.enableBackgroundScan(false);
+                    }
+                    /* Handled in parent state */
+                    ret = NOT_HANDLED;
+                    break;
+                case WifiMonitor.SCAN_RESULTS_EVENT:
+                    /* Re-enable background scan when a pending scan result is received */
+                    if (mEnableBackgroundScan && mIsScanOngoing) {
+                        if (!mWifiNative.enableBackgroundScan(true)) {
+                            handlePnoFailError();
+                        }
+                    }
+                    /* Handled in parent state */
+                    ret = NOT_HANDLED;
+                    break;
+                case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
+                    NetworkInfo info = (NetworkInfo) message.obj;
+                    mP2pConnected.set(info.isConnected());
+                    if (mP2pConnected.get()) {
+                        int defaultInterval = mContext.getResources().getInteger(
+                                R.integer.config_wifi_scan_interval_p2p_connected);
+                        long scanIntervalMs = Settings.Global.getLong(mContext.getContentResolver(),
+                                Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS,
+                                defaultInterval);
+                        mWifiNative.setScanInterval((int) scanIntervalMs/1000);
+                    } else if (mWifiConfigStore.getConfiguredNetworks().size() == 0) {
+                        if (DBG) log("Turn on scanning after p2p disconnected");
+                        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN,
+                                    ++mPeriodicScanToken, 0), mSupplicantScanIntervalMs);
+                    } else if (mEnableBackgroundScan && !mP2pConnected.get() &&
+                               (mWifiConfigStore.getConfiguredNetworks().size() != 0)) {
+                        if (!mWifiNative.enableBackgroundScan(true)) {
+                            handlePnoFailError();
+                        } else {
+                            if (DBG) log("Stop periodic scan on PNO success");
+                            mBackgroundScanConfigured = true;
+                        }
+                    }
+                case CMD_RECONNECT:
+                case CMD_REASSOCIATE:
+                    if (mTemporarilyDisconnectWifi) {
+                        // Drop a third party reconnect/reassociate if STA is
+                        // temporarily disconnected for p2p
+                        break;
+                    } else {
+                        // ConnectModeState handles it
+                        ret = NOT_HANDLED;
+                    }
+                    break;
+                case WifiP2pServiceImpl.P2P_MIRACAST_MODE_CHANGED:
+                    setScanIntevelOnMiracastModeChange(message.arg1);
+                    break;
+                case CMD_SCREEN_STATE_CHANGED:
+                    handleScreenStateChanged(message.arg1 != 0,
+                            /* startBackgroundScanIfNeeded = */ true);
+                    break;
+                default:
+                    ret = NOT_HANDLED;
+            }
+            return ret;
+        }
+
+        @Override
+        public void exit() {
+            /* No need for a background scan upon exit from a disconnected state */
+            if (mEnableBackgroundScan) {
+                mWifiNative.enableBackgroundScan(false);
+            }
+            mCurrentScanAlarmMs = 0;
+            setScanAlarm(false, 0);
+        }
+    }
+
+    class WpsRunningState extends State {
+        // Tracks the source to provide a reply
+        private Message mSourceMessage;
+        @Override
+        public void enter() {
+            mSourceMessage = Message.obtain(getCurrentMessage());
+            mWpsNetworkId = -1;
+            mWpsSuccess = false;
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch (message.what) {
+                case WifiMonitor.WPS_SUCCESS_EVENT:
+                    // Ignore intermediate success, wait for full connection
+                    if (mWifiConfigStore.enableAutoJoinWhenAssociated) {
+                        mWpsSuccess = true;
+                    }
+                    break;
+                case CMD_TARGET_SSID:
+                    /* Trying to associate to this SSID */
+                    if (mWpsSuccess && message.obj != null) {
+                        String SSID = (String) message.obj;
+                        mWpsNetworkId =
+                            mWifiConfigStore.getNetworkIdFromSsid(SSID);
+                        /* get only once network id , ignore next connect */
+                        mWpsSuccess = false;
+                    }
+                    break;
+                case WifiMonitor.NETWORK_CONNECTION_EVENT:
+                    replyToMessage(mSourceMessage, WifiManagerWAP.WPS_COMPLETED);
+                    mSourceMessage.recycle();
+                    mSourceMessage = null;
+                    deferMessage(message);
+                    transitionTo(mDisconnectedState);
+                    break;
+                case WifiMonitor.WPS_OVERLAP_EVENT:
+                    replyToMessage(mSourceMessage, WifiManagerWAP.WPS_FAILED,
+                            WifiManagerWAP.WPS_OVERLAP_ERROR);
+                    mSourceMessage.recycle();
+                    mSourceMessage = null;
+                    transitionTo(mDisconnectedState);
+                    break;
+                case WifiMonitor.WPS_FAIL_EVENT:
+                    // Arg1 has the reason for the failure
+                    if ((message.arg1 != WifiManagerWAP.ERROR) || (message.arg2 != 0)) {
+                        replyToMessage(mSourceMessage, WifiManagerWAP.WPS_FAILED, message.arg1);
+                        mSourceMessage.recycle();
+                        mSourceMessage = null;
+                        transitionTo(mDisconnectedState);
+                    } else {
+                        if (DBG) log("Ignore unspecified fail event during WPS connection");
+                    }
+                    break;
+                case WifiMonitor.WPS_TIMEOUT_EVENT:
+                    replyToMessage(mSourceMessage, WifiManagerWAP.WPS_FAILED,
+                            WifiManagerWAP.WPS_TIMED_OUT);
+                    mSourceMessage.recycle();
+                    mSourceMessage = null;
+                    transitionTo(mDisconnectedState);
+                    break;
+                case WifiManagerWAP.START_WPS:
+                    replyToMessage(message, WifiManagerWAP.WPS_FAILED, WifiManagerWAP.IN_PROGRESS);
+                    break;
+                case WifiManagerWAP.CANCEL_WPS:
+                    if (mWifiNative.cancelWps()) {
+                        replyToMessage(message, WifiManagerWAP.CANCEL_WPS_SUCCEDED);
+                    } else {
+                        replyToMessage(message, WifiManagerWAP.CANCEL_WPS_FAILED, WifiManagerWAP.ERROR);
+                    }
+                    transitionTo(mDisconnectedState);
+                    break;
+                /**
+                 * Defer all commands that can cause connections to a different network
+                 * or put the state machine out of connect mode
+                 */
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case WifiManagerWAP.CONNECT_NETWORK:
+                case CMD_ENABLE_NETWORK:
+                case CMD_RECONNECT:
+                case CMD_REASSOCIATE:
+                    deferMessage(message);
+                    break;
+                case CMD_AUTO_CONNECT:
+                case CMD_AUTO_ROAM:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    return HANDLED;
+                case CMD_START_SCAN:
+                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
+                    return HANDLED;
+                case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
+                    if (DBG) {
+                        loge("Network connection lost reason = "
+                              + message.arg2);
+                    }
+                    handleNetworkDisconnect();
+                    if (mWpsNetworkId >= 0 && message.arg2 != reason3) {
+                        mWifiNative.enableNetwork(mWpsNetworkId, true);
+                    }
+                    break;
+                case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
+                    if (DBG) log("Ignore Assoc reject event during WPS Connection");
+                    break;
+                case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
+                    // Disregard auth failure events during WPS connection. The
+                    // EAP sequence is retried several times, and there might be
+                    // failures (especially for wps pin). We will get a WPS_XXX
+                    // event at the end of the sequence anyway.
+                    if (DBG) log("Ignore auth failure during WPS connection");
+                    break;
+                case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
+                    // Throw away supplicant state changes when WPS is running.
+                    // We will start getting supplicant state changes once we get
+                    // a WPS success or failure
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+
+        @Override
+        public void exit() {
+            mWifiConfigStore.enableAllNetworks();
+            mWifiConfigStore.loadConfiguredNetworks();
+        }
+    }
+
+    class SoftApStartingState extends State {
+        @Override
+        public void enter() {
+            final Message message = getCurrentMessage();
+            if (message.what == CMD_START_AP) {
+                final WifiConfiguration config = (WifiConfiguration) message.obj;
+
+                if (config == null) {
+                    mWifiApConfigChannel.sendMessage(CMD_REQUEST_AP_CONFIG);
+                } else {
+                    mWifiApConfigChannel.sendMessage(CMD_SET_AP_CONFIG, config);
+                    startSoftApWithConfig(config);
+                }
+            } else {
+                throw new RuntimeException("Illegal transition to SoftApStartingState: " + message);
+            }
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                case CMD_TETHER_STATE_CHANGE:
+                    deferMessage(message);
+                    break;
+                case WifiStateMachineWAP.CMD_RESPONSE_AP_CONFIG:
+                    WifiConfiguration config = (WifiConfiguration) message.obj;
+                    if (config != null) {
+                        startSoftApWithConfig(config);
+                    } else {
+                        loge("Softap config is null!");
+                        sendMessage(CMD_START_AP_FAILURE);
+                    }
+                    break;
+                case CMD_START_AP_SUCCESS:
+                    setWifiApState(WIFI_AP_STATE_ENABLED);
+                    transitionTo(mSoftApStartedState);
+                    break;
+                case CMD_START_AP_FAILURE:
+                    setWifiApState(WIFI_AP_STATE_FAILED);
+                    transitionTo(mInitialState);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class SoftApStartedState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+            switch(message.what) {
+                case CMD_STOP_AP:
+                    if (DBG) log("Stopping Soft AP");
+                    /* We have not tethered at this point, so we just shutdown soft Ap */
+                    try {
+                        mNwService.stopAccessPoint(mInterfaceName);
+                    } catch(Exception e) {
+                        loge("Exception in stopAccessPoint()");
+                    }
+                    setWifiApState(WIFI_AP_STATE_DISABLED);
+                    transitionTo(mInitialState);
+                    break;
+                case CMD_START_AP:
+                    // Ignore a start on a running access point
+                    break;
+                    // Fail client mode operation when soft AP is enabled
+                case CMD_START_SUPPLICANT:
+                    loge("Cannot start supplicant with a running soft AP");
+                    setWifiState(WIFI_STATE_UNKNOWN);
+                    break;
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+                    if (startTethering(stateChange.available)) {
+                        transitionTo(mTetheringState);
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class TetheringState extends State {
+        @Override
+        public void enter() {
+            /* Send ourselves a delayed message to shut down if tethering fails to notify */
+            sendMessageDelayed(obtainMessage(CMD_TETHER_NOTIFICATION_TIMED_OUT,
+                    ++mTetherToken, 0), TETHER_NOTIFICATION_TIME_OUT_MSECS);
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+                    if (isWifiTethered(stateChange.active)) {
+                        transitionTo(mTetheredState);
+                    }
+                    return HANDLED;
+                case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                    if (message.arg1 == mTetherToken) {
+                        loge("Failed to get tether update, shutdown soft access point");
+                        transitionTo(mSoftApStartedState);
+                        // Needs to be first thing handled
+                        sendMessageAtFrontOfQueue(CMD_STOP_AP);
+                    }
+                    break;
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class TetheredState extends State {
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+                    if (!isWifiTethered(stateChange.active)) {
+                        loge("Tethering reports wifi as untethered!, shut down soft Ap");
+                        setHostApRunning(null, false);
+                        setHostApRunning(null, true);
+                    }
+                    return HANDLED;
+                case CMD_STOP_AP:
+                    if (DBG) log("Untethering before stopping AP");
+                    setWifiApState(WIFI_AP_STATE_DISABLING);
+                    stopTethering();
+                    transitionTo(mUntetheringState);
+                    // More work to do after untethering
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    class UntetheringState extends State {
+        @Override
+        public void enter() {
+            /* Send ourselves a delayed message to shut down if tethering fails to notify */
+            sendMessageDelayed(obtainMessage(CMD_TETHER_NOTIFICATION_TIMED_OUT,
+                    ++mTetherToken, 0), TETHER_NOTIFICATION_TIME_OUT_MSECS);
+
+        }
+        @Override
+        public boolean processMessage(Message message) {
+            logStateAndMessage(message, getClass().getSimpleName());
+
+            switch(message.what) {
+                case CMD_TETHER_STATE_CHANGE:
+                    TetherStateChange stateChange = (TetherStateChange) message.obj;
+
+                    /* Wait till wifi is untethered */
+                    if (isWifiTethered(stateChange.active)) break;
+
+                    transitionTo(mSoftApStartedState);
+                    break;
+                case CMD_TETHER_NOTIFICATION_TIMED_OUT:
+                    if (message.arg1 == mTetherToken) {
+                        loge("Failed to get tether update, force stop access point");
+                        transitionTo(mSoftApStartedState);
+                    }
+                    break;
+                case CMD_START_SUPPLICANT:
+                case CMD_STOP_SUPPLICANT:
+                case CMD_START_AP:
+                case CMD_STOP_AP:
+                case CMD_START_DRIVER:
+                case CMD_STOP_DRIVER:
+                case CMD_SET_OPERATIONAL_MODE:
+                case CMD_SET_COUNTRY_CODE:
+                case CMD_SET_FREQUENCY_BAND:
+                case CMD_START_PACKET_FILTERING:
+                case CMD_STOP_PACKET_FILTERING:
+                    deferMessage(message);
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return HANDLED;
+        }
+    }
+
+    //State machine initiated requests can have replyTo set to null indicating
+    //there are no recepients, we ignore those reply actions
+    private void replyToMessage(Message msg, int what) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, int arg1) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        dstMsg.arg1 = arg1;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    private void replyToMessage(Message msg, int what, Object obj) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessageWithArg2(msg);
+        dstMsg.what = what;
+        dstMsg.obj = obj;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+
+    /**
+     * arg2 on the source message has a unique id that needs to be retained in replies
+     * to match the request
+
+     * see WifiManager for details
+     */
+    private Message obtainMessageWithArg2(Message srcMsg) {
+        Message msg = Message.obtain();
+        msg.arg2 = srcMsg.arg2;
+        return msg;
+    }
+
+    private static int parseHex(char ch) {
+        if ('0' <= ch && ch <= '9') {
+            return ch - '0';
+        } else if ('a' <= ch && ch <= 'f') {
+            return ch - 'a' + 10;
+        } else if ('A' <= ch && ch <= 'F') {
+            return ch - 'A' + 10;
+        } else {
+            throw new NumberFormatException("" + ch + " is not a valid hex digit");
+        }
+    }
+
+    private byte[] parseHex(String hex) {
+        /* This only works for good input; don't throw bad data at it */
+        if (hex == null) {
+            return new byte[0];
+        }
+
+        if (hex.length() % 2 != 0) {
+            throw new NumberFormatException(hex + " is not a valid hex string");
+        }
+
+        byte[] result = new byte[(hex.length())/2 + 1];
+        result[0] = (byte) ((hex.length())/2);
+        for (int i = 0, j = 1; i < hex.length(); i += 2, j++) {
+            int val = parseHex(hex.charAt(i)) * 16 + parseHex(hex.charAt(i+1));
+            byte b = (byte) (val & 0xFF);
+            result[j] = b;
+        }
+
+        return result;
+    }
+
+    private static String makeHex(byte[] bytes) {
+        StringBuilder sb = new StringBuilder();
+        for (byte b : bytes) {
+            sb.append(String.format("%02x", b));
+        }
+        return sb.toString();
+    }
+
+    private static String makeHex(byte[] bytes, int from, int len) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < len; i++) {
+            sb.append(String.format("%02x", bytes[from+i]));
+        }
+        return sb.toString();
+    }
+
+
+    private static byte[] concat(byte[] array1, byte[] array2, byte[] array3) {
+
+        int len = array1.length + array2.length + array3.length;
+
+        if (array1.length != 0) {
+            len++;                      /* add another byte for size */
+        }
+
+        if (array2.length != 0) {
+            len++;                      /* add another byte for size */
+        }
+
+        if (array3.length != 0) {
+            len++;                      /* add another byte for size */
+        }
+
+        byte[] result = new byte[len];
+
+        int index = 0;
+        if (array1.length != 0) {
+            result[index] = (byte) (array1.length & 0xFF);
+            index++;
+            for (byte b : array1) {
+                result[index] = b;
+                index++;
+            }
+        }
+
+        if (array2.length != 0) {
+            result[index] = (byte) (array2.length & 0xFF);
+            index++;
+            for (byte b : array2) {
+                result[index] = b;
+                index++;
+            }
+        }
+
+        if (array3.length != 0) {
+            result[index] = (byte) (array3.length & 0xFF);
+            index++;
+            for (byte b : array3) {
+                result[index] = b;
+                index++;
+            }
+        }
+        return result;
+    }
+
+    void handleGsmAuthRequest(SimAuthRequestData requestData) {
+        if (targetWificonfiguration == null
+                || targetWificonfiguration.networkId == requestData.networkId) {
+            logd("id matches targetWifiConfiguration");
+        } else {
+            logd("id does not match targetWifiConfiguration");
+            return;
+        }
+
+        TelephonyManager tm = (TelephonyManager)
+                mContext.getSystemService(Context.TELEPHONY_SERVICE);
+
+        if (tm != null) {
+            StringBuilder sb = new StringBuilder();
+            for (String challenge : requestData.challenges) {
+
+                logd("RAND = " + challenge);
+
+                byte[] rand = null;
+                try {
+                    rand = parseHex(challenge);
+                } catch (NumberFormatException e) {
+                    loge("malformed challenge");
+                    continue;
+                }
+
+                String base64Challenge = android.util.Base64.encodeToString(
+                        rand, android.util.Base64.NO_WRAP);
+                /*
+                 * appType = 1 => SIM, 2 => USIM according to
+                 * com.android.internal.telephony.PhoneConstants#APPTYPE_xxx
+                 */
+                int appType = 2;
+                String tmResponse = tm.getIccSimChallengeResponse(appType, base64Challenge);
+                logv("Raw Response - " + tmResponse);
+
+                if (tmResponse != null && tmResponse.length() > 4) {
+                    byte[] result = android.util.Base64.decode(tmResponse,
+                            android.util.Base64.DEFAULT);
+                    logv("Hex Response -" + makeHex(result));
+                    int sres_len = result[0];
+                    String sres = makeHex(result, 1, sres_len);
+                    int kc_offset = 1+sres_len;
+                    int kc_len = result[kc_offset];
+                    String kc = makeHex(result, 1+kc_offset, kc_len);
+                    sb.append(":" + kc + ":" + sres);
+                    logv("kc:" + kc + " sres:" + sres);
+                } else {
+                    loge("bad response - " + tmResponse);
+                }
+            }
+
+            String response = sb.toString();
+            logv("Supplicant Response -" + response);
+            mWifiNative.simAuthResponse(requestData.networkId, response);
+        } else {
+            loge("could not get telephony manager");
+        }
+    }
+
+    void handle3GAuthRequest(SimAuthRequestData requestData) {
+
+    }
+    private void setScanIntevelOnMiracastModeChange(int mode) {
+        if ((mode == WifiP2pManager.MIRACAST_SOURCE)
+                || (mode == WifiP2pManager.MIRACAST_SINK)) {
+            int defaultWfdIntervel = mContext.getResources().getInteger(
+                    R.integer.config_wifi_scan_interval_wfd_connected);
+            long wfdScanIntervalMs = Settings.Global
+                    .getLong(
+                            mContext.getContentResolver(),
+                            Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_WFD_CONNECTED_MS,
+                            defaultWfdIntervel);
+            mWifiNative.setScanInterval((int) wfdScanIntervalMs / 1000);
+        }
+    }
+
+    private void handlePnoFailError() {
+        /* PNO should not fail when P2P is not connected and there are
+           saved profiles */
+        if (!mP2pConnected.get() &&
+            (mWifiConfigStore.getConfiguredNetworks().size() == 0)) {
+            return;
+        }
+        /* Trigger a periodic scan for every 300Sec if PNO fails */
+        if (mEnableBackgroundScan) {
+            mBackgroundScanConfigured = false;
+            sendMessageDelayed(obtainMessage(CMD_PNO_PERIODIC_SCAN,
+                               ++mPnoPeriodicScanToken, 0),
+                               mDefaultFrameworkScanIntervalMs);
+        }
+    }
+}
diff -Nuar a/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp b/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
--- a/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
+++ b/frameworks/opt/net/wifi/service/jni/com_android_server_wifi_WifiNative.cpp
@@ -158,6 +158,21 @@
     return (::wifi_unload_driver() == 0);
 }
 
+static jboolean android_net_wifi_loadApDriver(JNIEnv* env, jobject)
+{
+    return (::wifi_load_ap_driver() == 0);
+}
+
+static jboolean android_net_wifi_isApDriverLoaded(JNIEnv* env, jobject)
+{
+    return (::is_wifi_ap_driver_loaded() == 0);
+}
+
+static jboolean android_net_wifi_unloadApDriver(JNIEnv* env, jobject)
+{
+    return (::wifi_unload_ap_driver() == 0);
+}
+
 static jboolean android_net_wifi_startSupplicant(JNIEnv* env, jobject, jboolean p2pSupported)
 {
     return (::wifi_start_supplicant(p2pSupported) == 0);
@@ -1161,7 +1176,10 @@
     { "cancelRangeRequestNative", "(II[Landroid/net/wifi/RttManager$RttParams;)Z",
             (void*) android_net_wifi_cancelRange},
     { "setScanningMacOuiNative", "(I[B)Z", (void*) android_net_wifi_setScanningMacOui},
-    { "getChannelsForBandNative", "(II)[I", (void*) android_net_wifi_getValidChannels}
+    { "getChannelsForBandNative", "(II)[I", (void*) android_net_wifi_getValidChannels},
+    { "loadApDriver", "()Z",  (void *)android_net_wifi_loadApDriver },
+    { "isApDriverLoaded", "()Z",  (void *)android_net_wifi_isApDriverLoaded },
+    { "unloadApDriver", "()Z",  (void *)android_net_wifi_unloadApDriver }
 };
 
 int register_android_net_wifi_WifiNative(JNIEnv* env) {
