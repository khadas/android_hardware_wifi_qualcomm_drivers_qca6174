diff -urN ath6kl.orig/cfg80211.c ath6kl/cfg80211.c
--- ath6kl.orig/cfg80211.c	2016-01-28 11:15:40.578660366 +0800
+++ ath6kl/cfg80211.c	2016-01-28 11:16:06.934660848 +0800
@@ -6638,6 +6638,12 @@
 		ar->roam_mode = ATH6KL_MODULEROAM_DISABLE;
 	}
 
+#ifdef QCMBR_TCMD
+	if (testmode == 2) {
+		INIT_LIST_HEAD(&ar->qcmbr_queue_head);
+		spin_lock_init(&ar->qcmbr_queue_lock);
+	}
+#endif
 	return ar;
 }
 
@@ -6975,9 +6981,6 @@
 
 	vif->saved_pwr_mode =
 	vif->last_pwr_mode = REC_POWER;
-#ifdef CONFIG_SWOW_SUPPORT
-	vif->last_suspend_wow = 0;
-#endif
 
 	return 0;
 }
diff -urN ath6kl.orig/core.h ath6kl/core.h
--- ath6kl.orig/core.h	2016-01-28 11:15:40.594660366 +0800
+++ ath6kl/core.h	2016-01-28 11:16:06.934660848 +0800
@@ -1396,6 +1396,25 @@
 	int aging_time;
 };
 
+#ifdef QCMBR_TCMD
+#define ATH_XIOCTL_UNIFIED_UTF_CMD  0x1000
+#define ATH_XIOCTL_UNIFIED_UTF_RSP  0x1001
+#define MAX_UTF_LENGTH              1024
+
+typedef struct qcmbr_data_s {
+	unsigned int cmd;
+	unsigned int length;
+	unsigned char buf[MAX_UTF_LENGTH + 4];
+	unsigned int copy_to_user;
+} qcmbr_data_t;
+
+typedef struct qcmbr_queue_s {
+	unsigned char utf_buf[MAX_UTF_LENGTH + 4];
+	unsigned int length;
+	struct list_head list;
+} qcmbr_queue_t;
+#endif /* QCMBR_TCMD */
+
 struct ath6kl_vif {
 	struct list_head list;
 	struct wireless_dev wdev;
@@ -1528,9 +1547,6 @@
 
 	int p2p_wise_full_scan;		/* Counter to trigger full P2P scan. */
 	u16 next_conn_status;		/* CR508988 */
-#ifdef CONFIG_SWOW_SUPPORT
-	u8 last_suspend_wow;
-#endif//swow
 };
 
 #define WOW_LIST_ID		0
@@ -1906,10 +1922,10 @@
 
 	/* set if wow pattern set by debug_fs */
 	bool get_wow_pattern;
-#ifdef CONFIG_SWOW_SUPPORT
-	u8 swow_mode;
-	struct wmi_set_swol_indoor_info_cmd swol_indoor_cmd;
-#endif
+#ifdef QCMBR_TCMD
+	struct list_head qcmbr_queue_head;
+	spinlock_t qcmbr_queue_lock;
+#endif /* QCMBR_TCMD */
 };
 
 static inline void *ath6kl_priv(struct net_device *dev)
diff -urN ath6kl.orig/debug.c ath6kl/debug.c
--- ath6kl.orig/debug.c	2016-01-28 11:15:40.458660364 +0800
+++ ath6kl/debug.c	2016-01-28 11:16:06.934660848 +0800
@@ -6369,59 +6369,6 @@
 	.llseek = default_llseek,
 };
 
-#ifdef DIRECT_AUDIO_SUPPORT
-extern int Direct_Audio_TX_debug(void);
-extern int Direct_Audio_RX_debug(void);
-
-static ssize_t ath6kl_aow_write(struct file *file,
-					const char __user *user_buf,
-					size_t count, loff_t *ppos)
-{
-	u32 tmp,len;
-	char buf[32];
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-	buf[len] = '\0';
-	if (kstrtou32(buf, 0, &tmp))
-		return -EINVAL;	
-	if (tmp == 0) {//simulate aow tx
-		Direct_Audio_TX_debug();
-	} else if (tmp == 1) {//simulate aow rx
-		Direct_Audio_RX_debug();
-	}
-	return count;
-}
-
-extern void Direct_Audio_debug_dump(void);
-
-static ssize_t ath6kl_aow_read(struct file *file,
-					char __user *user_buf,
-					size_t count, loff_t *ppos)
-{
-	char buf[32];
-	int len;
-	
-	Direct_Audio_debug_dump();
-	len = snprintf(buf, sizeof(buf), "aow debug dump\n");
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static int ath6kl_aow_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static const struct file_operations fops_aow = {
-	.read = ath6kl_aow_read,
-	.write = ath6kl_aow_write,
-	.open = ath6kl_aow_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-#endif
 
 static ssize_t ath6kl_tx_rate_read(struct file *file,
 		char __user *user_buf,
@@ -6574,405 +6521,6 @@
 };
 
 
-#ifdef CONFIG_SWOW_SUPPORT
-extern int ath6kl_usb_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow);
-extern int ath6kl_usb_resume(struct ath6kl *ar);
-extern struct net_device *wlan0_ndev;
-#include <linux/inetdevice.h>
-
-void swow_set_suspend(struct ath6kl_vif *vif, int enable)
-{
-        if (vif) {
-                if (down_interruptible(&vif->ar->sem))
-                        return;
-                printk("%s[%d] enable=%d, current=%d\n",
-                        __func__, __LINE__, enable, vif->last_suspend_wow);
-                if (enable == 1 && vif->last_suspend_wow == 0) {
-                        /* enetr suspend mode */
-                        struct cfg80211_wowlan wow_setting;
-                        memset(&wow_setting, 0, sizeof(struct cfg80211_wowlan));
-                        wow_setting.disconnect = 1;
-                        wow_setting.gtk_rekey_failure = 1;
-                        ath6kl_usb_suspend(vif->ar, &wow_setting);
-                        vif->last_suspend_wow = 1;
-                }
-                if (enable == 0 && vif->last_suspend_wow == 1) {
-                  /* leave suspend mode */
-                        ath6kl_usb_resume(vif->ar);
-                        vif->last_suspend_wow = 0;
-                }
-                up(&vif->ar->sem);
-        }
-}
-
-/* File operation functions for SWOW*/
-static ssize_t ath6kl_swow_start_write(struct file *file,
-				const char __user *user_buf,
-				size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	struct ath6kl_vif *vif;
-	char buf[16], *p;
-	ssize_t len;
-	int option =0;
-	struct in_device *in_dev = __in_dev_get_rtnl(wlan0_ndev);
-	struct in_ifaddr *ifa;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-		
-	vif = ath6kl_vif_first(ar);
-
-	p = buf;
-	SKIP_SPACE;
-
-	sscanf(p, "%d", &option);
-	if( option > 9) {
-		ath6kl_err("out of range(0: Indoor, 1:Outdoor, 9:Stop)\n");
-		return -EFAULT;
-	}
-
-	if(vif && !test_bit(CONNECTED, &vif->flags)) {
-		ath6kl_err("Not Connnected\n");
-		return -EFAULT;
-	}
-	
-	switch(option) {
-	case 0:
-		if(1) {
-			// Indoor
-			ar->swow_mode = 0;
-			ar->swol_indoor_cmd.wlan_swol_indoor = 1;
-			ifa = in_dev->ifa_list;
-			if (ifa && ifa->ifa_local) {
-				ar->swol_indoor_cmd.swol_indoor_device_ip = ifa->ifa_local;
-			}
-			ath6kl_wmi_set_swol_indoor_info_cmd(ar->wmi, &ar->swol_indoor_cmd);
-			usleep_range(10000, 100000);
-			swow_set_suspend(vif, 1);
-		}else
-			ath6kl_err("swow indoor info should be set first.\n");
-		
-		break;
-	case 1:
-		// Outdoor, not available now.
-		break;
-	case 9:
-		// Stop
-		swow_set_suspend(vif, 0);
-		usleep_range(10000, 10000);
-		if( ar->swol_indoor_cmd.wlan_swol_indoor ) {
-			ar->swol_indoor_cmd.wlan_swol_indoor =0;
-			ath6kl_wmi_set_swol_indoor_info_cmd(ar->wmi, &ar->swol_indoor_cmd);
-		}
-		break;
-	default:
-		break;
-	}
-	
-	return count;
-}
-
-static const struct file_operations fops_swow_start = {
-	.write = ath6kl_swow_start_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_swow_waker_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[512];
-	int len =0, i=0;;
-	
-	len +=snprintf(buf, sizeof(buf), "Mode: %s\n", (ar->swow_mode ? "Outdoor" : "Indoor"));
-	for( i=0; i < 8; i++) {
-		len +=snprintf(buf +len, sizeof(buf) -len, "[%d] mac %02x:%02x:%02x:%02x:%02x:%02x mask %08x len %d key:%s\n", 
-			i,
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][0], 
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][1], 
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][2], 
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][3], 
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][4], 
-			ar->swol_indoor_cmd.swol_indoor_key_mac[i][5],
-			ar->swol_indoor_cmd.swol_indoor_app_mask[i],
-			ar->swol_indoor_cmd.swol_indoor_key_len[i],
-			ar->swol_indoor_cmd.swol_indoor_key[i]);
-	}
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_swow_waker_write(struct file *file,
-		const char __user *user_buf,
-		size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u32 index =0, app_mask;
-	int mac_addr[32];
-	u8 pwd[32];
-	char buf[64], *p;
-	ssize_t len;
-	int i = 0;
-    u32 tmp_len = 0;
-  
-	memset(pwd, 0, sizeof(pwd));
-	memset(mac_addr, 0, sizeof(mac_addr));
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	p = buf;
-	SKIP_SPACE;
-
-	sscanf(p, "%d", &index);
-	if( index > 7) {
-		ath6kl_err("out of password index range(0~7)\n");
-		return -EFAULT;
-	}else
-		ath6kl_err("swow index :%d\n", index);
-	
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%02x:%02x:%02x:%02x:%02x:%02x",
-			&mac_addr[0], &mac_addr[1], &mac_addr[2] ,&mac_addr[3] ,&mac_addr[4] ,&mac_addr[5]);
-	for( i=0; i <6; i++)
-		ar->swol_indoor_cmd.swol_indoor_key_mac[index][i] = mac_addr[i];
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%x\n", &app_mask);
-	ar->swol_indoor_cmd.swol_indoor_app_mask[index] = app_mask;
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp_len);
-	ar->swol_indoor_cmd.swol_indoor_key_len[index] = tmp_len;
-	memset( ar->swol_indoor_cmd.swol_indoor_key[index], 0, 16);
-
-	if(tmp_len > 16){
-		ath6kl_err("wrong key len\n");
-		return count;
-	}else if(tmp_len == 0)
-		return count;
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%s", pwd);
-	ath6kl_err("swow pwd:%s\n", pwd);
-
-	// set swow info
-	memcpy( ar->swol_indoor_cmd.swol_indoor_key[index], pwd, tmp_len);
-
-	return count;
-}
-
-static const struct file_operations fops_swow_waker = {
-	.read = ath6kl_swow_waker_read,
-	.write = ath6kl_swow_waker_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_swow_filter_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[512];
-	int len =0;
-	
-	len +=snprintf(buf, sizeof(buf), "waker_check:%d pw_check:%d\n", 
-		ar->swol_indoor_cmd.swol_indoor_waker_check,
-		ar->swol_indoor_cmd.swol_indoor_pw_check);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_swow_filter_write(struct file *file,
-		const char __user *user_buf,
-		size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u32 tmp =0;
-	char buf[64], *p;
-	ssize_t len;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	p = buf;
-	
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp);
-	ar->swol_indoor_cmd.swol_indoor_waker_check = tmp;
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp);
-	ar->swol_indoor_cmd.swol_indoor_pw_check = tmp;
-
-	if(ar->swol_indoor_cmd.swol_indoor_waker_check == 0 &&
-	   ar->swol_indoor_cmd.swol_indoor_pw_check == 1)
-	    ar->swol_indoor_cmd.swol_indoor_pw_check = 0;
-
-	return count;
-}
-
-static const struct file_operations fops_swow_filter = {
-	.read = ath6kl_swow_filter_read,
-	.write = ath6kl_swow_filter_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_swow_pattern_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[512];
-	int len =0;
-	
-	len +=snprintf(buf, sizeof(buf), "pattern:%d\n", 
-		ar->swol_indoor_cmd.swol_indoor_pattern);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_swow_pattern_write(struct file *file,
-		const char __user *user_buf,
-		size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u32 tmp =0;
-	char buf[64], *p;
-	ssize_t len;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	p = buf;
-	
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp);
-	ar->swol_indoor_cmd.swol_indoor_pattern = tmp;
-
-	return count;
-}
-
-static const struct file_operations fops_swow_pattern = {
-	.read = ath6kl_swow_pattern_read,
-	.write = ath6kl_swow_pattern_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_swow_exception_read(struct file *file, char __user *user_buf,
-				      size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	char buf[512];
-	int len =0;
-	
-	len +=snprintf(buf, sizeof(buf), "exception:%d exception_app:%d\n", 
-		ar->swol_indoor_cmd.swol_indoor_exception,
-		ar->swol_indoor_cmd.swol_indoor_exception_app);
-
-	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-}
-
-static ssize_t ath6kl_swow_exception_write(struct file *file,
-		const char __user *user_buf,
-		size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u32 tmp =0;
-	char buf[64], *p;
-	ssize_t len;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	p = buf;
-	
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp);
-	ar->swol_indoor_cmd.swol_indoor_exception = tmp;
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &tmp);
-	ar->swol_indoor_cmd.swol_indoor_exception_app = tmp;
-
-	return count;
-}
-
-static const struct file_operations fops_swow_exception = {
-	.read = ath6kl_swow_exception_read,
-	.write = ath6kl_swow_exception_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-static ssize_t ath6kl_swow_pulse_test_write(struct file *file,
-		const char __user *user_buf,
-		size_t count, loff_t *ppos)
-{
-	struct ath6kl *ar = file->private_data;
-	u32 type = 0, app = 0;
-	char buf[64], *p;
-	ssize_t len;
-
-	len = min(count, sizeof(buf) - 1);
-	if (copy_from_user(buf, user_buf, len))
-		return -EFAULT;
-
-	p = buf;
-	
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &type);
-	printk("type=%d\n", type);
-
-	SEEK_SPACE;
-	SKIP_SPACE;
-
-	sscanf(p, "%d\n", &app);
-	printk("app=%d\n", app);
-
-	ath6kl_wmi_set_swol_pulse_test_cmd(ar->wmi, type, app);
-
-	return count;
-}
-
-static const struct file_operations fops_swow_pulse_test = {
-	.write = ath6kl_swow_pulse_test_write,
-	.open = ath6kl_debugfs_open,
-	.owner = THIS_MODULE,
-	.llseek = default_llseek,
-};
-
-#endif
 
 int ath6kl_debug_init(struct ath6kl *ar)
 {
@@ -7224,10 +6772,6 @@
 
 	debugfs_create_file("bss_proc", S_IWUSR,
 				ar->debugfs_phy, ar, &fops_bss_proc);
-#ifdef DIRECT_AUDIO_SUPPORT
-	debugfs_create_file("aow", S_IRUSR | S_IWUSR,
-			    ar->debugfs_phy, ar, &fops_aow);
-#endif
 				
 	debugfs_create_file("sync_tsf", S_IWUSR | S_IWGRP | S_IWOTH,
 			    ar->debugfs_phy, ar, &fops_sync_tsf);
@@ -7244,25 +6788,6 @@
 	debugfs_create_file("rx_bundle_params", S_IRUSR | S_IWUSR,
 			    ar->debugfs_phy, ar, &fops_rx_bundle_params);
 
-#ifdef CONFIG_SWOW_SUPPORT
-	debugfs_create_file("swow_start", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_start);
-
-	debugfs_create_file("swow_waker", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_waker);
-
-	debugfs_create_file("swow_filter", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_filter);
-
-	debugfs_create_file("swow_pattern", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_pattern);
-
-	debugfs_create_file("swow_exception", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_exception);
-
-	debugfs_create_file("swow_pulse_test", S_IWUSR | S_IWGRP | S_IWOTH,
-				ar->debugfs_phy, ar, &fops_swow_pulse_test);
-#endif				
 	return 0;
 }
 
diff -urN ath6kl.orig/direct_audio.c ath6kl/direct_audio.c
--- ath6kl.orig/direct_audio.c	2016-01-28 11:15:40.462660364 +0800
+++ ath6kl/direct_audio.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,492 +0,0 @@
-ï»¿#include "core.h"
-#include "debug.h"
-#include "sda.h"
-
-#ifdef DIRECT_AUDIO_SUPPORT
-
-#define SDA_DEBUG	1
-
-#define DIRECT_AUDIO_LLC_TYPE 0x43FF
-#if SDA_DEBUG
-#define MAX_BUF_SIZE 1500 // bytes
-#define MAX_SHARE_MEM_ITEM	32
-#endif
-#define MAX_TX_POOL_ID 5
-
-struct Direct_Audio_Context {
-	u32		last_tx_process_time;
-	u32		max_tx_process_time;
-	u32		last_rx_process_time;
-	u32		max_rx_process_time;
-	struct ath6kl *ar;
-	u8		vif_id;
-};
-
-static struct Direct_Audio_Context	DA_context;
-SDA_SendDoneCallBack SDA_TX_DONE_CB = NULL;
-SDA_RecvCallBack SDA_RX_READY_CB = NULL;
-
-struct Direct_Audio_Setting_str {
-    u8  *pAddr;
-	u32 sizeTotal;
-	u32 lenUnit;
-	u32 lenHeadroom;
-	u8  *current_pAddr; 
-}__packed;
-
-static struct Direct_Audio_Setting_str global_TX_DA_Setting[MAX_TX_POOL_ID];
-static struct Direct_Audio_Setting_str global_RX_DA_Setting;
-
-#define TX_DA_INIT_ADDR(id)   global_TX_DA_Setting[id].pAddr
-#define TX_DA_ADDR(id)        global_TX_DA_Setting[id].current_pAddr
-#define TX_DA_POOL_SIZE(id)   global_TX_DA_Setting[id].sizeTotal
-#define TX_DA_UNIT_LEN(id)    global_TX_DA_Setting[id].lenUnit
-#define TX_DA_HEAD_ROOM(id)   global_TX_DA_Setting[id].lenHeadroom
-
-static void Direct_Audio_Tx_Setting(u32 BufferId,u8 *pAddr, u32 sizeTotal, u16 lenUnit, u16 lenHeadroom)
-{
-	if(BufferId >= MAX_TX_POOL_ID)
-	{
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: BufferId %d excess MAX_TX_POOL_ID %d\n", __func__, BufferId, MAX_TX_POOL_ID);
-		return;
-	}
-    TX_DA_INIT_ADDR(BufferId) = pAddr;
-	TX_DA_ADDR(BufferId) = pAddr;
-	TX_DA_POOL_SIZE(BufferId) = sizeTotal;
-	TX_DA_UNIT_LEN(BufferId) = lenUnit;
-	TX_DA_HEAD_ROOM(BufferId) = lenHeadroom;
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]BufferId=%d,pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
-	        __func__, __LINE__, BufferId, pAddr, sizeTotal, lenUnit, lenHeadroom);	
-}
-
-#define RX_DA_INIT_ADDR   global_RX_DA_Setting.pAddr
-#define RX_DA_ADDR        global_RX_DA_Setting.current_pAddr
-#define RX_DA_POOL_SIZE   global_RX_DA_Setting.sizeTotal
-#define RX_DA_UNIT_LEN    global_RX_DA_Setting.lenUnit
-#define RX_DA_HEAD_ROOM   global_RX_DA_Setting.lenHeadroom
-
-static void Direct_Audio_Rx_Setting(u8 *pAddr, u32 sizeTotal, u32 lenUnit, u32 lenHeadroom)
-{
-    RX_DA_INIT_ADDR = pAddr;
-	RX_DA_ADDR = pAddr;
-	RX_DA_POOL_SIZE = sizeTotal;
-	RX_DA_UNIT_LEN = lenUnit;
-	RX_DA_HEAD_ROOM = lenHeadroom;
-	
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d] pAddr=0%p,sizeTotal=%d,lenUnit=%d,lenHeadroom=%d\r\n",
-	    __func__, __LINE__, pAddr, sizeTotal, lenUnit, lenHeadroom);	
-}
-
-//SDA_SendDoneCallBack  SDA_TX_DONE_CB = NULL;
-#define SDA_BUF_READY(_desc)      	!!_desc->m_ReadyToCopy
-#define TX_SDA_INIT_ADDR			orig_data_p
-#define TX_SDA_ADDR 				descp_p
-#define TX_SDA_POOL_SIZE			BufferSize
-#define TX_SDA_UNIT_LEN(id)				TX_DA_UNIT_LEN(id)
-#define CLR_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 0
-#define SET_SDA_BUF_READY(_desc)  	_desc->m_ReadyToCopy = 1
-static void SDA_Tx_fun( struct net_device *dev, u32 BufferId, u8 *pBuffer, u32 BufferSize)
-{
-	u8 *orig_data_p = pBuffer;
-	u8 *data_p = pBuffer;
-	u8 *descp_p = pBuffer;
-	struct SDA_Descriptor *tx_desc = (struct SDA_Descriptor *) data_p;
-	if(BufferId >= MAX_TX_POOL_ID)
-	{
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: BufferId excess %d\n", __func__, MAX_TX_POOL_ID);
-		goto tx_fail;
-	}
-	if (!data_p || !SDA_BUF_READY(tx_desc)) {
-		//Should not into here
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: descriptor show not ready\n", __func__);
-		goto tx_fail;
-	}
-	/*Check descriptor*/
-	do {
-		struct sk_buff *skb;
-		int send_len = 0;
-		struct ethhdr *eth_hdr;
-		int alloc_size = 0;
-
-		/* point to RAW_Data
-		* Assume offset include Descriptor & Headroom 
-		*/
-		data_p += sizeof(SDA_Header_t);
-		/*Create skb, copy data, fill skb header*/
-		alloc_size = tx_desc->m_PayloadSize+sizeof(struct ethhdr);
-		skb = ath6kl_buf_alloc(alloc_size);
-		if (skb == NULL) {
-			//should not happened
-			ath6kl_dbg(ATH6KL_DBG_DA,"%s: Allocate skb failed\n", __func__);
-			break;
-		}
-
-		skb_put(skb, alloc_size);
-		memset(skb->data, 0, alloc_size);
-		//Copy data from share buf to skb
-		memcpy(skb->data, data_p-sizeof(struct ethhdr), tx_desc->m_PayloadSize+sizeof(struct ethhdr));
-		send_len += tx_desc->m_PayloadSize+sizeof(struct ethhdr);
-		
-		
-		eth_hdr = (struct ethhdr *)(skb->data);
-		skb->protocol = ntohs(eth_hdr->h_proto);	
-		skb->dev = dev;
-
-		/*Adjust the length of data before send*/ 
-		skb_trim(skb, send_len);
-		ath6kl_dbg(ATH6KL_DBG_DA, "%s[%d]BufferId=%d,audio len = %d,data len = %d\n",
-		        __func__, __LINE__, BufferId, tx_desc->m_PayloadSize, send_len);
-		/*{
-			int kkk;
-			for(kkk = 0;kkk<send_len;kkk++) {
-				if(kkk % 16 == 0)
-					printk("\n\r");
-				printk("%02x ",skb->data[kkk]);
-			}
-			printk("\n\r");
-		}*/
-		//Call normal tx path
-		ath6kl_data_tx(skb, dev, true);
-
-		//Clear share buffer Ready flag
-		CLR_SDA_BUF_READY(tx_desc);
-		//To-do: call SS complete routine
-
-		//Next frame & check if need retrun pAddr of DA Share buff
-		if(((TX_SDA_ADDR - TX_SDA_INIT_ADDR)+TX_SDA_UNIT_LEN(BufferId)) >= TX_SDA_POOL_SIZE ) {
-			/*Return to Init buf addr*/
-			TX_SDA_ADDR = TX_SDA_INIT_ADDR;
-		} else {
-			/*Go to Next buf*/
-			TX_SDA_ADDR += TX_SDA_UNIT_LEN(BufferId);	   
-		}
-		data_p = TX_SDA_ADDR;
-		tx_desc = (struct SDA_Descriptor *) data_p;
-	   
-	} while(SDA_BUF_READY(tx_desc));//Check if having next
-tx_fail:
-	if (SDA_TX_DONE_CB)
-		SDA_TX_DONE_CB(BufferId,pBuffer,BufferSize);
-}
-
-/*Assume The RX Already to be Packet Mode*/
-void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb)
-{
-    u32 tsf_ie=0, tsf_data=0;
-    u8 *data_p = RX_DA_ADDR;
-    struct SDA_Descriptor *rx_desc = (struct SDA_Descriptor *) data_p;
-
-    if (skb == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: input buf should not be NULL\n", __func__);
-		return;
-	}
-	if (!data_p) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: DSP dose not register rx pool\n", __func__);
-		dev_kfree_skb(skb);
-		return;
-	}
-
-	if(SDA_BUF_READY(rx_desc)) {
-	   //the share buf not available. DO NOT PUT PRINT LOG HERE.
-	   goto rx_fail;
-	}
-	
-#define TSF_IE 0x1234fedc
-    tsf_ie = le32_to_cpu(*((u32 *)(skb->data + skb->len - 2*sizeof(u32))));
-    if (tsf_ie == TSF_IE){
-      skb_trim(skb, (skb->len - 2*sizeof(u32)));
-
-      tsf_data = le32_to_cpu(*((u32 *)(skb->data + skb->len + sizeof(u32))));
-      //printk("~~current-tsf (%x) \n",tsf_data);
-    }
-	//Fill derscriptort
-	rx_desc->m_PayloadSize = skb->len;//no ethernet header included and remove TSF_IE
-    rx_desc->m_TimeStamp = 0 ;
-
-	if (skb->len > (RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM)) {
-	    //Should not happen
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: Not having enough room for RX DATA\n", __func__);
-		skb->len = RX_DA_UNIT_LEN-sizeof(struct SDA_Descriptor)-RX_DA_HEAD_ROOM;
-	}
-	//copy to share buf & Skip the length of "struct ethhdr"
-	memcpy((data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM) - sizeof(struct ethhdr),
-           skb->data -sizeof(struct ethhdr), 
-		   skb->len + sizeof(struct ethhdr));
-	
-	// Set rx timestamp
-	memcpy(data_p + sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM +sizeof(u32),
-			&tsf_data, sizeof(u32));	
-
-	//To-do: :Call SS Direct Audio RX routine
-	ath6kl_dbg(ATH6KL_DBG_DA, "%s[%d]audio len=%d\n\r",__func__,__LINE__,rx_desc->m_PayloadSize);
-	/*{
-		int kkk;
-		u8	*debug_ptr = data_p+sizeof(struct SDA_Descriptor) + RX_DA_HEAD_ROOM - sizeof(struct ethhdr);
-		for(kkk = 0;kkk<(rx_desc->m_PayloadSize+sizeof(struct ethhdr));kkk++) {
-			if(kkk % 16 == 0)
-				printk("\n\r");
-			printk("%02x ",debug_ptr[kkk]);
-		}
-		printk("\n\r");
-	}*/	
-	SET_SDA_BUF_READY(rx_desc);
-	if (SDA_RX_READY_CB)
-		SDA_RX_READY_CB((u8*)rx_desc,RX_DA_UNIT_LEN);
-
-	//Next DA Share buff
-	if(((RX_DA_ADDR - RX_DA_INIT_ADDR)+RX_DA_UNIT_LEN) >= RX_DA_POOL_SIZE ) {
-	    /*Return to Init buf addr*/
-	    RX_DA_ADDR = RX_DA_INIT_ADDR;
-	} else {
-	    /*Go to Next buf*/
-	    RX_DA_ADDR += RX_DA_UNIT_LEN;	   
-	}
-rx_fail:	
-    dev_kfree_skb(skb);
-}
-
-void SDA_function4Send(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
-{
-	struct ath6kl_vif *vif;
-	u32	entry_time;
-	if (DA_context.ar == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: DA_context.ar should not be NULL\n", __func__);
-		return;
-	}
-	vif = ath6kl_get_vif_by_index(DA_context.ar, DA_context.vif_id);
-	if (!vif) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: Failed to find vif for direct audio, DA_context.ar=%p, DA_context.vif_id=%d\n", __func__, DA_context.ar, DA_context.vif_id);
-		return;
-	}
-	entry_time = jiffies;
-	SDA_Tx_fun(vif->ndev,BufferId,pBuffer,BufferSize);
-	DA_context.last_tx_process_time = jiffies - entry_time;
-	
-	if (DA_context.max_tx_process_time < DA_context.last_tx_process_time)
-		DA_context.max_tx_process_time = DA_context.last_tx_process_time;
-}
-
-void SDA_function4RecvDone(unsigned char *pBuffer, unsigned int BufferSize)
-{
-	//what should we do in this API
-	ath6kl_dbg(ATH6KL_DBG_DA, "%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",__func__,__LINE__,pBuffer,BufferSize);
-}
-
-void SDA_setSharedMemory4Send(unsigned int BufferId, unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize)
-{
-	Direct_Audio_Tx_Setting(BufferId,pBufferTotal, BufferTotalSize, BufferUnitSize, HeadroomSize);	
-}
-
-void SDA_setSharedMemory4Recv(unsigned char *pBufferTotal, unsigned int BufferTotalSize, unsigned int BufferUnitSize, unsigned int HeadroomSize)
-{
-	Direct_Audio_Rx_Setting(pBufferTotal, BufferTotalSize, BufferUnitSize, HeadroomSize);
-}
-
-//Register callback which Mck notify DSP that Mck has received the audio packet
-void SDA_registerCallback4Recv(SDA_RecvCallBack pCallback)
-{
-	SDA_RX_READY_CB = pCallback;
-}
-
-//Register callback which Mck notify DSP that Mck has sent the audio packet
-void SDA_registerCallback4SendDone(SDA_SendDoneCallBack pCallback)
-{
-	ath6kl_dbg(ATH6KL_DBG_DA, "%s[%d]\n\r",__func__,__LINE__);
-	SDA_TX_DONE_CB = pCallback;
-}
-
-void Direct_Audio_debug_dump(void)
-{
-	ath6kl_dbg(ATH6KL_DBG_DA,"DA_context.ar = 0x%x\n\r",(int)DA_context.ar);
-	ath6kl_dbg(ATH6KL_DBG_DA,"DA_context.last_tx_process_time = %u\n\r",DA_context.last_tx_process_time);
-	ath6kl_dbg(ATH6KL_DBG_DA,"DA_context.max_tx_process_time = %u\n\r",DA_context.max_tx_process_time);
-	ath6kl_dbg(ATH6KL_DBG_DA,"DA_context.last_rx_process_time = %u\n\r",DA_context.last_rx_process_time);
-	ath6kl_dbg(ATH6KL_DBG_DA,"DA_context.max_rx_process_time = %u\n\r",DA_context.max_rx_process_time);
-}
-
-void Direct_Audio_init(struct ath6kl *ar)
-{
-	int i;
-	
-	memset(&global_RX_DA_Setting, 0x0, sizeof(global_RX_DA_Setting));
-	for (i = 0; i < MAX_TX_POOL_ID; i++)
-	    memset(&global_TX_DA_Setting[i], 0x0, sizeof(global_TX_DA_Setting[0]));
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]\n\r",__func__,__LINE__);
-
-	memset(&DA_context,0x00,sizeof(DA_context));
-
-	DA_context.ar = ar;
-	DA_context.vif_id = 1;//use p2p0 as default
-}
-
-void Direct_Audio_deinit(struct ath6kl *ar)
-{
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]\n\r",__func__,__LINE__);
-}
-
-void SDA_GetTSF(unsigned int *pTsf)
-{
-    u32 datah = 0, datal = 0;
-#define TSF_TO_TU(_h,_l)    ((((u64)(_h)) << 32) | ((u64)(_l)))
-#define REG_TSF_L 0x5054
-#define REG_TSF_H 0x5058
-	
-	if (DA_context.ar == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: DA_context.ar should not be NULL\n", __func__);
-		return;
-	}
-		
-	ath6kl_diag_read32(DA_context.ar, REG_TSF_L, &datal);
-	ath6kl_diag_read32(DA_context.ar, REG_TSF_H, &datah);
-	*((u64 *)pTsf)  = TSF_TO_TU(datah, datal);
-}
-
-unsigned long long SDA_getTsf (unsigned char vif_id)
-{
-    u32 datah = 0, datal = 0;
-#define TSF_TO_TU(_h,_l)    ((((u64)(_h)) << 32) | ((u64)(_l)))
-#define REG_TSF_L 0x5054
-#define REG_TSF_H 0x5058
-#define REG_TSF2_L 0x50d4
-#define REG_TSF2_H 0x50d8
-	
-	if (DA_context.ar == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: DA_context.ar should not be NULL\n", __func__);
-		return 0;
-	}
-
-	if (vif_id) {/*p2p0*/
-	    ath6kl_diag_read32(DA_context.ar, REG_TSF2_L, &datal);
-	    ath6kl_diag_read32(DA_context.ar, REG_TSF2_H, &datah);    
-    } else {/*wlan0*/
-	    ath6kl_diag_read32(DA_context.ar, REG_TSF_L, &datal);
-	    ath6kl_diag_read32(DA_context.ar, REG_TSF_H, &datah);
-    }
-	return TSF_TO_TU(datah, datal);
-}
-
-int SDA_syncTsf (void)
-{
-    struct ath6kl *ar;
-    int ret;
-    
-	if (DA_context.ar == NULL) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s: DA_context.ar should not be NULL\n", __func__);
-		return 0;
-	}
-    ar = DA_context.ar;
-    ret = ath6kl_wmi_set_sync_tsf_cmd(ar->wmi, 1);
-    return (ret?(-1):0);
-}
-
-#if SDA_DEBUG//debug use
-struct D_A_SHARE_MEM {
-    SDA_Header_t	desc;
-	u8				data[MAX_BUF_SIZE];
-};
-
-static void debug_tx_done_cb(unsigned int BufferId, unsigned char *pBuffer, unsigned int BufferSize)
-{
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
-	        __func__, __LINE__, BufferId, pBuffer, BufferSize);
-}
-
-int Direct_Audio_TX_debug(void) 
-{
-	u8	*buf;
-	u32 len,i,BufferSize;
-	u8	*ptr,*eth_ptr;
-	SDA_Descriptor_t *share_mem_ptr;
-	struct ath6kl_vif *vif;
-	u8	test_mymac[6] = {0x00,0x03,0x7f,0x20,0x52,0xa4};
-	u8	test_peermac[6] = {0x84,0xc9,0xb2,0x11,0xf3,0x41};
-	struct ethhdr *eth_hdr;
-
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]Simulate TX behavior\n\r",__func__,__LINE__);
-	SDA_registerCallback4SendDone(debug_tx_done_cb);
-
-	len = (sizeof(SDA_Header_t)+MAX_BUF_SIZE)*MAX_SHARE_MEM_ITEM;
-	buf = kmalloc(len, GFP_ATOMIC);
-	if (!buf)
-		return -ENOMEM;
-	SDA_setSharedMemory4Send(0, buf, len, sizeof(SDA_Header_t)+MAX_BUF_SIZE, 50);		
-	//SDA_registerIf(0);//use wlan0
-	ptr	= buf;
-	//construct tx share memory
-	vif = ath6kl_get_vif_by_index(DA_context.ar, DA_context.vif_id);
-	if(!vif)
-		return -ENOMEM;	
-	memcpy(test_peermac,vif->bssid,6);
-	memcpy(test_mymac,vif->ndev->dev_addr,6);
-	memset(buf,0x00,len);
-	share_mem_ptr = (SDA_Descriptor_t *)buf;
-	BufferSize = 0;
-	
-	for (i=0; i<MAX_SHARE_MEM_ITEM; i++) {
-		//fill descript
-		share_mem_ptr->m_ReadyToCopy = 1;
-		share_mem_ptr->m_PayloadSize = 5*(i+1);
-		share_mem_ptr->m_TimeStamp = 0;
-		//fill ethernet header
-		eth_ptr = ptr+sizeof(SDA_Header_t)-sizeof(struct ethhdr);
-		eth_hdr = (struct ethhdr *)eth_ptr;
-		memcpy(eth_hdr->h_dest,test_peermac,6);
-		memcpy(eth_hdr->h_source,test_mymac,6);
-		eth_hdr->h_proto = htons(DIRECT_AUDIO_LLC_TYPE);	
-		
-		memset(ptr+sizeof(SDA_Header_t),i,share_mem_ptr->m_PayloadSize);
-		BufferSize += sizeof(SDA_Header_t) + MAX_BUF_SIZE;
-		ptr = ptr + sizeof(SDA_Header_t) + MAX_BUF_SIZE;
-		share_mem_ptr = (SDA_Descriptor_t *)ptr;
-	}
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]BufferId=%d,pBuffer=0x%p,BufferSize=%d\n\r",
-	        __func__, __LINE__, 0, buf, BufferSize);
-	//notify Direct Audio module to send packet
-	SDA_function4Send(0, buf, BufferSize);
-
-	kfree(buf);
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]Simulate TX finish\n\r",__func__,__LINE__);
-	return 0;
-}
-
-static void debug_rx_ready_cb(unsigned char *pBuffer, unsigned int BufferSize)
-{
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]pBuffer=0x%p,BufferSize=%d\n\r",
-	        __func__, __LINE__, pBuffer, BufferSize);
-}
-
-int Direct_Audio_RX_debug(void)
-{
-	u8	*buf;
-	u32 len;
-	
-	if(RX_DA_INIT_ADDR) {
-		ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]already rx debug\n\r",__func__,__LINE__);
-		return -1;
-	}
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]SimulateRX behavior\n\r",__func__,__LINE__);
-	len = sizeof(struct D_A_SHARE_MEM)*MAX_SHARE_MEM_ITEM;
-	buf = kmalloc(len, GFP_ATOMIC);
-	if (!buf)
-		return -ENOMEM;
-	//construct rx share memory
-	memset(buf,0x00,len);
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]buf=0x%p\n\r", __func__, __LINE__, buf);
-	SDA_setSharedMemory4Recv(buf, len, sizeof(struct D_A_SHARE_MEM), 50);
-	//Direct_Audio_RxReady_Notify_cb_Reg(debug_rx_ready_cb);
-	SDA_registerCallback4Recv(debug_rx_ready_cb);
-	ath6kl_dbg(ATH6KL_DBG_DA,"%s[%d]Simulate RX finish\n\r",__func__,__LINE__);
-	return 0;
-}
-#endif //if SDA_DEBUG
-
-EXPORT_SYMBOL(SDA_function4Send);
-EXPORT_SYMBOL(SDA_function4RecvDone);
-EXPORT_SYMBOL(SDA_setSharedMemory4Send);
-EXPORT_SYMBOL(SDA_setSharedMemory4Recv);
-EXPORT_SYMBOL(SDA_registerCallback4SendDone);
-EXPORT_SYMBOL(SDA_registerCallback4Recv);
-EXPORT_SYMBOL(SDA_GetTSF);
-EXPORT_SYMBOL(SDA_getTsf);
-EXPORT_SYMBOL(SDA_syncTsf);
-#endif
diff -urN ath6kl.orig/.git/HEAD ath6kl/.git/HEAD
--- ath6kl.orig/.git/HEAD	2016-01-28 11:15:40.482660364 +0800
+++ ath6kl/.git/HEAD	1970-01-01 08:00:00.000000000 +0800
@@ -1 +0,0 @@
-1001434fdcf0e5c9f56db9595438f0877614b938
Binary files ath6kl.orig/.git/index and ath6kl/.git/index differ
diff -urN ath6kl.orig/init.c ath6kl/init.c
--- ath6kl.orig/init.c	2016-01-28 11:15:40.462660364 +0800
+++ ath6kl/init.c	2016-01-28 11:16:06.934660848 +0800
@@ -3029,9 +3029,6 @@
 	return 0;
 }
 
-#ifdef CONFIG_SWOW_SUPPORT
-struct net_device *wlan0_ndev;
-#endif
 
 u8 registered_idx_0 = 0;
 int ath6kl_core_init(struct ath6kl *ar)
@@ -3363,10 +3360,6 @@
 		ar->conf_flags |= ATH6KL_CONF_SKB_DUP;
 	else
 		ath6kl_info(" skb copy disable\n");
-    
-#ifdef CONFIG_SWOW_SUPPORT
-	wlan0_ndev = ndev;
-#endif
 
 	return ret;
 
@@ -3492,7 +3485,21 @@
 	clear_bit(WMI_ENABLED, &ar->flag);
   
 	up(&ar->wmi_evt_sem);
-  
+
+#ifdef QCMBR_TCMD
+	if (testmode == 2) {
+	    spin_lock_bh(&ar->qcmbr_queue_lock);
+	    if (!list_empty(&ar->qcmbr_queue_head)) {
+	        qcmbr_queue_t *msg_buf, *tmp_buf;
+	        list_for_each_entry_safe(msg_buf, tmp_buf, &ar->qcmbr_queue_head, list) {
+	            list_del(&msg_buf->list);
+	            kfree(msg_buf);
+	        }
+	    }
+	    spin_unlock_bh(&ar->qcmbr_queue_lock);
+	}	
+#endif /* QCMBR_TCMD */
+
 	if (ar->htc_target) {
 		ath6kl_dbg(ATH6KL_DBG_TRC, "%s: shut down htc\n", __func__);
 		ath6kl_htc_stop(ar->htc_target);
diff -urN ath6kl.orig/Kbuild ath6kl/Kbuild
--- ath6kl.orig/Kbuild	2016-01-28 11:15:40.458660364 +0800
+++ ath6kl/Kbuild	2016-01-28 11:16:06.934660848 +0800
@@ -118,7 +118,6 @@
 ath6kl_usb-$(CONFIG_ACS_SUPPORT) += acs.o
 ath6kl_usb-$(CONFIG_ACL_SUPPORT) += acl_ioctl.o
 ath6kl_usb-$(CONFIG_TX99_SUPPORT) += tx99_ioctl.o
-ath6kl_usb-$(CONFIG_DIRECT_AUDIO_SUPPORT) += direct_audio.o
 
 ccflags-y += -DCONFIG_QC_INTERNAL
 ccflags-$(CONFIG_FPGA) += -DCONFIG_FPGA
diff -urN ath6kl.orig/main.c ath6kl/main.c
--- ath6kl.orig/main.c	2016-01-28 11:15:40.466660364 +0800
+++ ath6kl/main.c	2016-01-28 11:16:06.934660848 +0800
@@ -2266,6 +2266,7 @@
 	return &vif->net_stats;
 }
 
+
 static int ath6kl_ioctl_p2p_set_ps(struct ath6kl_vif *vif,
 				char *user_cmd,
 				int len)
@@ -2593,6 +2594,7 @@
 					ret = 0;
 				}
 #endif
+
 				else {
 					ath6kl_dbg(ATH6KL_DBG_TRC,
 						"not yet support \"%s\"\n",
@@ -3402,10 +3404,9 @@
 {
     struct ath6kl *ar = ath6kl_priv(dev);
     int ret = 0;
-    int i, j;
+    int i;
     struct ioctl_priv_params *data;
     struct ath6kl_vif *vif = netdev_priv(dev);
-    u8 ip_addrs[4];
     
     data = kmalloc(sizeof(struct ioctl_priv_params), GFP_ATOMIC);
     if (!data)
@@ -3747,123 +3748,6 @@
     case IOCTL_PRIV_PS_SET:
         ath6kl_cfg80211_set_power_mgmt(NULL, dev, (data->params.power_save.ps_set)?1:0,-1);
         break;
-    case IOCTL_PRIV_SWOW_START:
-        if(!test_bit(CONNECTED, &vif->flags)) {
-            ath6kl_err("Not Connnected\n");
-            kfree(data);
-            return -EFAULT;
-        }
-        switch(data->params.swow_start.cmd) {
-        case 0:
-            if(1) {
-                // Indoor
-                ath6kl_wmi_usb_cut_cmd(ar->wmi, 30);
-                ar->swow_mode = 0;
-                ar->swol_indoor_cmd.wlan_swol_indoor = 1;
-                
-                ret = ath6kl_parse_arp_offload_ip_addrs(data->params.swow_start.arp_ip_addr,
-                    strlen(data->params.swow_start.arp_ip_addr), ip_addrs);
-
-                if(ret) {
-                    return ret;
-                }
-
-                memcpy(&(ar->swol_indoor_cmd.swol_indoor_device_ip), ip_addrs, sizeof(u32));
-		
-                ath6kl_wmi_set_swol_indoor_info_cmd(ar->wmi, &ar->swol_indoor_cmd);
-                usleep_range(10000, 100000);
-                swow_set_suspend(vif, 1);
-            }else
-                ath6kl_err("swow indoor info should be set first.\n");
-            break;
-        case 1:
-            // Outdoor, not available now.
-            break;
-        case 9:
-            // Stop
-            swow_set_suspend(vif, 0);
-            usleep_range(10000, 10000);
-            if( ar->swol_indoor_cmd.wlan_swol_indoor ) {
-                ar->swol_indoor_cmd.wlan_swol_indoor =0;
-                ath6kl_wmi_set_swol_indoor_info_cmd(ar->wmi, &ar->swol_indoor_cmd);
-            }
-            break;
-        default:
-            break;
-        }
-        break;
-    case IOCTL_PRIV_SWOW_WAKER_W:
-        {
-            struct waker *waker_w = &(data->params.swow_waker_w.write_waker);
-            int index = data->params.swow_waker_w.waker_id;
-
-            if(index > 7){
-               ath6kl_err("out of index[0~7] : %d\n", index);
-               kfree(data);
-               return -EINVAL;
-            }
-
-            for( i=0; i <6; i++)
-                ar->swol_indoor_cmd.swol_indoor_key_mac[index][i] = waker_w->key_mac[i];
-                
-            ar->swol_indoor_cmd.swol_indoor_app_mask[index] = waker_w->app_mask;
-            ar->swol_indoor_cmd.swol_indoor_key_len[index] = waker_w->key_len;
-            memset( ar->swol_indoor_cmd.swol_indoor_key[index], 0, 16);
-            if(waker_w->key_len > 16){
-                ath6kl_err("wrong key len\n");
-                kfree(data);
-                return -EINVAL;
-            }
-            
-            memcpy(ar->swol_indoor_cmd.swol_indoor_key[index], waker_w->key, waker_w->key_len);
-        
-        }
-        break;
-    case IOCTL_PRIV_SWOW_WAKER_R:
-        {
-            struct waker *waker_r;
-            
-            for( j=0; j < 8; j++) {
-                waker_r = &(data->params.swow_waker_r.read_waker[j]);
-                for( i=0; i <6; i++)
-                    waker_r->key_mac[i] = ar->swol_indoor_cmd.swol_indoor_key_mac[j][i];
-                waker_r->app_mask = ar->swol_indoor_cmd.swol_indoor_app_mask[j];
-                waker_r->key_len = ar->swol_indoor_cmd.swol_indoor_key_len[j];
-                waker_r->key_len = ar->swol_indoor_cmd.swol_indoor_key_len[j];
-                memset(waker_r->key, 0, 16);
-                memcpy(waker_r->key, ar->swol_indoor_cmd.swol_indoor_key[j], waker_r->key_len);
-            }
-        }
-        break;
-    case IOCTL_PRIV_SWOW_EXCEPTION_W:
-        ar->swol_indoor_cmd.swol_indoor_exception = data->params.swow_exception.exception;
-        ar->swol_indoor_cmd.swol_indoor_exception_app = data->params.swow_exception.exception_app;
-        break;
-    case IOCTL_PRIV_SWOW_EXCEPTION_R:
-        data->params.swow_exception.exception = ar->swol_indoor_cmd.swol_indoor_exception;
-        data->params.swow_exception.exception_app = ar->swol_indoor_cmd.swol_indoor_exception_app;
-        break;
-    case IOCTL_PRIV_SWOW_PATTEN_W:
-        ar->swol_indoor_cmd.swol_indoor_pattern = data->params.swow_pattern.pattern;
-        break;
-    case IOCTL_PRIV_SWOW_PATTEN_R:
-        data->params.swow_pattern.pattern = ar->swol_indoor_cmd.swol_indoor_pattern;
-        break;
-    case IOCTL_PRIV_SWOW_FILTER_W:
-        ar->swol_indoor_cmd.swol_indoor_waker_check = data->params.swow_filter.waker_check;
-        ar->swol_indoor_cmd.swol_indoor_pw_check = data->params.swow_filter.pw_check;
-        if(ar->swol_indoor_cmd.swol_indoor_waker_check == 0 && ar->swol_indoor_cmd.swol_indoor_pw_check == 1)
-            ar->swol_indoor_cmd.swol_indoor_pw_check = 0;
-        break;
-    case IOCTL_PRIV_SWOW_FILTER_R:
-        data->params.swow_filter.waker_check = ar->swol_indoor_cmd.swol_indoor_waker_check;
-        data->params.swow_filter.pw_check = ar->swol_indoor_cmd.swol_indoor_pw_check;
-        break;
-    case IOCTL_PRIV_SWOW_PULSE_TEST:
-        ath6kl_wmi_set_swol_pulse_test_cmd(ar->wmi,
-               data->params.swow_pulse_test.type,
-               data->params.swow_pulse_test.app);
-        break;
     case IOCTL_PRIV_RX_BUNFLE_PARAMS_W:
         if(data->params.rx_bundle_params.min_rx_bundle_frame > 10) {
             ath6kl_err("min_rx_bundle_frame (%d):should less than 10\n",
@@ -3886,6 +3770,108 @@
     return ret;
 }
 
+#ifdef QCMBR_TCMD
+
+struct tcmd_tlv_response_head{
+	u32 perserve;
+	u32 act;
+	u16 len;
+};
+
+struct tcmd_qcmbr_header{
+	u16 lenth;
+	u16 mck_patten;
+	u32 act;
+	u32 reserved;
+};
+static int ath6kl_qcmbr_unified_ioctl(struct ath6kl_vif *vif,
+				qcmbr_data_t * pqcmbr_data)
+{
+	int ret=0;
+	struct ath6kl *ar = vif->ar;
+	qcmbr_queue_t *qcmbr_buf = NULL;
+	struct tcmd_tlv_response_head *tcmdtlvrxhead;
+	struct tcmd_qcmbr_header *tcmdqcmbrhead;
+
+	switch (pqcmbr_data->cmd) {
+		case ATH_XIOCTL_UNIFIED_UTF_CMD:
+		{
+			pqcmbr_data->copy_to_user = 0;
+			if(pqcmbr_data->length) {
+				ret = ath6kl_wmi_test_cmd(vif->ar->wmi, pqcmbr_data->buf, pqcmbr_data->length);
+			}
+		}
+		break;
+
+		case ATH_XIOCTL_UNIFIED_UTF_RSP:
+		{
+            if (!list_empty(&ar->qcmbr_queue_head)) {
+				pqcmbr_data->copy_to_user = 1;
+				spin_lock_bh(&ar->qcmbr_queue_lock);
+				qcmbr_buf = list_first_entry(&ar->qcmbr_queue_head,
+								qcmbr_queue_t, list);
+				list_del(&qcmbr_buf->list);
+				spin_unlock_bh(&ar->qcmbr_queue_lock);
+				ret = 0;
+			} else {
+				ret = -1;
+			}
+
+			if (!ret) {
+				memcpy(pqcmbr_data->buf, qcmbr_buf->utf_buf,
+					qcmbr_buf->length);
+				tcmdtlvrxhead = (struct tcmd_tlv_response_head *)qcmbr_buf->utf_buf;
+				tcmdqcmbrhead = (struct tcmd_qcmbr_header *)pqcmbr_data->buf;
+
+				pqcmbr_data->length = tcmdtlvrxhead->len;
+				tcmdqcmbrhead->lenth =  tcmdtlvrxhead->len;
+				tcmdqcmbrhead->mck_patten = 0x6004;
+				kfree(qcmbr_buf);
+			} else {
+				ret = -EAGAIN;
+			}
+		}
+		break;
+	}
+	return ret;
+}
+
+static int ath6kl_ioctl_tcmd(struct net_device *dev,
+				struct ifreq *rq,
+				int cmd)
+{
+	int ret = true;
+
+	struct ath6kl_vif *vif = netdev_priv(dev);
+	qcmbr_data_t *qcmbr_data;
+
+	qcmbr_data = kmalloc(sizeof(qcmbr_data_t), GFP_KERNEL);
+	if(qcmbr_data == NULL) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	memset(qcmbr_data, 0, sizeof(qcmbr_data_t));
+
+	if(copy_from_user(qcmbr_data, rq->ifr_data, sizeof(*qcmbr_data))) {
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	ret = ath6kl_qcmbr_unified_ioctl(vif, qcmbr_data);
+
+	if(qcmbr_data->copy_to_user) {
+		ret = copy_to_user(rq->ifr_data, qcmbr_data->buf,
+		qcmbr_data->length+sizeof(struct tcmd_qcmbr_header));
+		printk(KERN_DEBUG "copy to user done with len %d + header size\n", qcmbr_data->length);
+	}
+
+exit:
+	kfree(qcmbr_data);
+	return ret;
+}
+#endif /* QCMBR_TCMD */
+
 int ath6kl_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct ath6kl *ar = ath6kl_priv(dev);
@@ -3922,12 +3908,18 @@
 	case IEEE80211_IOCTL_DELMAC:
 	case IEEE80211_IOCTL_GET_MACADDR:
 #endif
+		ret = ath6kl_ioctl_standard(dev, rq, cmd);
+		break;
 #ifdef TX99_SUPPORT
 	case SIOCIOCTLTX99:/* TX99 */
 #else
 	case ATH6KL_IOCTL_STANDARD13:	/* TX99 */
 #endif
+#ifdef QCMBR_TCMD
+		ret = ath6kl_ioctl_tcmd(dev, rq, cmd);
+#else
 		ret = ath6kl_ioctl_standard(dev, rq, cmd);
+#endif /* QCMBR_TCMD */
 		break;
 #ifndef CE_SUPPORT
 	case ATH6KL_IOCTL_WEXT_PRIV6:
diff -urN ath6kl.orig/Makefile ath6kl/Makefile
--- ath6kl.orig/Makefile	2016-01-28 11:15:40.462660364 +0800
+++ ath6kl/Makefile	2016-01-28 11:16:06.934660848 +0800
@@ -73,7 +73,6 @@
 ath6kl_usb-$(CONFIG_ACS_SUPPORT) += acs.o
 ath6kl_usb-$(CONFIG_ACL_SUPPORT) += acl_ioctl.o
 ath6kl_usb-$(CONFIG_TX99_SUPPORT) += tx99_ioctl.o
-ath6kl_usb-$(CONFIG_DIRECT_AUDIO_SUPPORT) += direct_audio.o
 
 ccflags-$(CONFIG_QC_INTERNAL) += -DCONFIG_QC_INTERNAL
 ccflags-$(CONFIG_FPGA) += -DCONFIG_FPGA
diff -urN ath6kl.orig/testmode.c ath6kl/testmode.c
--- ath6kl.orig/testmode.c	2016-01-28 11:15:40.554660366 +0800
+++ ath6kl/testmode.c	2016-01-28 11:16:06.934660848 +0800
@@ -20,6 +20,10 @@
 
 #include "core.h"
 
+#ifdef QCMBR_TCMD
+#include "ath_ioctl.h"
+#endif
+
 /*
  * netlink.h remove these macros from kernel 3.5.
  * TODO : Error handle for nla_put_XXX calls.
@@ -77,6 +81,7 @@
 	wake_up(&ar->event_wq);
 }
 
+#ifndef QCMBR_TCMD
 void ath6kl_tm_rx_event(struct ath6kl *ar, void *buf, size_t buf_len)
 {
 	struct sk_buff *skb;
@@ -105,6 +110,31 @@
 #endif
 
 }
+#else
+
+void ath6kl_tm_rx_event(struct ath6kl *ar, void *buf, size_t buf_len)
+{
+	qcmbr_queue_t *qcmbr_buf = NULL;
+
+	printk(KERN_DEBUG "%s\n", __func__);
+
+	if(buf_len == 0) {
+		printk(KERN_ERR "buf_len 0 at %s\n", __func__);
+		return;
+	}
+
+	qcmbr_buf = kmalloc(sizeof(qcmbr_queue_t), GFP_KERNEL);
+	if(qcmbr_buf != NULL) {
+		qcmbr_buf->length = buf_len;
+		memcpy(qcmbr_buf->utf_buf, buf, buf_len);
+		spin_lock_bh(&ar->qcmbr_queue_lock);
+		list_add_tail(&(qcmbr_buf->list), &ar->qcmbr_queue_head);
+		spin_unlock_bh(&ar->qcmbr_queue_lock);
+	}else {
+		printk(KERN_ERR " allocate failed %s\n", __func__);
+	}
+}
+#endif /* QCMBR_TCMD */
 
 #ifdef ATH6KL_SUPPORT_WLAN_HB
 void ath6kl_wlan_hb_event(struct ath6kl *ar, u8 value,
@@ -368,52 +398,6 @@
 	u16 enable;
 };
 
-#ifdef CONFIG_SWOW_SUPPORT
-enum nl80211_wlan_swow_cmd {
-	NL80211_WLAN_SWOW_SETMODE       = 0,
-	NL80211_WLAN_SWOW_STOP          = 1,
-	NL80211_WLAN_SWOW_SET_PWD       = 2,
-	NL80211_WLAN_SWOW_MODE_GET      = 3,
-	NL80211_WLAN_SWOW_PWD_GET       = 4,
-	NL80211_WLAN_SWOW_SET_TCP       = 5,
-	NL80211_WLAN_SWOW_SET_MAC       = 6,
-};
-enum swow_mode {
-	SWOW_INDOOR_MODE  = 0,  
-	SWOW_OUTDOOR_MODE = 1,
-};
-
-struct wlan_swow_params {
-	u16 cmd;
-	u16 mode;
-
-	union {
-		struct {
-			u8 length[8];
-			u8 password[8][16];
-			u8 mac[8][6];
-		} pwd_info;
-		struct {
-			u16 src_port;
-			u16 dst_port;
-			u32 tcp_seq;
-			u32 ack_seq;	
-			u16 ip_id;
-			u32 asyncId;
-			u32 device_ip;
-			u32 server_ip;
-			u32 gateway_ip;
-		} outdoor_tcp;
-		struct {
-			u8 gateway_mac[ETH_ALEN];
-			u8 swol_rc4_key_tx[16];
-			u8 swol_rc4_key_rx[16];
-		} outdoor_gwmac_key;
-	} params;
-};
-
-extern void swow_set_suspend(struct ath6kl_vif *vif, int enable);
-#endif //swow
 
 #if defined(CE_2_SUPPORT)
 extern unsigned int debug_mask;
@@ -806,82 +790,6 @@
 		return 0;
 
 		break;
-#ifdef CONFIG_SWOW_SUPPORT
-case ATH6KL_TM_CMD_WLAN_SWOW:
-	{
-		struct wlan_swow_params *swow_params;
-		static struct wmi_set_swol_outdoor_info_cmd outdoor_cmd;
-		static struct wmi_set_swol_indoor_info_cmd indoor_cmd;
-		struct ath6kl_vif *vif;
-
-		vif = ath6kl_vif_first(ar);
-
-		if (!vif)
-			return -EINVAL;
-			
-		if (!tb[ATH6KL_TM_ATTR_DATA]) {
-			printk(KERN_ERR "%s: NO DATA\n", __func__);
-			return -EINVAL;
-		}
-
-		buf = nla_data(tb[ATH6KL_TM_ATTR_DATA]);
-		buf_len = nla_len(tb[ATH6KL_TM_ATTR_DATA]);
-		
-		swow_params = (struct wlan_swow_params *)buf;
-		
-		if (swow_params->cmd == NL80211_WLAN_SWOW_SETMODE) {
-			printk("SWOW MODE %x \n",swow_params->mode);
-			if (swow_params->mode == SWOW_INDOOR_MODE) {
-				/*Indoor*/
-				indoor_cmd.wlan_swol_indoor = 1;
-				ath6kl_wmi_set_swol_indoor_info_cmd(
-		             ar->wmi, &indoor_cmd);
-				usleep_range(10000, 10000);
-				swow_set_suspend(vif, 1);/* enetr suspend mode */
-			} else if (swow_params->mode == SWOW_OUTDOOR_MODE) {
-				/*Outdoor*/
-				outdoor_cmd.wlan_swol_tcp_enable = 1;
-				ath6kl_wmi_set_swol_outdoor_info_cmd(ar->wmi, 1, &outdoor_cmd);
-				usleep_range(10000, 10000);
-				swow_set_suspend(vif, 1);/* enetr suspend mode */
-			}
-		} else if (swow_params->cmd == NL80211_WLAN_SWOW_STOP) {
-			/*-1 : Fail (WoWLAN mode is not running)*/
-			printk("STOP SWOW \n");
-			/*Due to wmi would be disabled, need to wake up first*/
-			swow_set_suspend(vif, 0);
-			usleep_range(10000, 10000);
-			if(indoor_cmd.wlan_swol_indoor){
-				indoor_cmd.wlan_swol_indoor = 0;
-				ath6kl_wmi_set_swol_indoor_info_cmd(ar->wmi, &indoor_cmd);
-			}
-			if(outdoor_cmd.wlan_swol_tcp_enable){
-				outdoor_cmd.wlan_swol_tcp_enable = 0;
-				ath6kl_wmi_set_swol_outdoor_info_cmd(ar->wmi, 0, &outdoor_cmd);
-			}
-		} else if (swow_params->cmd == NL80211_WLAN_SWOW_SET_PWD){
-			/*Password (0~16 B)*/
-			printk("SWOW Password Length %d\n",swow_params->params.pwd_info.length);
-		} else if (swow_params->cmd == NL80211_WLAN_SWOW_SET_TCP){
-		      outdoor_cmd.tcp_src_port = swow_params->params.outdoor_tcp.src_port;
-		      outdoor_cmd.tcp_dst_port = swow_params->params.outdoor_tcp.dst_port;
-		      outdoor_cmd.tcp_seq = swow_params->params.outdoor_tcp.tcp_seq;
-		      outdoor_cmd.ack_seq= swow_params->params.outdoor_tcp.ack_seq;
-		      outdoor_cmd.ip_id = swow_params->params.outdoor_tcp.ip_id;
-		      outdoor_cmd.device_ip = swow_params->params.outdoor_tcp.device_ip;
-		      outdoor_cmd.server_ip = swow_params->params.outdoor_tcp.server_ip;
-		      outdoor_cmd.gateway_ip= swow_params->params.outdoor_tcp.gateway_ip;
-		      outdoor_cmd.asyncId = swow_params->params.outdoor_tcp.asyncId;
-		} else if (swow_params->cmd == NL80211_WLAN_SWOW_SET_MAC){
-		      memcpy(outdoor_cmd.gateway_mac, swow_params->params.outdoor_gwmac_key.gateway_mac, ETH_ALEN);
-              memcpy(outdoor_cmd.swol_rc4_key_tx, swow_params->params.outdoor_gwmac_key.swol_rc4_key_tx, 16);
-              memcpy(outdoor_cmd.swol_rc4_key_rx, swow_params->params.outdoor_gwmac_key.swol_rc4_key_rx, 16);
-		}
-	}
-
-	return 0;
-	break;
-#endif //swow
 #ifdef ATH6KL_SUPPORT_WLAN_HB
 	case ATH6KL_TM_CMD_WLAN_HB:
 	{
diff -urN ath6kl.orig/txrx.c ath6kl/txrx.c
--- ath6kl.orig/txrx.c	2016-01-28 11:15:40.538660365 +0800
+++ ath6kl/txrx.c	2016-01-28 11:16:06.934660848 +0800
@@ -1326,14 +1326,6 @@
 			ath6kl_eapol_handshake_protect(vif, false);
 	}
 
-#ifdef DIRECT_AUDIO_SUPPORT
-#define DIRECT_AUDIO_LLC_TYPE 0x43FF
-	if (skb->protocol == cpu_to_be16(DIRECT_AUDIO_LLC_TYPE)) {
-		extern void SDA_Rx_fun( struct net_device *dev, struct sk_buff *skb);
-		SDA_Rx_fun(vif->ndev, skb);
-		return;
-	}
-#endif
 
 /*
 #if ((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)) &&	\
diff -urN ath6kl.orig/usb.c ath6kl/usb.c
--- ath6kl.orig/usb.c	2016-01-28 11:15:40.542660365 +0800
+++ ath6kl/usb.c	2016-01-28 11:16:06.934660848 +0800
@@ -1435,12 +1435,6 @@
 	ar_usb = usb_get_intfdata(interface);
 	if (ar_usb == NULL)
 		return;
-#ifdef DIRECT_AUDIO_SUPPORT
-{
-	extern void Direct_Audio_deinit(struct ath6kl *ar);
-	Direct_Audio_deinit(ar_usb->ar);
-}
-#endif
 	ath6kl_stop_txrx(ar_usb->ar);
 
 	/* Delay to wait for the target to reboot */
@@ -2732,9 +2726,6 @@
 }
 #endif
 
-#ifdef DIRECT_AUDIO_SUPPORT
-	extern void Direct_Audio_init(struct ath6kl *ar);
-#endif
 
 u8 suspend_idx = 1;
 /* ath6kl usb driver registered functions */
@@ -2878,9 +2869,6 @@
 #ifdef ATH6KL_BUS_VOTE
 	up(&usb_probe_sem);
 #endif
-#ifdef DIRECT_AUDIO_SUPPORT
-	Direct_Audio_init(ar);
-#endif
 	return ret;
 
 err_core_free:
diff -urN ath6kl.orig/wmi.c ath6kl/wmi.c
--- ath6kl.orig/wmi.c	2016-01-28 11:15:40.554660366 +0800
+++ ath6kl/wmi.c	2016-01-28 11:16:06.934660848 +0800
@@ -452,15 +452,6 @@
 					sizeof(struct ath6kl_llc_snap_hdr),
 					layer2_priority);
 		} else 
-#ifdef DIRECT_AUDIO_SUPPORT
-#define DIRECT_AUDIO_LLC_TYPE 0x43FF
-#define SDA_AC_VI_PRIORITY 0x5
-#define SDA_AC_VO_PRIORITY 0x7
-		if (llc_hdr->eth_type == htons(DIRECT_AUDIO_LLC_TYPE)){
-			usr_pri =  SDA_AC_VI_PRIORITY;
-			*phtc_tag = ATH6KL_DATA_PKT_TAG;
-		} else 
-#endif
 			usr_pri = layer2_priority & 0x7;
 
 		/*
@@ -6143,54 +6134,6 @@
 			WMI_SET_OCB_CHANNEL_OP_CMDID,
 			NO_SYNC_WMIFLAG);
 }
-#ifdef CONFIG_SWOW_SUPPORT
-int ath6kl_wmi_set_swol_indoor_info_cmd(struct wmi *wmi, struct wmi_set_swol_indoor_info_cmd *cmd)
-{
-    struct sk_buff *skb;
-
-	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
-	if (!skb)
-		return -ENOMEM;
-
-	if (cmd)
-		memcpy(skb->data, cmd, sizeof(*cmd));
-	
-	return ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_SWOL_INDOOR_INFO,
-				NO_SYNC_WMIFLAG);
-}
-
-int ath6kl_wmi_set_swol_pulse_test_cmd(struct wmi *wmi, u8 type, u8 app)
-{
-    struct sk_buff *skb;
-    struct wmi_set_swol_pulse_test_cmd *cmd;
-
-	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
-	if (!skb)
-		return -ENOMEM;
-
-	cmd = (struct wmi_set_swol_pulse_test_cmd *)skb->data;
-	cmd->swol_indoor_type = type;
-	cmd->swol_indoor_application = app;
-
-	return ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_SWOL_PULSE_TEST,
-				NO_SYNC_WMIFLAG);
-}
-
-int ath6kl_wmi_set_swol_outdoor_info_cmd(struct wmi *wmi, u8 enable, struct wmi_set_swol_outdoor_info_cmd *cmd)
-{
-    struct sk_buff *skb;
-    //struct wmi_set_swol_outdoor_info_cmd *cmd;
-
-	skb = ath6kl_wmi_get_new_buf(sizeof(*cmd));
-	if (!skb)
-		return -ENOMEM;
-
-	memcpy(skb->data, (char *)cmd, sizeof(struct wmi_set_swol_outdoor_info_cmd));  
-
-	return ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_SWOL_OUTDOOR_INFO,
-				NO_SYNC_WMIFLAG);
-}
-#endif
 int ath6kl_wmi_set_sync_tsf_cmd(struct wmi *wmi, u32 sync_tsf_p)
 {
     struct sk_buff *skb;
diff -urN ath6kl.orig/wmi.h ath6kl/wmi.h
--- ath6kl.orig/wmi.h	2016-01-28 11:15:40.474660364 +0800
+++ ath6kl/wmi.h	2016-01-28 11:16:06.934660848 +0800
@@ -3339,47 +3339,6 @@
 	u32 per_packet_rx_stats;
 } __packed;
 
-#ifdef CONFIG_SWOW_SUPPORT
-struct wmi_set_swol_indoor_info_cmd {
-	u8 wlan_swol_indoor;
-	u8 swol_indoor_key[8][16];
-	u8 swol_indoor_key_len[8];
-	u8 swol_indoor_key_mac[8][6];
-	u32 swol_indoor_app_mask[8];
-	u8 swol_indoor_waker_check;
-	u8 swol_indoor_pw_check;
-	u8 swol_indoor_pattern;
-	u8 swol_indoor_exception;
-	u8 swol_indoor_exception_app;
-	u32 swol_indoor_device_ip;
-} __packed;
-
-struct wmi_set_swol_pulse_test_cmd {
-	u8 swol_indoor_type;
-	u8 swol_indoor_application;
-} __packed;
-
-struct wmi_set_swol_outdoor_info_cmd {
-	u8 wlan_swol_tcp_enable;
-
-	u16 tcp_src_port;//NC port
-	u16 tcp_dst_port;//Push server port
-	u32 tcp_seq;	
-	u32 ack_seq;
-	
-	u16 ip_id;//NC ip
-	
-	u32 device_ip;//NC ip
-	u32 server_ip;//Push server ip
-	u32 gateway_ip;//gateway ip
-	u8 gateway_mac[ETH_ALEN];
-    
-	u32	asyncId;
-	u8	swol_rc4_key_tx[16];
-	u8	swol_rc4_key_rx[16];
-} __packed;
-
-#endif
 
 struct wmi_set_bundle_param_cmd {
 	u8 min_rx_bundle_frame;
@@ -3702,12 +3661,6 @@
 /* 802.11p */
 int ath6kl_wmi_set_ocb_channel_op(struct wmi *wmi, u8 if_idx,
 	struct wmi_set_ocb_channel_op_cmd *channel_op_cmd);
-#ifdef CONFIG_SWOW_SUPPORT
-int ath6kl_wmi_set_swol_indoor_info_cmd(struct wmi *wmi, struct wmi_set_swol_indoor_info_cmd *cmd);
-int ath6kl_wmi_set_swol_pulse_test_cmd(struct wmi *wmi, u8 type, u8 app);
-int ath6kl_wmi_set_swol_outdoor_info_cmd(struct wmi *wmi, u8 enable, 
-	struct wmi_set_swol_outdoor_info_cmd *cmd);
-#endif//swow
 
 int ath6kl_wmi_set_sync_tsf_cmd(struct wmi *wmi, u32 sync_tsf_p);
 int ath6kl_wmi_set_da_retry_limit_cmd(struct wmi *wmi, u32 retry_limit);
